/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 360);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/fragment.ts
var fragment = __webpack_require__(64);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/util/constants.ts
var constants = __webpack_require__(8);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/create-element.ts
/* eslint-disable prefer-destructuring */


function h(type, props, ...children) {
  props = props || {}

  props.children = (children.length === 0 && props.children
    ? props.children
    : children
  ).filter(Boolean)

  if (props.children.length === 1 && Array.isArray(props.children[0])) {
    props.children = props.children[0]
  }

  if (type && type.defaultProps) {
    Object.keys(type.defaultProps).forEach(prop => {
      if (props[prop] === undefined) {
        props[prop] = type.defaultProps[prop]
      }
    })
  }

  if (type && type in constants["g" /* DEFAULTS */]) {
    Object.keys(constants["g" /* DEFAULTS */][type]).forEach(prop => {
      if (props[prop] === undefined) {
        props[prop] = constants["g" /* DEFAULTS */][type][prop]
      }
    })
  }

  return { type, props }
}

/* harmony default export */ var create_element = (h);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/clone-element.ts
function cloneElement(element, props, ...children) {
  props = { ...element.props, ...(props || {}) }

  props.children = (children.length === 0 && props.children
    ? props.children
    : children
  ).filter(Boolean)

  if (props.children.length === 0) {
    props.children = element.props.children || []
  }

  if (props.children.length === 1 && Array.isArray(props.children[0])) {
    // eslint-disable-next-line prefer-destructuring
    props.children = props.children[0]
  }

  return { type: element.type, props }
}

/* harmony default export */ var clone_element = (cloneElement);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/render-to-object.ts
var render_to_object = __webpack_require__(75);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/create-from-object.ts


const CLASS_ALIASES_FLIPPED = Object(constants["n" /* objectFlip */])(constants["f" /* CLASS_ALIASES */])
const ATTR_ALIASES_FLIPPED = Object(constants["n" /* objectFlip */])(constants["a" /* ATTR_ALIASES */])
const PROMOTE_ALIASES_FLIPPED = Object(constants["l" /* categoryObjectFlip */])(constants["i" /* PROMOTE_ALIASES */])
const CHILDREN_PROPS_FLIPPED = Object(constants["n" /* objectFlip */])(constants["d" /* CHILDREN_PROPS */])
const CHILDREN_TEXT_PROPS_FLIPPED = Object(constants["n" /* objectFlip */])(constants["e" /* CHILDREN_TEXT_PROPS */])
const CHILDREN_CONTAINER_PROPS_FLIPPED = Object(constants["n" /* objectFlip */])(constants["c" /* CHILDREN_CONTAINER_PROPS */])
const SPLIT_ALIASES_FLIPPED = Object(constants["m" /* heirarchyObjectFlip */])(constants["k" /* SPLIT_ALIASES */])

function createFromObject(element, _parent) {
  if (
    typeof element === 'string' ||
    typeof element === 'number' ||
    typeof element === 'boolean' ||
    element == null
  ) {
    return element
  }
  if (Array.isArray(element)) {
    const result = []

    for (let i = 0, len = element.length; i < len; i++) {
      result.push(createFromObject(element[i], element))
    }

    return result
  }

  let { type } = element

  if (!type) {
    if ('value' in element && 'title' in element) {
      type = 'Input.Choice'
    }
  }

  if (type && typeof type === 'string') {
    const result = {
      type: CLASS_ALIASES_FLIPPED[type],
      props: { children: [] }
    }

    Object.keys(element).forEach(key => {
      if (constants["b" /* CASE_INSENSITIVE */][key] === true) {
        const str = element[key]
        if (str && typeof str === 'string') {
          element[key] = str.charAt(0).toLowerCase() + str.slice(1)
        }
      }
    })

    if (type in SPLIT_ALIASES_FLIPPED) {
      const { type: newType, subtype } = SPLIT_ALIASES_FLIPPED[type]
      const newElement = { ...element, type: newType }
      const newResult = createFromObject(newElement, _parent)
      newResult.type = newType
      newResult.props.type = subtype
      return newResult
    }

    Object.keys(element).forEach(key => {
      if (key === 'type') {
        /** noop */
      } else if (key in CHILDREN_PROPS_FLIPPED) {
        const newChildren = createFromObject(element[key], element)
        result.props.children = result.props.children.concat(newChildren)
      } else if (key in CHILDREN_TEXT_PROPS_FLIPPED) {
        const newChildren = createFromObject(element[key], element)
        result.props.children = result.props.children.concat(newChildren)
      } else if (key in CHILDREN_CONTAINER_PROPS_FLIPPED) {
        const newChildren = createFromObject(element[key], element)

        result.props.children = result.props.children.concat({
          type: CHILDREN_CONTAINER_PROPS_FLIPPED[key],
          props: { children: newChildren }
        })
      } else if (
        type in PROMOTE_ALIASES_FLIPPED &&
        key in PROMOTE_ALIASES_FLIPPED[type]
      ) {
        const childNewType = PROMOTE_ALIASES_FLIPPED[type][key]
        const children = element[key]

        if (
          typeof children === 'string' ||
          typeof children === 'number' ||
          typeof children === 'boolean'
        ) {
          result.props.children.push({
            type: childNewType,
            props: { children }
          })
        } else if (Array.isArray(children)) {
          result.props.children = result.props.children.concat({
            type: childNewType,
            props: {
              children: children.map(child => {
                const newChild = createFromObject(child, element)
                return newChild
              })
            }
          })
        } else {
          result.props.children.push({
            type: childNewType,
            props: { ...children }
          })
        }
      } else {
        result.props[key] = createFromObject(element[key], element)
      }
    })

    return result
  }

  console.error(`Warning invalid card element type ${JSON.stringify(element)}`)
  return element
  // throw new Error(`Invalid card element type ${JSON.stringify(element)}`)
}

/* harmony default export */ var create_from_object = (createFromObject);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/util/children.ts
var util_children = __webpack_require__(55);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/util/rhast2jsx.ts + 1 modules
var rhast2jsx = __webpack_require__(85);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/util/rcast2rhast.ts
var rcast2rhast = __webpack_require__(81);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/index.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Children", function() { return Children; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "util", function() { return util; });
/* concated harmony reexport Fragment */__webpack_require__.d(__webpack_exports__, "Fragment", function() { return fragment["Fragment"]; });
/* concated harmony reexport h */__webpack_require__.d(__webpack_exports__, "h", function() { return create_element; });
/* concated harmony reexport createElement */__webpack_require__.d(__webpack_exports__, "createElement", function() { return create_element; });
/* concated harmony reexport cloneElement */__webpack_require__.d(__webpack_exports__, "cloneElement", function() { return clone_element; });
/* concated harmony reexport renderToObject */__webpack_require__.d(__webpack_exports__, "renderToObject", function() { return render_to_object["a" /* default */]; });
/* concated harmony reexport render */__webpack_require__.d(__webpack_exports__, "render", function() { return render_to_object["a" /* default */]; });
/* concated harmony reexport createFromObject */__webpack_require__.d(__webpack_exports__, "createFromObject", function() { return create_from_object; });
/* concated harmony reexport setLocalResourceProtocolMapper */__webpack_require__.d(__webpack_exports__, "setLocalResourceProtocolMapper", function() { return render_to_object["b" /* setLocalResourceProtocolMapper */]; });









const Children = { toArray: util_children["a" /* toArray */] }
const util = { rcast2rhast: rcast2rhast["a" /* rcast2rhast */], rhast2jsx: rhast2jsx["a" /* rhast2jsx */] }




/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Encoding", function() { return Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bytesToUrlBase64", function() { return bytesToUrlBase64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b64Encode", function() { return b64Encode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b64Decode", function() { return b64Decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bytesToString", function() { return bytesToString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringToBytes", function() { return stringToBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlBase64ToString", function() { return urlBase64ToString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringToUrlBase64", function() { return stringToUrlBase64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bytesToHex", function() { return bytesToHex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexToBase64", function() { return hexToBase64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexToBytes", function() { return hexToBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numToHex", function() { return numToHex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strToHex", function() { return strToHex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineArrays", function() { return combineArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromUrlSafeBase64", function() { return fromUrlSafeBase64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toUrlSafeBase64", function() { return toUrlSafeBase64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint8ArrayToSafeBase64Url", function() { return uint8ArrayToSafeBase64Url; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "safeBase64UrlToUint8Array", function() { return safeBase64UrlToUint8Array; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayBuffersToCryptoKeys", function() { return arrayBuffersToCryptoKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cryptoKeysToUint8Array", function() { return cryptoKeysToUint8Array; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "joinUint8Arrays", function() { return joinUint8Arrays; });
/* eslint-disable prefer-destructuring */
function Encoding(b64) {
  return bytesToHex(b64Decode(b64))
}

function bytesToUrlBase64(u8) {
  return b64Encode(u8).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '')
}

function b64Encode(buff) {
  return btoa(
    new Uint8Array(buff).reduce((s, b) => s + String.fromCharCode(b), '')
  )
}

function b64Decode(b64) {
  const byteString = atob(b64)
  const byteArray = new Uint8Array(byteString.length)
  for (let i = 0; i < byteString.length; i++) {
    byteArray[i] = byteString.charCodeAt(i)
  }

  return byteArray
}

function bytesToString(bytes) {
  return String.fromCharCode.apply(null, new Uint8Array(bytes))
}

function stringToBytes(input) {
  const buf = new Uint8Array(input.length)
  for (let i = 0, strLen = input.length; i < strLen; i++) {
    buf[i] = input.charCodeAt(i)
  }
  return buf
}

function urlBase64ToString(str) {
  return atob(str.replace(/-/g, '+').replace(/_/g, '/'))
}

function stringToUrlBase64(str) {
  return binaryStringToUrlBase64(utf8ToBinaryString(str))
}

function binaryStringToUrlBase64(bin) {
  return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+/g, '')
}

function utf8ToBinaryString(str) {
  const escstr = encodeURIComponent(str)
  const binstr = escstr.replace(/%([0-9A-F]{2})/g, (match, p1) => {
    return String.fromCharCode(parseInt(p1, 16))
  })

  return binstr
}

function bytesToHex(input) {
  return input
    .reduce((prev, i) => {
      return prev + `0${i.toString(16)}`.slice(-2)
    }, '')
    .toLowerCase()
}

function hexToBase64(hexString) {
  return b64Encode(hexToBytes(hexString))
}

function hexToBytes(hexString) {
  return new Uint8Array(
    hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
  )
}

function numToHex(input) {
  const d = input.toString(16)
  if (d.length % 2) {
    return `0${d}`
  }
  return d
}

function strToHex(str) {
  return bytesToHex(stringToBytes(str))
}

function combineArrays(a, b) {
  const result = new Uint8Array(a.length + b.length)
  result.set(a)
  result.set(b, a.length)
  return result
}

function fromUrlSafeBase64(base64url) {
  const { length } = base64url
  return `${base64url.replace(/-/g, '+').replace(/_/g, '/')}${new Array(
    5 - (length % 4)
  ).join('=')}`
}

function toUrlSafeBase64(base64) {
  return base64.replace(/\//g, '_').replace(/\+/g, '-').replace(/=/g, '')
}

function uint8ArrayToSafeBase64Url(
  uint8Array,
  start,
  end
) {
  start = start || 0
  end = end || uint8Array.byteLength

  const base64 = btoa(
    String.fromCharCode.apply(null, uint8Array.subarray(start, end))
  )
  return base64.replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_')
}

function safeBase64UrlToUint8Array(base64UrlData) {
  const padding = '='.repeat((4 - (base64UrlData.length % 4)) % 4)
  const base64 = (base64UrlData + padding).replace(/-/g, '+').replace(/_/g, '/')

  const rawData = atob(base64)
  const buffer = new Uint8Array(rawData.length)

  for (let i = 0; i < rawData.length; ++i) {
    buffer[i] = rawData.charCodeAt(i)
  }
  return buffer
}

function arrayBuffersToCryptoKeys(
  publicKey,
  privateKey
) {
  // Length, in bytes, of a P-256 field element. Expected format of the private
  // key.
  const PRIVATE_KEY_BYTES = 32

  // Length, in bytes, of a P-256 public key in uncompressed EC form per SEC
  // 2.3.3. This sequence must start with 0x04. Expected format of the
  // public key.
  const PUBLIC_KEY_BYTES = 65

  if (publicKey.byteLength !== PUBLIC_KEY_BYTES) {
    throw new Error(
      `The publicKey is expected to be ${PUBLIC_KEY_BYTES} bytes.`
    )
  }

  // Cast ArrayBuffer to Uint8Array
  const publicBuffer = new Uint8Array(publicKey)
  if (publicBuffer[0] !== 0x04) {
    throw new Error('The publicKey is expected to start with an 0x04 byte.')
  }

  const jwk = {
    kty: 'EC',
    crv: 'P-256',
    x: uint8ArrayToSafeBase64Url(publicBuffer, 1, 33),
    y: uint8ArrayToSafeBase64Url(publicBuffer, 33, 65),
    ext: true,
    d: undefined
  }

  const keyPromises = []
  keyPromises.push(
    crypto.subtle.importKey(
      'jwk',
      jwk,
      { name: 'ECDH', namedCurve: 'P-256' },
      true,
      []
    )
  )

  if (privateKey) {
    if (privateKey.byteLength !== PRIVATE_KEY_BYTES) {
      throw new Error(
        `The privateKey is expected to be ${PRIVATE_KEY_BYTES} bytes.`
      )
    }

    // d must be defined after the importKey call for public
    jwk.d = uint8ArrayToSafeBase64Url(privateKey)
    keyPromises.push(
      crypto.subtle.importKey(
        'jwk',
        jwk,
        { name: 'ECDH', namedCurve: 'P-256' },
        true,
        ['deriveBits']
      )
    )
  }

  return Promise.all(keyPromises).then((keys) => {
    const keyPair = {
      publicKey: keys[0]
    }
    if (keys.length > 1) {
      keyPair.privateKey = keys[1]
    }
    return keyPair
  })
}

function cryptoKeysToUint8Array(
  publicKey,
  privateKey
)


 {
  return Promise.resolve()
    .then(() => {
      const promises = []
      promises.push(
        crypto.subtle.exportKey('jwk', publicKey).then((jwk) => {
          const x = safeBase64UrlToUint8Array(jwk.x)
          const y = safeBase64UrlToUint8Array(jwk.y)

          const publicKey = new Uint8Array(65)
          publicKey.set([0x04], 0)
          publicKey.set(x, 1)
          publicKey.set(y, 33)

          return publicKey
        })
      )

      if (privateKey) {
        promises.push(
          crypto.subtle.exportKey('jwk', privateKey).then((jwk) => {
            return safeBase64UrlToUint8Array(jwk.d)
          })
        )
      }

      return Promise.all(promises)
    })
    .then((exportedKeys) => {
      const result


 = {
        publicKey: exportedKeys[0]
      }

      if (exportedKeys.length > 1) {
        result.privateKey = exportedKeys[1]
      }

      return result
    })
}

function joinUint8Arrays(allUint8Arrays) {
  return allUint8Arrays.reduce(function reduce(cumulativeValue, nextValue) {
    if (!(nextValue instanceof Uint8Array)) {
      console.error('Received an non-Uint8Array value:', nextValue)
      throw new Error('Received an non-Uint8Array value.')
    }

    const joinedArray = new Uint8Array(
      cumulativeValue.byteLength + nextValue.byteLength
    )
    joinedArray.set(cumulativeValue, 0)
    joinedArray.set(nextValue, cumulativeValue.byteLength)
    return joinedArray
  }, new Uint8Array())
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __extends; });
/* unused harmony export __assign */
/* unused harmony export __rest */
/* unused harmony export __decorate */
/* unused harmony export __param */
/* unused harmony export __metadata */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __awaiter; });
/* unused harmony export __generator */
/* unused harmony export __createBinding */
/* unused harmony export __exportStar */
/* unused harmony export __values */
/* unused harmony export __read */
/* unused harmony export __spread */
/* unused harmony export __spreadArrays */
/* unused harmony export __await */
/* unused harmony export __asyncGenerator */
/* unused harmony export __asyncDelegator */
/* unused harmony export __asyncValues */
/* unused harmony export __makeTemplateObject */
/* unused harmony export __importStar */
/* unused harmony export __importDefault */
/* unused harmony export __classPrivateFieldGet */
/* unused harmony export __classPrivateFieldSet */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BotAdapterMiddleware", function() { return _adapter__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "URN_BOTADAPTER", function() { return _adapter__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony import */ var iopa_botadapter_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(196);
/* harmony import */ var iopa_botadapter_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(iopa_botadapter_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (checked) */ if(__webpack_require__.o(iopa_botadapter_types__WEBPACK_IMPORTED_MODULE_1__, "CardFactory")) __webpack_require__.d(__webpack_exports__, "CardFactory", function() { return iopa_botadapter_types__WEBPACK_IMPORTED_MODULE_1__["CardFactory"]; });

/* harmony reexport (checked) */ if(__webpack_require__.o(iopa_botadapter_types__WEBPACK_IMPORTED_MODULE_1__, "MessageFactory")) __webpack_require__.d(__webpack_exports__, "MessageFactory", function() { return iopa_botadapter_types__WEBPACK_IMPORTED_MODULE_1__["MessageFactory"]; });

/* harmony import */ var iopa_botadapter_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var iopa_botadapter_schema__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(iopa_botadapter_schema__WEBPACK_IMPORTED_MODULE_2__);
/* harmony reexport (checked) */ if(__webpack_require__.o(iopa_botadapter_schema__WEBPACK_IMPORTED_MODULE_2__, "CardFactory")) __webpack_require__.d(__webpack_exports__, "CardFactory", function() { return iopa_botadapter_schema__WEBPACK_IMPORTED_MODULE_2__["CardFactory"]; });

/* harmony reexport (checked) */ if(__webpack_require__.o(iopa_botadapter_schema__WEBPACK_IMPORTED_MODULE_2__, "MessageFactory")) __webpack_require__.d(__webpack_exports__, "MessageFactory", function() { return iopa_botadapter_schema__WEBPACK_IMPORTED_MODULE_2__["MessageFactory"]; });

/* harmony import */ var iopa_botadapter_schema_teams__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78);
/* harmony import */ var iopa_botadapter_schema_teams__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(iopa_botadapter_schema_teams__WEBPACK_IMPORTED_MODULE_3__);
/* harmony reexport (checked) */ if(__webpack_require__.o(iopa_botadapter_schema_teams__WEBPACK_IMPORTED_MODULE_3__, "CardFactory")) __webpack_require__.d(__webpack_exports__, "CardFactory", function() { return iopa_botadapter_schema_teams__WEBPACK_IMPORTED_MODULE_3__["CardFactory"]; });

/* harmony reexport (checked) */ if(__webpack_require__.o(iopa_botadapter_schema_teams__WEBPACK_IMPORTED_MODULE_3__, "MessageFactory")) __webpack_require__.d(__webpack_exports__, "MessageFactory", function() { return iopa_botadapter_schema_teams__WEBPACK_IMPORTED_MODULE_3__["MessageFactory"]; });

/* harmony import */ var iopa_botadapter_cards__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CardFactory", function() { return iopa_botadapter_cards__WEBPACK_IMPORTED_MODULE_4__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MessageFactory", function() { return iopa_botadapter_cards__WEBPACK_IMPORTED_MODULE_4__["b"]; });







// note: do not export testing-framework as msw distorts response in cloudlfare environment


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable
/**
 * Microsoft Bot Connector API - v3.0
 * The Bot Connector REST API allows your bot to send and receive messages to channels configured in the  [Bot Framework Developer Portal](https://dev.botframework.com). The Connector service uses industry-standard REST  and JSON over HTTPS.    Client libraries for this REST API are available. See below for a list.    Many bots will use both the Bot Connector REST API and the associated [Bot State REST API](/en-us/restapi/state). The  Bot State REST API allows a bot to store and retrieve state associated with users and conversations.    Authentication for both the Bot Connector and Bot State REST APIs is accomplished with JWT Bearer tokens, and is  described in detail in the [Connector Authentication](/en-us/restapi/authentication) document.    # Client Libraries for the Bot Connector REST API    * [Bot Builder for C#](/en-us/csharp/builder/sdkreference/)  * [Bot Builder for Node.js](/en-us/node/builder/overview/)  * Generate your own from the [Connector API Swagger file](https://raw.githubusercontent.com/Microsoft/BotBuilder/master/CSharp/Library/Microsoft.Bot.Connector.Shared/Swagger/ConnectorAPI.json)    Â© 2016 Microsoft
 *
 * OpenAPI spec version: v3
 * Contact: botframework@microsoft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(229), exports);
__exportStar(__webpack_require__(230), exports);
//# sourceMappingURL=index.js.map

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(9)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/lib/iopaRef.ts


// RFC 2141 with the addition of allowing periods in the first segment / domain name and allowing only one segment
const URN_WEAK = new RegExp(
  /^urn:[a-z0-9][a-z0-9-]{0,31}(:([a-z0-9()+,\-.:=@;$_!*']|%[0-9a-f]{2})+)?$/
)

// RFC 2141 strict
const URN_STRICT = new RegExp(
  /^urn:[a-z0-9][a-z0-9-]{0,31}(:([a-z0-9()+,\-.:=@;$_!*']|%[0-9a-f]{2})+)?$/
)

class IopaRefImpl {
  constructor(  config) {;this.config = config;
    if (!config.id.startsWith('urn:')) {
      config.id = `urn:${config.id}`
    }
    const valid = URN_STRICT.test(config.id)
    if (!valid) {
      if (URN_WEAK.test(config.id)) {
        throw new Error(
          `Iopa Ref id must be a valid URN according to RFC2141, got '${config.id}'`
        )
      }
    }
  }

  get id() {
    return this.config.id
  }

  get description() {
    return this.config.description
  }

  // Utility for getting type of an IOPA Ref, using `typeof iopaRef.T`
  get T() {
    throw new Error(`tried to read iopaRef.T of ${this}`)
  }

  toString() {
    return `iopaRef{${this.config.id}}`
  }
}

function createIopaRef(config) {
  return new IopaRefImpl(config)
}

function createCapabilityRef(config) {
  return createIopaRef(config)
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/lib/create-plugin.ts


function createPlugin(props) {
    return class  {
        

        constructor(app) {
            this.props = props
            this.props.register({
                app,
                router: app,
                featureFlags: {
                    register(name) {
                        app.registerFeatureFlag({ name })
                    },
                },
            })
        }

         get id() {
            return this.props.id
        }

         get description() {
            return this.props.description
        }

         get title() {
            return this.props.title
        }

         get icon() {
            return this.props.icon
        }

        toString() {
            return `plugin{${this.props.id}}`
        }
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/lib/index.ts
/* concated harmony reexport createIopaRef */__webpack_require__.d(__webpack_exports__, "a", function() { return createIopaRef; });
/* unused concated harmony import createCapabilityRef */
/* unused concated harmony import createPlugin */




/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return CLASS_ALIASES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return IMPLICIT_ALIASES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return RAW_ALIASES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ATTR_ALIASES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return PROMOTE_ALIASES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return CHILDREN_PROPS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return CHILDREN_TEXT_PROPS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return CHILDREN_CONTAINER_PROPS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return SPLIT_ALIASES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CASE_INSENSITIVE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return DEFAULTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return objectFlip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return categoryObjectFlip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return heirarchyObjectFlip; });
const CLASS_ALIASES = {
  card: 'AdaptiveCard',
  // card elements
  text: 'TextBlock',
  image: 'Image',
  media: 'Media',
  mediasource: 'MediaSource',
  // containers
  container: 'Container',
  columnset: 'ColumnSet',
  column: 'Column',
  factset: 'FactSet',
  fact: 'Fact',
  imageset: 'ImageSet',
  // inputs
  choice: 'Input.Choice',
  actionset: 'ActionSet'
}

const IMPLICIT_ALIASES = { 'Input.Choice': 'choice' }

const RAW_ALIASES = { speak: 'speak' }

const ATTR_ALIASES = {
  /* intentionally left blank */
}

const PROMOTE_ALIASES = {
  card: {
    body: 'body',
    actionset: 'actions',
    speak: 'speak',
    fallback: 'fallback'
  },
  image: {
    action: 'selectAction'
  },
  container: {
    action: 'selectAction'
  },
  columnset: {
    action: 'selectAction'
  },
  column: {
    action: 'selectAction'
  }
}

const CHILDREN_PROPS = {
  container: 'items',
  columnset: 'columns',
  column: 'items',
  factset: 'facts',
  imageset: 'images',
  choiceset: 'choices',
  media: 'sources'
  //  input: "actionset"
}

const CHILDREN_TEXT_PROPS = {
  action: 'title',
  text: 'text',
  choice: 'title'
}

const CHILDREN_CONTAINER_PROPS = {
  actionset: 'actions'
}

const SPLIT_ALIASES = {
  action: {
    openurl: 'Action.OpenUrl',
    submit: 'Action.Submit',
    showcard: 'Action.ShowCard'
  },
  input: {
    date: 'Input.Date',
    time: 'Input.Time',
    number: 'Input.Number',
    text: 'Input.Text',
    toggle: 'Input.Toggle',
    choiceset: 'Input.ChoiceSet',
    file: 'Input.File',
    video: 'Input.Video'
  }
}

const CASE_INSENSITIVE = {
  spacing: true,
  style: true,
  horizontalAlignment: true,
  size: true,
  imageSize: true,
  color: true,
  weight: true,
  thickness: true
}

const DEFAULTS = {
  card: {
    $schema: 'http://adaptivecards.io/schemas/adaptive-card.json',
    version: '1.2',
    style: 'default'
  }
}

function objectFlip(obj) {
  const ret = {}
  Object.keys(obj).forEach((key) => {
    ret[obj[key]] = key
  })
  return ret
}

function categoryObjectFlip(obj) {
  const ret = {}
  Object.keys(obj).forEach((key) => {
    ret[CLASS_ALIASES[key]] = objectFlip(obj[key])
  })
  return ret
}

function heirarchyObjectFlip(obj) {
  const ret = {}
  Object.keys(obj).forEach((key) => {
    const child = obj[key]
    Object.keys(child).forEach((childkey) => {
      ret[child[childkey]] = { type: key, subtype: childkey }
    })
  })
  return ret
}


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(232)
var ieee754 = __webpack_require__(233)
var isArray = __webpack_require__(136)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16)))

/***/ }),
/* 10 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InputHints = exports.ActivityTypes = exports.CarrierApi = void 0;
__exportStar(__webpack_require__(357), exports);
var api_1 = __webpack_require__(197);
Object.defineProperty(exports, "CarrierApi", { enumerable: true, get: function () { return api_1.DefaultApi; } });
var iopa_botadapter_schema_1 = __webpack_require__(5);
Object.defineProperty(exports, "ActivityTypes", { enumerable: true, get: function () { return iopa_botadapter_schema_1.ActivityTypes; } });
Object.defineProperty(exports, "InputHints", { enumerable: true, get: function () { return iopa_botadapter_schema_1.InputHints; } });
//# sourceMappingURL=index.js.map

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(212);
var util = __webpack_require__(213);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(214);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export JsonWebTokenError */
/* unused harmony export JOSEInvalidEncodingError */
/* unused harmony export JOSEMultiError */
/* unused harmony export JOSEAlgNotWhitelistedError */
/* unused harmony export JOSECritNotUnderstoodError */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return JOSENotSupportedError; });
/* unused harmony export JWEDecryptionFailedError */
/* unused harmony export JWEInvalidError */
/* unused harmony export JWKImportFailedError */
/* unused harmony export JWKInvalidError */
/* unused harmony export JWKKeySupportError */
/* unused harmony export JWKStoreNoMatchingKeyError */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return JWSInvalidError; });
/* unused harmony export JWSVerificationFailedError */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return JWTClaimInvalidError; });
/* unused harmony export JWTExpiredError */
/* unused harmony export JWTNotBeforeError */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return JWTMalformed; });
class JsonWebTokenError extends Error {
  

  

  constructor(code, message, inner) {
    super()
    this.message = message
    this.code = code
    this.inner = inner
  }
}

class JOSEInvalidEncodingError extends JsonWebTokenError

 {
  constructor(message, err) {
    super('ERR_JOSE_INVALID_ENCODING', message, err)
  }
}

class JOSEMultiError extends JsonWebTokenError

 {
  constructor(message, err) {
    super('ERR_JOSE_MULTIPLE_ERRORS', message, err)
  }
}

class JOSEAlgNotWhitelistedError extends JsonWebTokenError

 {
  constructor(message, err) {
    super('ERR_JOSE_ALG_NOT_WHITELISTED', message, err)
  }
}

class JOSECritNotUnderstoodError extends JsonWebTokenError

 {
  constructor(message, err) {
    super('ERR_JOSE_CRIT_NOT_UNDERSTOOD', message, err)
  }
}

class JOSENotSupportedError extends JsonWebTokenError

 {
  constructor(message, err) {
    super('ERR_JOSE_NOT_SUPPORTED', message, err)
  }
}

class JWEDecryptionFailedError extends JsonWebTokenError

 {
  constructor(message, err) {
    super('ERR_JWE_DECRYPTION_FAILED', message, err)
  }
}

class JWEInvalidError extends JsonWebTokenError {
  constructor(message, err) {
    super('ERR_JWE_INVALID', message, err)
  }
}

class JWKImportFailedError extends JsonWebTokenError

 {
  constructor(message, err) {
    super('ERR_JWK_IMPORT_FAILED', message, err)
  }
}

class JWKInvalidError extends JsonWebTokenError {
  constructor(message, err) {
    super('ERR_JWK_INVALID', message, err)
  }
}

class JWKKeySupportError extends JsonWebTokenError

 {
  constructor(message, err) {
    super('ERR_JWK_KEY_SUPPORT', message, err)
  }
}

class JWKStoreNoMatchingKeyError extends JsonWebTokenError

 {
  constructor(message, err) {
    super('ERR_JWKSTORE_NO_MATCHING_KEY', message, err)
  }
}

class JWSInvalidError extends JsonWebTokenError {
  constructor(message, err) {
    super('ERR_JWS_INVALID', message, err)
  }
}

class JWSVerificationFailedError extends JsonWebTokenError

 {
  constructor(message, err) {
    super('ERR_JWS_VERIFICATION_FAILED', message, err)
  }
}

class JWTClaimInvalidError extends JsonWebTokenError

 {
  constructor(
    message,
    claim,
    reason





  ) {
    super('ERR_JWT_CLAIM_INVALID', message, new Error(message))
    this.claim = claim
    this.reason = reason
  }

  

  
}

class JWTExpiredError extends JsonWebTokenError {
  

  constructor(message, expiredAt) {
    super('ERR_JWT_EXPIRED', message)
    this.expiredAt = expiredAt
  }
}

class JWTNotBeforeError extends JsonWebTokenError {
  

  constructor(message, date) {
    super('ERR_JWT_NOT_BEFORE', message)
    this.date = date
  }
}

class JWTMalformed extends JsonWebTokenError {
  constructor(message, err) {
    super('ERR_JWT_MALFORMED', message, err)
  }
}


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return IopaMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IopaHeaders; });








class IopaMap {
  constructor(data, prevData) {
    if (prevData) {
      this._loadEntries(prevData.entries())
    }
    if (data) {
      if (Array.isArray(data)) {
        this._loadEntries(data)
      } else if ('entries' in data) {
        this._loadEntries((data.entries )())
      } else {
        this._loadEntries(
          Object.entries((data ) ) 



        )
      }
    }
  }

   _loadEntries(entries) {
    for (const entry of entries) {
      this.set(entry[0], entry[1])
    }
  }

  get(key) {
    return this[(key ) ]
  }

  has(key) {
    return key in this
  }

  addRef(iopaRef, value) {
    this[iopaRef.id] = value
    return value
  }

  getRef(iopaRef) {
    return this[iopaRef.id]
  }

  



  set(data, value) {
    if (value || typeof data !== 'object') {
      this[(data ) ] = value
      return
    }
    if (Array.isArray(data)) {
      this._loadEntries(data)
    } else if ('entries' in data) {
      this._loadEntries((data.entries )())
    } else {
      this._loadEntries(
        Object.entries((data ) ) 



      )
    }
  }

  default(key, valueFn) {
    if (key in this) {
      /** noop */
    } else if (typeof valueFn === 'function') {
      this.set(key, (valueFn )())
    } else {
      this.set(key, valueFn)
    }
    return this.get(key)
  }

  entries() {
    return Object.entries(this) 
  }

  delete(key) {
    if (key in this) {
      delete this[(key ) ]
      return true
    }
    return false
  }

  toString() {
    return jsonSerialize(this.toJSON())
  }

  toJSON() {
    const jsonObj = {}

    for (const key of Object.getOwnPropertyNames(this).filter(
      (key) => !key.startsWith('_') && !BLACK_LIST_STRINGIFY.includes(key)
    )) {
      jsonObj[key] = this[key]
    }

    const proto1 = Object.getPrototypeOf(this)
    const proto2 = Object.getPrototypeOf(proto1)
    ;[proto1, proto2].forEach((proto) => {
      for (const key of Object.getOwnPropertyNames(proto)) {
        const desc = Object.getOwnPropertyDescriptor(proto, key)
        const hasGetter = desc && typeof desc.get === 'function'
        if (hasGetter) {
          jsonObj[key] = desc.get.call(this)
        }
      }
    })

    return jsonObj
  }
}

const getCircularReplacer = () => {
  const seen = new WeakSet()
  return (key, value) => {
    if (typeof value === 'object' && value !== null) {
      if (seen.has(value)) {
        return undefined
      }
      seen.add(value)
      if ('toJSON' in value) {
        return value.toJSON()
      }
    }
    return value
  }
}

const jsonSerialize = (data) => JSON.stringify(data, getCircularReplacer(), 2)


class IopaHeaders extends IopaMap {
  get(name) {
    name = `${name}`
    const key = find(this, name)
    if (key === undefined) {
      return null
    }

    let val = this[key]
    if (name.toLowerCase() === 'content-encoding') {
      val = val.toLowerCase()
    }

    return val
  }

  set(data, value) {
    if (typeof data === 'string') {
      return super.set(find(this, data) || data, value)
    }

    return super.set(data, value)
  }

  has(name) {
    return !!find(this, `${name}`)
  }
}

/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */
function find(map, name) {
  name = name.toLowerCase()
  return Object.keys(map).find((key) => key.toLowerCase() === name)
}

const BLACK_LIST_STRINGIFY = [
  'server.CancelToken',
  'server.CancelTokenSource',
  'get',
  'set',
  'delete',
  'toJSON',
  'capability',
  'setCapability',
  'iopa.Events',
  'server.Capabilities'
]


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RequestMethod; });
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @enum
 * Enum for RequestMethods
 * @property {string} GET - The get request type
 * @property {string} PATCH - The patch request type
 * @property {string} POST - The post request type
 * @property {string} PUT - The put request type
 * @property {string} DELETE - The delete request type
 */
var RequestMethod;
(function (RequestMethod) {
    RequestMethod["GET"] = "GET";
    RequestMethod["PATCH"] = "PATCH";
    RequestMethod["POST"] = "POST";
    RequestMethod["PUT"] = "PUT";
    RequestMethod["DELETE"] = "DELETE";
})(RequestMethod || (RequestMethod = {}));
//# sourceMappingURL=RequestMethod.js.map

/***/ }),
/* 16 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MiddlewareControl; });
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @class
 * Class representing MiddlewareControl
 */
class MiddlewareControl {
    /**
     * @public
     * @constructor
     * Creates an instance of MiddlewareControl
     * @param {MiddlewareOptions[]} [middlewareOptions = []] - The array of middlewareOptions
     * @returns The instance of MiddlewareControl
     */
    constructor(middlewareOptions = []) {
        // tslint:disable-next-line:ban-types
        this.middlewareOptions = new Map();
        for (const option of middlewareOptions) {
            const fn = option.constructor;
            this.middlewareOptions.set(fn, option);
        }
    }
    /**
     * @public
     * To get the middleware option using the class of the option
     * @param {Function} fn - The class of the strongly typed option class
     * @returns The middleware option
     * @example
     * // if you wanted to return the middleware option associated with this class (MiddlewareControl)
     * // call this function like this:
     * getMiddlewareOptions(MiddlewareControl)
     */
    // tslint:disable-next-line:ban-types
    getMiddlewareOptions(fn) {
        return this.middlewareOptions.get(fn);
    }
    /**
     * @public
     * To set the middleware options using the class of the option
     * @param {Function} fn - The class of the strongly typed option class
     * @param {MiddlewareOptions} option - The strongly typed middleware option
     * @returns nothing
     */
    // tslint:disable-next-line:ban-types
    setMiddlewareOptions(fn, option) {
        this.middlewareOptions.set(fn, option);
    }
}
//# sourceMappingURL=MiddlewareControl.js.map

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var time_util_namespaceObject = {};
__webpack_require__.r(time_util_namespaceObject);
__webpack_require__.d(time_util_namespaceObject, "timespan", function() { return timespan; });
__webpack_require__.d(time_util_namespaceObject, "now", function() { return now; });
__webpack_require__.d(time_util_namespaceObject, "parseSeconds", function() { return parseSeconds; });
__webpack_require__.d(time_util_namespaceObject, "format", function() { return time_util_format; });

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/converters/pem.ts
var converters_pem = __webpack_require__(26);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/converters/encoding.ts
var encoding = __webpack_require__(1);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/converters/asn1.ts
/* eslint-disable no-bitwise */










function ASN1(typ, ...hexstrings) {
  const str = hexstrings.join('').replace(/\s+/g, '').toLowerCase()
  let len = str.length / 2
  let lenlen = 0
  let hex = typ

  if (len !== Math.round(len)) {
    throw new Error('invalid hex')
  }

  // The first byte of any ASN.1 sequence is the type (Sequence, Integer, etc)
  // The second byte is either the size of the value, or the size of its size

  // 1. If the second byte is < 0x80 (128) it is considered the size
  // 2. If it is > 0x80 then it describes the number of bytes of the size
  //    ex: 0x82 means the next 2 bytes describe the size of the value
  // 3. The special case of exactly 0x80 is "indefinite" length (to end-of-file)

  if (len > 127) {
    lenlen += 1
    while (len > 255) {
      lenlen += 1
      len >>= 8
    }
  }

  if (lenlen) {
    hex += encoding["numToHex"](0x80 + lenlen)
  }
  return hex + encoding["numToHex"](str.length / 2) + str
}

// The Integer type has some special rules
function Integer(str) {
  const first = parseInt(str.slice(0, 2), 16)

  // If the first byte is 0x80 or greater, the number is considered negative
  // Therefore we add a '00' prefix if the 0x80 bit is set
  if (0x80 & first) {
    str = `00${str}`
  }

  return ASN1('02', str)
}

// The Bit String type also has a special rule
function BitString(str) {
  // '00' is a mask of how many bits of the next byte to ignore
  return ASN1('03', `00${str}`)
}

//
// Parser
//

const ELOOP =
  'uASN1.js Error: iterated over 15+ elements (probably a malformed file)'
const EDEEP =
  'uASN1.js Error: element nested 20+ layers deep (probably a malformed file)'
// Container Types are Sequence 0x30, Octect String 0x04, Array? (0xA0, 0xA1)
// Value Types are Integer 0x02, Bit String 0x03, Null 0x05, Object ID 0x06,
// Sometimes Bit String is used as a container (RSA Pub Spki)
const VTYPES = [0x02, 0x03, 0x05, 0x06, 0x0c, 0x82]

function parse(buf, depth, ws = '') {
  if (!ws) {
    ws = ''
  }
  if (depth >= 20) {
    throw new Error(EDEEP)
  }

  let index = 2 // we know, at minimum, data starts after type (0) and lengthSize (1)
  const asn1 = { type: buf[0], lengthSize: 0, length: buf[1] }
  let child
  let iters = 0
  let adjust = 0

  // Determine how many bytes the length uses, and what it is
  if (0x80 & asn1.length) {
    asn1.lengthSize = 0x7f & asn1.length
    // I think that buf->hex->int solves the problem of Endianness... not sure
    asn1.length = parseInt(
      encoding["bytesToHex"](buf.slice(index, index + asn1.lengthSize)),
      16
    )
    index += asn1.lengthSize
  }

  // High-order bit Integers have a leading 0x00 to signify that they are positive.
  // Bit Streams use the first byte to signify padding, which x.509 doesn't use.
  if (buf[index] === 0x00 && (asn1.type === 0x02 || asn1.type === 0x03)) {
    // However, 0x00 on its own is a valid number
    if (asn1.length > 1) {
      index += 1
      adjust = -1
    }
  }
  const adjustedLen = asn1.length + adjust

  if (VTYPES.indexOf(asn1.type) !== -1) {
    asn1.value = buf.slice(index, index + adjustedLen)
    return asn1
  }

  asn1.children = []

  while (iters < 15 && index < 2 + asn1.length + asn1.lengthSize) {
    iters += 1
    child = parse(
      buf.slice(index, index + adjustedLen),
      (depth || 0) + 1,
      `${ws}  `
    )
    index += 2 + child.lengthSize + child.length
    if (index > 2 + asn1.lengthSize + asn1.length) {
      console.error(JSON.stringify(asn1, toPrettyHex, 2))
      throw new Error(
        `Parse error: child value length (${
          child.length
        }) is greater than remaining parent length (${asn1.length - index} = ${
          asn1.length
        } - ${index})`
      )
    }
    asn1.children.push(child)
  }

  if (index !== 2 + asn1.lengthSize + asn1.length) {
    throw new Error(
      `${'premature end-of-file ( index: '}${index} length: ${
        2 + asn1.lengthSize + asn1.length
      })`
    )
  }

  if (iters >= 15) {
    throw new Error(ELOOP)
  }

  return asn1
}

function toPrettyHex(k, v) {
  if (k === 'value') {
    return `0x${encoding["bytesToHex"](v.data)}`
  }
  return v
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/converters/vapid.ts
/* eslint-disable prefer-destructuring */



const { hexToBase64, strToHex, fromUrlSafeBase64 } = encoding

function vapidToPEM(vapidKeys


) {
  return hexToBase64(
    ASN1(
      '30',
      Integer('01'),
      ASN1('04', strToHex(fromUrlSafeBase64(vapidKeys.privateKey))),
      ASN1('A0', ASN1('06', '2A  86 48 CE 3D 03 01 07')) // prime256v1
    )
  )
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/converters/time-util.ts
/**  add a number of seconds or string representing a timespan eg: "1d", "20h", 60' to iat in seconds */
function timespan(timespan, iat) {
    const timestamp = iat || Math.floor(Date.now() / 1000)

    if (typeof timespan === 'string') {
        const milliseconds = parseSeconds(timespan)
        if (typeof milliseconds === 'undefined') {
            return undefined
        }
        return Math.floor(timestamp + milliseconds / 1000)
    }
    if (typeof timespan === 'number') {
        return timestamp + timespan
    }
    return undefined
}

function now() {
    return Math.floor(Date.now() / 1000)
}

// vercel/ms converted to typescript and seconds
// Copyright (c) 2016 Zeit, Inc.
// MIT License

/**
 * Helpers.
 */

const PERIOD_S = 1
const PERIOD_MS = PERIOD_S / 1000
const PERIOD_M = PERIOD_S * 60
const PERIOD_H = PERIOD_M * 60
const PERIOD_D = PERIOD_H * 24
const PERIOD_W = PERIOD_D * 7
const PERIOD_Y = PERIOD_D * 365.25

/*
 * 
 Parse the given `str` and return seconds.
 *
 * @param str like '1h' or number in seconds
 * @return {number} seconds
 * @api private
 */

function parseSeconds(str) {
    if (typeof str === 'number' && isFinite(str)) {
        return str
    }
    str = String(str)
    if (str.length > 100) {
        return undefined
    }
    const match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
    )
    if (!match) {
        return undefined
    }
    const n = parseFloat(match[1])
    const type = (match[2] || 's').toLowerCase()
    switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * PERIOD_Y
        case 'weeks':
        case 'week':
        case 'w':
            return n * PERIOD_W
        case 'days':
        case 'day':
        case 'd':
            return n * PERIOD_D
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * PERIOD_H
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * PERIOD_M
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * PERIOD_S
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n * PERIOD_MS
        default:
            return undefined
    }
}

/**
 * format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String}
 * @api public
 */

function time_util_format(
    val,
    options
) {
    options = options || { long: false }
    if (typeof val === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val)
    }
    throw new Error(`val is not a valid number. val=${JSON.stringify(val)}`)
}

/**

/**
 * Short format for `s`.
 *
 * @param {Number} s
 * @return {String}
 * @api private
 */

function fmtShort(val) {
    const valAbs = Math.abs(val)
    if (valAbs >= PERIOD_D) {
        return `${Math.round(val / PERIOD_D)}d`
    }
    if (valAbs >= PERIOD_H) {
        return `${Math.round(val / PERIOD_H)}h`
    }
    if (valAbs >= PERIOD_M) {
        return `${Math.round(val / PERIOD_M)}m`
    }
    if (valAbs >= PERIOD_S) {
        return `${Math.round(val / PERIOD_S)}s`
    }
    return `${Math.round(val / PERIOD_MS)}ms`
}

/**
 * Long format for `s`.
 *
 * @param {Number} s
 * @return {String}
 * @api private
 */

function fmtLong(val) {
    const valAbs = Math.abs(val)
    if (valAbs >= PERIOD_D) {
        return plural(val, valAbs, PERIOD_D, 'day')
    }
    if (valAbs >= PERIOD_H) {
        return plural(val, valAbs, PERIOD_H, 'hour')
    }
    if (valAbs >= PERIOD_M) {
        return plural(val, valAbs, PERIOD_M, 'minute')
    }
    if (valAbs >= PERIOD_S) {
        return plural(val, valAbs, PERIOD_S, 'second')
    }
    return plural(val, valAbs, PERIOD_MS, 'millisecond')
}

/**
 * Pluralization helper.
 */

function plural(val, valAbs, n, name) {
    const isPlural = valAbs >= n * 1.5
    return `${Math.round(val / n)} ${name}${isPlural ? 's' : ''}`
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/converters/ssh.ts
/* eslint-disable no-bitwise */



//  7  s  s  h  -  r  s  a
const RSA = '00000007 73 73 68 2d 72 73 61'
  .replace(/\s+/g, '')
  .toLowerCase()

function ssh_parse(pem, jwk) {
  const parts = pem.split(/\s+/)
  const buf = encoding["b64Decode"](parts[1])
  const els = []
  let index = 0
  let len
  let i = 0
  const offset = buf.byteOffset || 0
  const dv = new DataView(buf.slice(offset, offset + buf.byteLength))
  let el

  if (RSA !== encoding["bytesToHex"](buf.slice(0, RSA.length / 2))) {
    throw new Error('does not lead with ssh header')
  }

  while (index < buf.byteLength) {
    i += 1
    if (i > 3) {
      throw new Error('15+ elements, probably not a public ssh key')
    }
    len = dv.getUint32(index, false)
    index += 4
    el = buf.slice(index, index + len)
    // remove BigUInt '00' prefix
    if (el[0] === 0x00) {
      el = el.slice(1)
    }
    els.push(el)
    index += len
  }

  jwk.n = encoding["bytesToUrlBase64"](els[2])
  jwk.e = encoding["bytesToUrlBase64"](els[1])

  return jwk
}

function pack(opts) {
  const { jwk } = opts
  const header = 'ssh-rsa'
  const comment = opts.comment || 'rsa@localhost'
  const e = _padHexInt(encoding["Encoding"](jwk.e))
  const n = _padHexInt(encoding["Encoding"](jwk.n))
  const hex = [
    _numToUint32Hex(header.length),
    encoding["strToHex"](header),
    _numToUint32Hex(e.length / 2),
    e,
    _numToUint32Hex(n.length / 2),
    n
  ].join('')
  return [header, encoding["hexToBase64"](hex), comment].join(' ')
}

function _numToUint32Hex(num) {
  let hex = num.toString(16)
  while (hex.length < 8) {
    hex = `0${hex}`
  }
  return hex
}

function _padHexInt(hex) {
  // BigInt is negative if the high order bit 0x80 is set,
  // so ASN1, SSH, and many other formats pad with '0x00'
  // to signifiy a positive number.
  const i = parseInt(hex.slice(0, 2), 16)
  if (0x80 & i) {
    return `00${hex}`
  }
  return hex
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/converters/x509.ts




function guess(buf, asn1) {
  const meta = { kty: 'RSA', format: 'pkcs1', public: true }

  if (
    asn1.children.every((el) => {
      return el.type === 0x02
    })
  ) {
    if (asn1.children.length === 2) {
      // rsa pkcs1 public
      return meta
    }
    if (asn1.children.length >= 9) {
      // the standard allows for "otherPrimeInfos", hence at least 9
      meta.public = false
      // rsa pkcs1 private
      return meta
    }
    throw new Error(
      'not an RSA PKCS#1 public or private key (wrong number of ints)'
    )
  } else {
    meta.format = 'pkcs8'
  }

  return meta
}

function parsePkcs1(
  buf,
  asn1,
  jwk
) {
  if (
    !asn1.children.every((el) => {
      return el.type === 0x02
    })
  ) {
    throw new Error('not an RSA PKCS#1 public or private key (not all ints)')
  }

  if (asn1.children.length === 2) {
    jwk.n = encoding["bytesToUrlBase64"](asn1.children[0].value)
    jwk.e = encoding["bytesToUrlBase64"](asn1.children[1].value)
    return jwk
  }
  if (asn1.children.length >= 9) {
    // the standard allows for "otherPrimeInfos", hence at least 9

    jwk.n = encoding["bytesToUrlBase64"](asn1.children[1].value)
    jwk.e = encoding["bytesToUrlBase64"](asn1.children[2].value)
    jwk.d = encoding["bytesToUrlBase64"](asn1.children[3].value)
    jwk.p = encoding["bytesToUrlBase64"](asn1.children[4].value)
    jwk.q = encoding["bytesToUrlBase64"](asn1.children[5].value)
    jwk.dp = encoding["bytesToUrlBase64"](asn1.children[6].value)
    jwk.dq = encoding["bytesToUrlBase64"](asn1.children[7].value)
    jwk.qi = encoding["bytesToUrlBase64"](asn1.children[8].value)
    return jwk
  }
  throw new Error(
    'not an RSA PKCS#1 public or private key (wrong number of ints)'
  )
}

function parsePkcs8(
  buf,
  asn1,
  jwk
) {
  if (
    asn1.children.length === 2 &&
    asn1.children[1].type === 0x03 &&
    asn1.children[1].value[0] === 0x30
  ) {
    asn1 = parse(asn1.children[1].value)
    jwk.n = encoding["bytesToUrlBase64"](asn1.children[0].value)
    jwk.e = encoding["bytesToUrlBase64"](asn1.children[1].value)
  } else if (
    asn1.children.length === 3 &&
    asn1.children[2].type === 0x04 &&
    asn1.children[2].children[0].type === 0x30 &&
    asn1.children[2].children[0].children[0].type === 0x02
  ) {
    // eslint-disable-next-line prefer-destructuring
    asn1 = asn1.children[2].children[0]
    jwk.n = encoding["bytesToUrlBase64"](asn1.children[1].value)
    jwk.e = encoding["bytesToUrlBase64"](asn1.children[2].value)
    jwk.d = encoding["bytesToUrlBase64"](asn1.children[3].value)
    jwk.p = encoding["bytesToUrlBase64"](asn1.children[4].value)
    jwk.q = encoding["bytesToUrlBase64"](asn1.children[5].value)
    jwk.dp = encoding["bytesToUrlBase64"](asn1.children[6].value)
    jwk.dq = encoding["bytesToUrlBase64"](asn1.children[7].value)
    jwk.qi = encoding["bytesToUrlBase64"](asn1.children[8].value)
  } else {
    throw new Error('not an RSA PKCS#8 public or private key (wrong format)')
  }
  return jwk
}

function packPkcs1(jwk) {
  const n = Integer(encoding["Encoding"](jwk.n))
  const e = Integer(encoding["Encoding"](jwk.e))

  if (!jwk.d) {
    return encoding["hexToBytes"](ASN1('30', n, e))
  }

  return encoding["hexToBytes"](
    ASN1(
      '30',
      Integer('00'),
      n,
      e,
      Integer(encoding["Encoding"](jwk.d)),
      Integer(encoding["Encoding"](jwk.p)),
      Integer(encoding["Encoding"](jwk.q)),
      Integer(encoding["Encoding"](jwk.dp)),
      Integer(encoding["Encoding"](jwk.dq)),
      Integer(encoding["Encoding"](jwk.qi))
    )
  )
}

function packPkcs8(jwk) {
  if (!jwk.d) {
    // Public RSA
    return encoding["hexToBytes"](
      ASN1(
        '30',
        ASN1('30', ASN1('06', '2a864886f70d010101'), ASN1('05')),
        BitString(
          ASN1(
            '30',
            Integer(encoding["Encoding"](jwk.n)),
            Integer(encoding["Encoding"](jwk.e))
          )
        )
      )
    )
  }

  // Private RSA
  return encoding["hexToBytes"](
    ASN1(
      '30',
      Integer('00'),
      ASN1('30', ASN1('06', '2a864886f70d010101'), ASN1('05')),
      ASN1(
        '04',
        ASN1(
          '30',
          Integer('00'),
          Integer(encoding["Encoding"](jwk.n)),
          Integer(encoding["Encoding"](jwk.e)),
          Integer(encoding["Encoding"](jwk.d)),
          Integer(encoding["Encoding"](jwk.p)),
          Integer(encoding["Encoding"](jwk.q)),
          Integer(encoding["Encoding"](jwk.dp)),
          Integer(encoding["Encoding"](jwk.dq)),
          Integer(encoding["Encoding"](jwk.qi))
        )
      )
    )
  )
}

const packSpki = packPkcs8

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/converters/clear-private-entries.ts
var clear_private_entries = __webpack_require__(53);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/converters/pem-to-jwk.ts







/** Convert a PEM string to JWK format */
function convertPEMtoJWK(
  pem,
  opts
) {
  let jwk = { use: null, kty: 'RSA', n: null, e: null }

  if (pem.indexOf('ssh-rsa ') === 0) {
    return ssh_parse(pem, jwk)
  }

  const block = converters_pem["b" /* parsePemToBytes */](pem)

  const asn1 = parse(block)
  const meta = guess(block, asn1)

  if (meta.format === 'pkcs1') {
    jwk = parsePkcs1(block, asn1, jwk)
  } else {
    jwk = parsePkcs8(block, asn1, jwk)
  }

  if (opts.public) {
    Object(clear_private_entries["a" /* clearPrivateEntries */])(jwk)
  }

  return jwk
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/converters/jwk-to-format.ts






/** Convert a JWK object to given format */
function convertJWK(
  jwk_,
  opts
) {
  const jwk = JSON.parse(JSON.stringify(jwk_))
  let { format } = opts
  let pub = opts.public || false

  if (pub || ['spki', 'pkix', 'ssh', 'rfc4716'].indexOf(format) !== -1) {
    Object(clear_private_entries["a" /* clearPrivateEntries */])(jwk)
  }

  if (jwk.kty !== 'RSA') {
    throw new Error("jwk.kty must be 'RSA' for RSA keys")
  }

  if (!jwk.p) {
    // TODO test for n and e
    pub = true
    if (!format || format === 'pkcs1') {
      format = 'pkcs1'
    } else if (['spki', 'pkix'].indexOf(format) !== -1) {
      format = 'spki'
    } else if (['ssh', 'rfc4716'].indexOf(format) !== -1) {
      format = 'ssh'
    } else {
      throw new Error(
        `options.format must be 'spki', 'pkcs1', or 'ssh' for public RSA keys, not (${typeof format}) ${format}`
      )
    }
  } else if (!format || format === 'pkcs1') {
    format = 'pkcs1'
  } else if (format !== 'pkcs8') {
    throw new Error(
      "options.format must be 'pkcs1' or 'pkcs8' for private RSA keys"
    )
  }

  if (format === 'pkcs1') {
    if (jwk.d) {
      return converters_pem["a" /* packBlock */]({
        type: 'RSA PRIVATE KEY',
        bytes: packPkcs1(jwk)
      })
    }
    return converters_pem["a" /* packBlock */]({
      type: 'RSA PUBLIC KEY',
      bytes: packPkcs1(jwk)
    })
  }
  if (format === 'pkcs8') {
    return converters_pem["a" /* packBlock */]({ type: 'PRIVATE KEY', bytes: packPkcs8(jwk) })
  }
  if (['spki', 'pkix'].indexOf(format) !== -1) {
    return converters_pem["a" /* packBlock */]({ type: 'PUBLIC KEY', bytes: packSpki(jwk) })
  }
  if (['ssh', 'rfc4716'].indexOf(format) !== -1) {
    return pack({ jwk, comment: opts.comment })
  }
  throw new Error(`Unknown format: ${format}`)
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/converters/index.ts
/* unused concated harmony import Encoding */
/* unused concated harmony import PEM */
/* concated harmony reexport TimeUtil */__webpack_require__.d(__webpack_exports__, "a", function() { return time_util_namespaceObject; });
/* unused concated harmony import Vapid */
/* concated harmony reexport convertPEMtoJWK */__webpack_require__.d(__webpack_exports__, "b", function() { return convertPEMtoJWK; });
/* unused concated harmony import convertJWK */















/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return generateUUID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getRequestHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return setRequestHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return appendRequestHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return cloneRequestWithNewUrl; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */

/**
 * @constant
 * To generate the UUID
 * @returns The UUID string
 */
const generateUUID = () => {
    let uuid = "";
    for (let j = 0; j < 32; j++) {
        if (j === 8 || j === 12 || j === 16 || j === 20) {
            uuid += "-";
        }
        uuid += Math.floor(Math.random() * 16).toString(16);
    }
    return uuid;
};
/**
 * @constant
 * To get the request header from the request
 * @param {RequestInfo} request - The request object or the url string
 * @param {FetchOptions|undefined} options - The request options object
 * @param {string} key - The header key string
 * @returns A header value for the given key from the request
 */
const getRequestHeader = (request, options, key) => {
    let value = null;
    if (typeof Request !== "undefined" && request instanceof Request) {
        value = request.headers.get(key);
    }
    else if (typeof options !== "undefined" && options.headers !== undefined) {
        if (typeof Headers !== "undefined" && options.headers instanceof Headers) {
            value = options.headers.get(key);
        }
        else if (options.headers instanceof Array) {
            const headers = options.headers;
            for (let i = 0, l = headers.length; i < l; i++) {
                if (headers[i][0] === key) {
                    value = headers[i][1];
                    break;
                }
            }
        }
        else if (options.headers[key] !== undefined) {
            value = options.headers[key];
        }
    }
    return value;
};
/**
 * @constant
 * To set the header value to the given request
 * @param {RequestInfo} request - The request object or the url string
 * @param {FetchOptions|undefined} options - The request options object
 * @param {string} key - The header key string
 * @param {string } value - The header value string
 * @returns Nothing
 */
const setRequestHeader = (request, options, key, value) => {
    if (typeof Request !== "undefined" && request instanceof Request) {
        request.headers.set(key, value);
    }
    else if (typeof options !== "undefined") {
        if (options.headers === undefined) {
            options.headers = new Headers({
                [key]: value,
            });
        }
        else {
            if (typeof Headers !== "undefined" && options.headers instanceof Headers) {
                options.headers.set(key, value);
            }
            else if (options.headers instanceof Array) {
                let i = 0;
                const l = options.headers.length;
                for (; i < l; i++) {
                    const header = options.headers[i];
                    if (header[0] === key) {
                        header[1] = value;
                        break;
                    }
                }
                if (i === l) {
                    options.headers.push([key, value]);
                }
            }
            else {
                Object.assign(options.headers, { [key]: value });
            }
        }
    }
};
/**
 * @constant
 * To append the header value to the given request
 * @param {RequestInfo} request - The request object or the url string
 * @param {FetchOptions|undefined} options - The request options object
 * @param {string} key - The header key string
 * @param {string } value - The header value string
 * @returns Nothing
 */
const appendRequestHeader = (request, options, key, value) => {
    if (typeof Request !== "undefined" && request instanceof Request) {
        request.headers.append(key, value);
    }
    else if (typeof options !== "undefined") {
        if (options.headers === undefined) {
            options.headers = new Headers({
                [key]: value,
            });
        }
        else {
            if (typeof Headers !== "undefined" && options.headers instanceof Headers) {
                options.headers.append(key, value);
            }
            else if (options.headers instanceof Array) {
                options.headers.push([key, value]);
            }
            else if (options.headers === undefined) {
                options.headers = { [key]: value };
            }
            else if (options.headers[key] === undefined) {
                options.headers[key] = value;
            }
            else {
                options.headers[key] += `, ${value}`;
            }
        }
    }
};
/**
 * @constant
 * To clone the request with the new url
 * @param {string} url - The new url string
 * @param {Request} request - The request object
 * @returns A promise that resolves to request object
 */
const cloneRequestWithNewUrl = (newUrl, request) => tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](undefined, void 0, void 0, function* () {
    const body = request.headers.get("Content-Type") ? yield request.blob() : yield Promise.resolve(undefined);
    const { method, headers, referrer, referrerPolicy, mode, credentials, cache, redirect, integrity, keepalive, signal } = request;
    return new Request(newUrl, { method, headers, body, referrer, referrerPolicy, mode, credentials, cache, redirect, integrity, keepalive, signal });
});
//# sourceMappingURL=MiddlewareUtil.js.map

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var shallow_namespaceObject = {};
__webpack_require__.r(shallow_namespaceObject);
__webpack_require__.d(shallow_namespaceObject, "merge", function() { return merge; });
__webpack_require__.d(shallow_namespaceObject, "assign", function() { return shallow_assign; });
__webpack_require__.d(shallow_namespaceObject, "copy", function() { return copy; });
__webpack_require__.d(shallow_namespaceObject, "clone", function() { return clone; });
__webpack_require__.d(shallow_namespaceObject, "cloneDoubleLayer", function() { return cloneDoubleLayer; });
__webpack_require__.d(shallow_namespaceObject, "cloneTripleLayer", function() { return cloneTripleLayer; });
__webpack_require__.d(shallow_namespaceObject, "cloneFilter", function() { return cloneFilter; });
__webpack_require__.d(shallow_namespaceObject, "mergeContext", function() { return mergeContext; });

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa/src/iopa/map.ts
var map = __webpack_require__(14);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa/src/util/shallow.ts





















function merge(target, defaults, replace) {
  if (!target) {
    throw new Error('target must not be empty')
  }

  if (!defaults) {
    defaults = {}
  }

  if (replace) {
    for (var key in defaults) {
      if (defaults.hasOwnProperty(key)) {
        target[key] = defaults[key]
      }
    }
  } else {
    for (var key in defaults) {
      if (defaults.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
        target[key] = defaults[key]
      }
    }
  }
}

function shallow_assign(target) {
  if (!target) {
    throw new Error('target must not be empty')
  }

  target = Object(target)
  for (let index = 1; index < arguments.length; index++) {
    const source = arguments[index]
    if (source != null) {
      for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key]
        }
      }
    }
  }
  return target
}

function copy(source, target) {
  if (!source) {
    source = {}
  }

  if (!target) {
    target = Object.create(Object.getPrototypeOf(source))
  }

  for (const key in source) {
    if (source.hasOwnProperty(key)) {
      target[key] = source[key]
    }
  }

  return target
}

function clone(source) {
  const clone = Object.create(Object.getPrototypeOf(source))

  for (const key in source) {
    if (source.hasOwnProperty(key)) {
      clone[key] = source[key]
    }
  }

  return clone
}

function cloneDoubleLayer(source) {
  const clone = Object.create(Object.getPrototypeOf(source))

  for (const key1 in source) {
    if (source.hasOwnProperty(key1)) {
      const item = source[key1]
      if (typeof item === 'object') {
        const targetItem = Object.create(Object.getPrototypeOf(item))

        for (const key2 in item) {
          if (item.hasOwnProperty(key2)) {
            targetItem[key2] = item[key2]
          }
        }
        clone[key1] = targetItem
      } else {
        clone[key1] = item
      }
    }
  }

  return clone
}

function cloneTripleLayer(source) {
  const clone = Object.create(Object.getPrototypeOf(source))

  for (const key1 in source) {
    if (source.hasOwnProperty(key1)) {
      const item = source[key1]
      if (typeof item === 'object') {
        const targetItem = Object.create(Object.getPrototypeOf(item))

        for (const key2 in item) {
          if (item.hasOwnProperty(key2)) {
            const item2 = item[key2]
            if (typeof item2 === 'object') {
              const targetItem2 = Object.create(Object.getPrototypeOf(item2))

              for (const key3 in item2) {
                if (item2.hasOwnProperty(key3)) {
                  targetItem2[key3] = item[key3]
                }
              }
              targetItem[key2] = targetItem2
            } else {
              targetItem[key2] = item2
            }
          }
        }
        clone[key1] = targetItem
      } else {
        clone[key1] = item
      }
    }
  }

  return clone
}

function cloneFilter(source, blacklist) {
  const clone = Object.create(Object.getPrototypeOf(source))

  for (const key in source) {
    if (source.hasOwnProperty(key) && blacklist.indexOf(key) == -1) {
      clone[key] = source[key]
    }
  }

  return clone
}

function mergeContext(target, defaults) {
  if (!target) {
    throw new Error('target must not be empty')
  }

  if (!defaults) {
    return
  } // nothing to do

  Object.keys(defaults).forEach((key) => {
    if (key !== 'iopa.Headers') {
      target[key] = defaults[key]
    } else {
      target[key] = new map["a" /* IopaHeaders */](target[key], defaults[key])
    }
  })
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa/src/util/prototype.ts
/*
 * Internet Open Protocol Abstraction (IOPA)
 * Copyright (c) 2016-2020 Internet Open Protocol Alliance
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Create alias access methods on context.response for context body elemeent for given stream/readable/writable prototype
 *
 * Note: the alias will be a collection of both functions (which simply shell out to target function) and valuetypes (which
 * have a getter and setter defined which each shell out to the target property)
 *
 * @method cloneKeyBehaviors
 *
 * @param targetObjectPrototype (__proto__)  the prototype object for the context.response object on which the alias properties are set
 * @param sourceObjectprototype (__proto__)  the prototpye object for the generic stream/writable on which to enumerate all properties
 * @param iopaContextKey (string) e.g., "iopa.Body"
 * @returns (void)
 * @private
 */
function cloneKeyBehaviors(
  targetObjectPrototype,
  sourceObjectprototype,
  iopaContextKey,
  response
) {
  Object.getOwnPropertyNames(sourceObjectprototype).forEach((_property) => {
    if (typeof sourceObjectprototype[_property] === 'function') {
      targetObjectPrototype[_property] = (...rest) => {
        let item
        if (response) {
          item = targetObjectPrototype[iopaContextKey]
        } else {
          item = targetObjectPrototype.response[iopaContextKey]
        }

        return item[_property](...rest)
      }
    } else {
      Object.defineProperty(targetObjectPrototype, _property, {
        get() {
          let item
          if (response) {
            item = this[iopaContextKey]
          } else {
            item = this.response[iopaContextKey]
          }

          return item[_property]
        },

        set(val) {
          let item
          if (response) {
            item = this[iopaContextKey]
          } else {
            item = this.response[iopaContextKey]
          }

          item[_property] = val
        }
      })
    }
  })
}

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa/src/util/cancellation.ts
var cancellation = __webpack_require__(65);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa/src/iopa/constants.ts
var constants = __webpack_require__(77);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa/src/util/events.ts
var events = __webpack_require__(66);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa/src/util/guid.ts
/*
 * Internet Open Protocol Abstraction (IOPA)
 * Copyright (c) 2016-2020 Internet Open Protocol Alliance
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Create a new guid */
function guid() {
  return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`
}

/** Helper function to create a new 4 character ID (random) */
function s4() {
  return Math.floor((1 + Math.random()) * 0x10000)
    .toString(16)
    .substring(1)
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa/src/util/freelist.ts
/**
 * Node 0.12.x - 4.0.x Freelist module
 *
 * Included without functional changes
 * just license notice added
 *
 * Simple function but has now been deprecated in Node.js but including here
 *
 * This license applies to this module only
 */

/**
 * Copyright Node.js contributors. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

// This is a free list to avoid creating so many of the same object.
class FreeList {
  

  

  

  

  constructor(name, max, factory) {
    this.name = name
    this._constructor = factory
    this.max = max
    this.list = []
  }

  alloc(...args) {
    return this.list.length ? this.list.shift() : this._constructor(...args)
  }

  free(obj) {
    if (this.list.length < this.max) {
      this.list.push(obj)
      return true
    }
    return false
  }
}

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa/src/iopa/context.ts
var iopa_context = __webpack_require__(63);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa/src/iopa/factory.ts































/** Represents IopaContext Factory of up to 100 items */
class factory_Factory

 {
  

  constructor(
    name = 'IopaContext',
    size = 100,
    factory = () => new iopa_context["a" /* ContextBase */]() 
  ) {
    this._factory = new FreeList(name, size, factory)
  }

  /** Creates a new IOPA Context */
   createContext(
    url,
    options


  ) {
    const optionsValid = _validOptions(options)

    const context


 = this._factory.alloc().init()
    context.dispose = this._dispose.bind(this, context)
    context.set('server.Id', `#${_nextSequence()}`)

    if (optionsValid.withResponse) {
      const response
 = this._factory.alloc().init()

      const request = (context ) 

      request.set('iopa.Body', Promise.resolve(''))
      request.set('iopa.Headers', new map["a" /* IopaHeaders */]())
      request.set('iopa.Labels', new Map())
      request.set('iopa.Method', 'GET')
      request.set('iopa.OriginalUrl', url || 'https://localhost/factory')
      request.set('iopa.Url', new URL(request.get('iopa.OriginalUrl')))
      request.set('iopa.Path', '/')
      request.set('iopa.Protocol', 'HTTPS/2.0')
      request.set('iopa.QueryString', '')
      request.set('iopa.RemoteAddress', '::1')
      request.set('iopa.Scheme', 'https:')
      request.set('server.Source', 'create')
      request.set('server.Timestamp', Date.now())

      request.response = response

      response.set('iopa.StatusCode', 200)
      response.set('iopa.Size', 0)
      response.set('iopa.StatusText', 'OK')
      response.set('iopa.Headers', new map["a" /* IopaHeaders */]())

      response.send = async (body, sendoptions) => {
        if (sendoptions) {
          if (sendoptions.headers) {
            response.set(
              'iopa.Headers',
              new map["a" /* IopaHeaders */](sendoptions.headers, response['iopa.Headers'])
            )
          }
          if (sendoptions.status) {
            response.set('iopa.StatusCode', sendoptions.status)
          }
          if (sendoptions.statusText) {
            response.set('iopa.StatusText', sendoptions.statusText)
          }
        }
        // eslint-disable-next-line dot-notation
        if (body && body['length']) {
          response.set(
            'iopa.Size',
            // eslint-disable-next-line dot-notation
            response.get('iopa.Size') + body['length']
          )
        }
        response.set('iopa.Body', body) // TODO APPEND
      }

      response.end = (async (body, sendoptions) => {
        void response.send(body, sendoptions)
        context.get('iopa.Events').emit('end', response)
      }) 

      delete optionsValid.withResponse
    }

    context.create = this.createChildContext.bind(this, context)

    mergeContext(context, optionsValid)

    return context 
  }

  /** Creates a new IOPA Context that is a child request/response of a parent Context */
   createChildContext(
    parentContext,
    url,
    options
  ) {
    options = _validOptions(options)

    const context = this.createContext()
    _mergeCapabilities(context , parentContext )

    context.set('iopa.Path', parentContext.get('iopa.Path') + url || '')
    context.set('iopa.Scheme', parentContext.get('iopa.Scheme'))
    context['iopa.Host'] = parentContext['iopa.Host']
    context['iopa.Port'] = parentContext['iopa.Port']

    mergeContext(context, options)

    return context
  }

  /** Release the memory used by a given IOPA Context */
   _dispose(context) {
    if (context === null || context.get('server.CancelTokenSource') === null) {
      return
    }

    if (context.response) {
      const { response } = context

      Object.keys(response).forEach((prop) => {
        response[prop] = null
      })

      this._factory.free(response )
    }

    Object.keys(context).forEach((prop) => {
      context[prop] = null
    })

    this._factory.free(context)
  }
}

/** Merges server.Capabilities of parent Context onto child Context */
function _mergeCapabilities(
  childContext,
  parentContext
) {
  childContext['server.ParentContext'] = parentContext
  merge(
    childContext['server.Capabilities'],
    cloneDoubleLayer(parentContext['server.Capabilities'])
  )

  if (childContext.response && parentContext.response) {
    merge(
      childContext.response['server.Capabilities'],
      cloneDoubleLayer(parentContext.response['server.Capabilities'])
    )
  }
}

/** Clean Options;  allows overide for future validation  */
function _validOptions(options) {
  if (typeof options === 'string' || options instanceof String) {
    const result = {}
    result['iopa.Method'] = options
    return result
  }
  return options || {}
}

const maxSequence = 2 ** 16
let _lastSequence = Math.floor(Math.random() * (maxSequence - 1))

function _nextSequence() {
  _lastSequence += 1
  if (_lastSequence === maxSequence) {
    _lastSequence = 1
  }

  return _lastSequence.toString()
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa/src/appBuilder/middleware.ts



















/** Assures that the middleware is represented as IOPA middleware promise format (promise) fn(context, next)  where next = (promise) function()  */
function Middleware(
  app,
  middleware,
  action = 'invoke'
) {
  let args

  if (typeof middleware === 'function') {
    switch (middleware.length) {
      //
      // fn() with this=app and fn.invoke(next) with this = context
      //
      case 0:
        middleware.call(app)
        return (context, next) => {
          return middleware.invoke.call(context, next)
        }
        break

      //
      // fn(next) or fn(app) and fn.invoke(context, next)
      //
      case 1:
        args = _getParamNames(middleware)
        if (arrayEqual(args, ['next'])) {
          return (context, next) => {
            return middleware.call(context, next)
          }
        }

        // eslint-disable-next-line no-case-declarations
        // eslint-disable-next-line
        const mw = new middleware(app)
        return mw.invoke.bind(mw)

      //
      // fn(req,res) or fn(context, next)
      //
      case 2:
        args = _getParamNames(middleware)
        if (arrayEqual(args, ['req', 'res'])) {
          throw new Error(
            "must require 'iopa-connect' to use Connect/Express style middleware"
          )
        } else {
          return middleware
        }

      //
      // fn(req,res,next)
      //
      case 3:
        throw new Error(
          "must require 'iopa-connect' to use Connect/Express style middleware"
        )

      //
      // fn(err,req,res,next)
      //
      case 4:
        throw new Error(
          "must require 'iopa-connect' to use Connect/Express style middleware"
        )

      default:
        throw new Error('unknown middleware')
    }
  } else {
    console.error('middleware must be a function')
    throw new Error('middleware must be called on a function')
  }
}

// PRIVATE HELPER FUNCTIONS
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm

/** Gets the parameter names of a javascript function */
function _getParamNames(func) {
  const fnStr = func.toString().replace(STRIP_COMMENTS, '')
  let result = fnStr
    .slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')'))
    .match(/([^\s,]+)/g)
  if (result === null) {
    result = []
  }
  return result
}

/** Check if two arrays have same elements */
function arrayEqual(array1, array2) {
  // if the other array is a falsy value, return
  if (!array2) {
    return false
  }

  // compare lengths - can save a lot of time
  if (array1.length !== array2.length) {
    return false
  }

  // eslint-disable-next-line no-plusplus
  for (let i = 0, l = array1.length; i < l; i++) {
    // Check if we have nested arrays
    if (array1[i] instanceof Array && array2[i] instanceof Array) {
      // recurse into the nested arrays
      if (!array1[i].compare(array2[i])) {
        return false
      }
    } else if (array1[i] !== array2[i]) {
      // Warning - two different object instances will never be equal: {x:20} != {x:20}
      return false
    }
  }
  return true
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa/src/appBuilder/appBuilder.ts




































const packageVersion = __webpack_require__(217).version





class appBuilder_AppPropertiesWithCapabilities extends map["b" /* default */]

 {
  capability(keyOrRef, value) {
    if (typeof keyOrRef === 'string') {
      return this.get('server.Capabilities').get(keyOrRef )
    }
    return this[(keyOrRef ).id]
  }

  setCapability(keyOrRef, value) {
    if (typeof keyOrRef === 'string') {
      this.get('server.Capabilities').set(keyOrRef , value)
      return
    }
    this.get('server.Capabilities')[(keyOrRef ).id] = value
  }
}

/** AppBuilder Class to Compile/Build all Middleware in the Pipeline into single IOPA AppFunc */
class appBuilder_AppBuilder  {
  

  




  






  constructor(
    options = {}
  ) {;appBuilder_AppBuilder.prototype.__init.call(this);appBuilder_AppBuilder.prototype.__init2.call(this);
    const defaults = new appBuilder_AppPropertiesWithCapabilities({
      'server.AppId': guid(),
      'app.DefaultApp': DefaultApp,
      'app.DefaultMiddleware': [DefaultMiddleware],
      'server.Testing': new map["b" /* default */](),
      'server.Related': [],
      'server.Capabilities': new map["b" /* default */]({
        'urn:io.iopa:app': { 'server.Version': packageVersion }
      })
    })

    if (typeof options === 'string') {
      options = { 'server.AppId': options }
    } else if ('app.DefaultMiddleware' in options) {
      delete options['app.DefaultMiddleware']
    }

    if (options) {
      Object.entries(options).forEach(([key, value]) => {
        if (key === 'server.Capabilities') {
          const capabilities = defaults.get('server.Capabilities')
          Object.entries(value).forEach(([key2, value2]) => {
            capabilities.set((key2 ) , value2)
          })
        } else {
          defaults.set((key ) , value)
        }
      })
    }

    this.properties = defaults

    this.middleware = { invoke: [], dispatch: [] }
  }

  capability(key) {
    return this.properties.get('server.Capabilities').get(key)
  }

  setCapability(
    key,
    value
  ) {
    this.properties.get('server.Capabilities').set(key, value)
  }

   __init() {this.middlewareProxy = Middleware}

   __init2() {this.Factory = new factory_Factory()}

   createContext(url, options) {
    const context = (this.Factory.createContext(
      url,
      options
    ) ) 
    return context
  }

   fork(when) {
    const subApp = new appBuilder_AppBuilder(this.properties.toJSON())

    this.use(async function forkFunction(
      context,
      next
    ) {
      if (!subApp.properties.get('server.IsBuilt')) {
        subApp.build()
      }

      if (when(context)) {
        await subApp.invoke(context)
        return Promise.resolve(null)
        // do not call next on main pipeline after forked pipeline is invoked
      }

      return next()
    },
    'forkFuncton')

    return subApp
  }

  /** Add Middleware Function to AppBuilder pipeline */
  



   use(method, mw) {
    let id

    /** Fix comnmon es6 module interop issues */
    if (typeof method === 'object' && 'default' in method) {
      // eslint-disable-next-line dot-notation
      method = method['default']
    } else if (typeof mw === 'object' && 'default' in mw) {
      // eslint-disable-next-line dot-notation
      method = mw['default']
    }

    if (typeof method === 'function' && typeof mw === 'string') {
      /** resilience wrapper style */
      id = mw
      mw = method
      method = 'invoke'
    } else if (typeof method === 'function' && !mw) {
      mw = method
      method = 'invoke'
    } else if (method === undefined) {
      throw new Error(
        `app.use called with undefined / empty middleware for ${mw}`
      )
    }

    if (!this.middleware[method]) {
      throw new Error(
        `Unknown AppBuilder Category ${JSON.stringify(
          method,
          null,
          2
        )} for ${id}`
      )
    }

    const params = _getParams(mw)
    if (params === 'app' || mw.length === 1) {
      const Mw = mw
      let mwInstance
      try {
        mwInstance = new Mw(this)
      } catch (ex) {
        console.log(ex)
        // in case this is a js lambda function
        mwInstance = Mw(this) || {}
      }

      if (typeof mwInstance.invoke === 'function') {
        this.middleware.invoke.push(mwInstance.invoke.bind(mwInstance))
      }

      if (typeof mwInstance.dispatch === 'function') {
        this.middleware.dispatch.push(mwInstance.dispatch.bind(mwInstance))
      }
    } else {
      this.middleware[method].push(
        this.middlewareProxy((this ) , mw)
      )
    }

    return this
  }

   dispose() {
    /** noop */
  }

  /** Compile/Build all Middleware in the Pipeline into single IOPA AppFunc */
   build() {
    const middleware = this.properties
      .get('app.DefaultMiddleware')
      .concat(this.middleware.invoke)
      .concat(this.properties.get('app.DefaultApp'))

    const pipeline


 = this.compose_(middleware) 

    if (this.middleware.dispatch.length > 0) {
      pipeline.dispatch = this.compose_(this.middleware.dispatch.reverse())
    } else {
      pipeline.dispatch = (context) => {
        return Promise.resolve()
      }
    }

    pipeline.properties = this.properties
    this.properties.set('server.IsBuilt', true)
    this.properties.set('server.Pipeline', pipeline)
    return pipeline
  }

  /** Call Dispatch Pipeline  to process given context */
   dispatch(context) {
    return this.properties.get('server.Pipeline').dispatch.call(this, context)
  }

  /** Call App Invoke Pipeline to process given context */
   invoke(context) {
    if (!this.properties.get('server.IsBuilt')) {
      this.build()
    }
    return this.properties.get('server.Pipeline').call(this, context)
  }

  /** Compile/Build all Middleware in the Pipeline into single IOPA AppFunc  */
   compose_(middleware) {
    let i
    let next
    let curr
    i = middleware.length
    next = (context) => {
      return Promise.resolve(context)
    }

    // eslint-disable-next-line no-plusplus
    while (i--) {
      curr = middleware[i]
      if (!curr) {
        console.error(middleware, i)
        throw new Error('Missing middleware')
      }
      next = ((fn, prev, context) => {
        const _next = prev.bind(this, context)
        _next.invoke = prev
        return fn.call(this, context, _next)
      }).bind(this, curr, next)
    }

    return (context) => {
      const capabilities = this.properties.get('server.Capabilities')

      context.capability =
        context.capability ||
        ((keyOrRef) => {
          if (typeof keyOrRef === 'string') {
            return this.properties.get('server.Capabilities').get(keyOrRef)
          }
          return this.properties.get('server.Capabilities')[keyOrRef.id]
        })

      context.get =
        context.get ||
        ((key) => {
          return context[key ]
        })

      context.set =
        context.set ||
        ((data, value) => {
          if (typeof data === 'string') {
            context[data ] = value
            return
          }
          if (Array.isArray(data)) {
            for (const entry of data) {
              context.set(entry[0], entry[1])
            }
          } else if ('entries' in data) {
            for (const entry of (data.entries )()) {
              context.set(entry[0], entry[1])
            }
          } else {
            for (const entry of Object.entries(data) ) {
              context.set(entry[0], entry[1])
            }
          }
        })

      context.set(
        'server.Capabilities',
        new map["b" /* default */](cloneDoubleLayer(capabilities)) 
      )

      if (context.response) {
        context.response.get =
          context.response.get ||
          ((key) => {
            return context.response[key]
          })

        context.response.set =
          context.response.set ||
          ((data, value) => {
            if (typeof data === 'string') {
              context.response[data ] = value
              return
            }
            if (Array.isArray(data)) {
              for (const entry of data) {
                context.response.set(entry[0], entry[1])
              }
            } else if ('entries' in data) {
              for (const entry of (data.entries )()) {
                context.response.set(entry[0], entry[1])
              }
            } else {
              for (const entry of Object.entries(data) ) {
                context.response.set(entry[0], entry[1])
              }
            }
          })

        context.response.set(
          'server.Capabilities',
          context.get('server.Capabilities')
        )
      }

      return next.call(this, context)
    }
  }
}

/** Default middleware handler used at start of pipeline  */
function DefaultMiddleware(
  context,
  next
) {
  const value = next()

  if (typeof value === 'undefined') {
    console.error(
      'Server Error: One of the middleware functions on this server returned no value'
    )
    return Promise.resolve()
  }
  return value
}

/** Default app used at end of pipeline if not handled by any other middleware */
function DefaultApp(
  context,
  next
) {
  return Promise.resolve()
}

const appBuilder_STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm

/** Gets the parameter names of a javascript function as a comma separated string */
function _getParams(func) {
  const fnStr = func.toString().replace(appBuilder_STRIP_COMMENTS, '')
  let result = fnStr
    .slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')'))
    .match(/([^\s,]+)/g)
  if (result === null) {
    result = []
  }
  return result.join()
}

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/index.ts
var src = __webpack_require__(86);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa/src/index.ts
/* unused harmony export iopaPrototype */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return util; });
/* concated harmony reexport App */__webpack_require__.d(__webpack_exports__, "a", function() { return appBuilder_AppBuilder; });
/* unused concated harmony import IopaMap */
/* concated harmony reexport IopaHeaders */__webpack_require__.d(__webpack_exports__, "d", function() { return map["a" /* IopaHeaders */]; });
/* concated harmony reexport ContextBase */__webpack_require__.d(__webpack_exports__, "b", function() { return iopa_context["a" /* ContextBase */]; });
/* concated harmony reexport ResponseBase */__webpack_require__.d(__webpack_exports__, "e", function() { return iopa_context["b" /* ResponseBase */]; });
/* concated harmony reexport Factory */__webpack_require__.d(__webpack_exports__, "c", function() { return factory_Factory; });
/* concated harmony reexport constants */__webpack_require__.d(__webpack_exports__, "f", function() { return constants; });
/* unused concated harmony import Context */
/* unused concated harmony import FC */
/*
 * Internet Open Protocol Abstraction (IOPA)
 * Copyright (c) 2016 Internet Open Protocol Alliance
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */















const iopaPrototype = {
  cloneKeyBehaviors: cloneKeyBehaviors
}

const util = {
  shallow: shallow_namespaceObject,
  prototype: iopaPrototype,
  Disposable: events["a" /* Disposable */],
  EventEmitter: events["b" /* EventEmitter */],
  CancellationToken: cancellation["a" /* Token */],
  CancellationTokenSource: cancellation["b" /* TokenSource */]
}


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeatureUsageFlag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return TelemetryHandlerOptions; });
/* harmony import */ var _MiddlewareControl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */

/**
 * @enum
 * @property {number} NONE - The hexadecimal flag value for nothing enabled
 * @property {number} REDIRECT_HANDLER_ENABLED - The hexadecimal flag value for redirect handler enabled
 * @property {number} RETRY_HANDLER_ENABLED - The hexadecimal flag value for retry handler enabled
 * @property {number} AUTHENTICATION_HANDLER_ENABLED - The hexadecimal flag value for the authentication handler enabled
 */
var FeatureUsageFlag;
(function (FeatureUsageFlag) {
    FeatureUsageFlag[FeatureUsageFlag["NONE"] = 0] = "NONE";
    FeatureUsageFlag[FeatureUsageFlag["REDIRECT_HANDLER_ENABLED"] = 1] = "REDIRECT_HANDLER_ENABLED";
    FeatureUsageFlag[FeatureUsageFlag["RETRY_HANDLER_ENABLED"] = 2] = "RETRY_HANDLER_ENABLED";
    FeatureUsageFlag[FeatureUsageFlag["AUTHENTICATION_HANDLER_ENABLED"] = 4] = "AUTHENTICATION_HANDLER_ENABLED";
})(FeatureUsageFlag || (FeatureUsageFlag = {}));
/**
 * @class
 * @implements MiddlewareOptions
 * Class for TelemetryHandlerOptions
 */
class TelemetryHandlerOptions {
    constructor() {
        /**
         * @private
         * A member to hold the OR of feature usage flags
         */
        this.featureUsage = FeatureUsageFlag.NONE;
    }
    /**
     * @public
     * @static
     * To update the feature usage in the context object
     * @param {Context} context - The request context object containing middleware options
     * @param {FeatureUsageFlag} flag - The flag value
     * @returns nothing
     */
    static updateFeatureUsageFlag(context, flag) {
        let options;
        if (context.middlewareControl instanceof _MiddlewareControl__WEBPACK_IMPORTED_MODULE_0__[/* MiddlewareControl */ "a"]) {
            options = context.middlewareControl.getMiddlewareOptions(TelemetryHandlerOptions);
        }
        else {
            context.middlewareControl = new _MiddlewareControl__WEBPACK_IMPORTED_MODULE_0__[/* MiddlewareControl */ "a"]();
        }
        if (typeof options === "undefined") {
            options = new TelemetryHandlerOptions();
            context.middlewareControl.setMiddlewareOptions(TelemetryHandlerOptions, options);
        }
        options.setFeatureUsage(flag);
    }
    /**
     * @private
     * To set the feature usage flag
     * @param {FeatureUsageFlag} flag - The flag value
     * @returns nothing
     */
    setFeatureUsage(flag) {
        /* tslint:disable: no-bitwise */
        this.featureUsage = this.featureUsage | flag;
        /* tslint:enable: no-bitwise */
    }
    /**
     * @public
     * To get the feature usage
     * @returns A feature usage flag as hexadecimal string
     */
    getFeatureUsage() {
        return this.featureUsage.toString(16);
    }
}
//# sourceMappingURL=TelemetryHandlerOptions.js.map

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/constants/jwa.ts


// correspondence between JWA name ("alg" in JOSE header and JWK) and Web Crypto Signing algorithm
const JWA_SIGNING = {
  /** [HMAC](https://tools.ietf.org/html/rfc7518#section-3.2) using SHA-256 hash algorithm (default) */
  HS256: { name: 'HMAC', hash: 'SHA-256' },
  /** [HMAC](https://tools.ietf.org/html/rfc7518#section-3.2) using SHA-384 hash algorithm */
  HS384: { name: 'HMAC', hash: 'SHA-384' },
  /** [HMAC](https://tools.ietf.org/html/rfc7518#section-3.2) using SHA-512 hash algorithm */
  HS512: { name: 'HMAC', hash: 'SHA-512' },
  /** [RSASSA](https://tools.ietf.org/html/rfc7518#section-3.3) for signature and [RSAOAEP](https://tools.ietf.org/html/rfc2437#section-7.1) for encryptyion using SHA-256 hash algorithm */
  RS256: { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' },
  /**  [RSASSA](https://tools.ietf.org/html/rfc7518#section-3.3) for signature and [RSAOAEP](https://tools.ietf.org/html/rfc2437#section-7.1) for encryptyion using SHA-384 hash algorithm */
  RS384: { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-384' },
  /**   [RSASSA](https://tools.ietf.org/html/rfc7518#section-3.3) for signature and [RSAOAEP](https://tools.ietf.org/html/rfc2437#section-7.1) for encryptyion using SHA-512 hash algorithm */
  RS512: { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-512' },
  /** [ECDSA](https://tools.ietf.org/html/rfc7518#section-3.4) using P-256 curve and SHA-256 hash algorithm */
  ES256: {
    name: 'ECDSA',
    namedCurve: 'P-256',
    hash: 'SHA-256'
  },
  /** [ECDSA](https://tools.ietf.org/html/rfc7518#section-3.4) using P-384 curve and SHA-384 hash algorithm */
  ES384: {
    name: 'ECDSA',
    namedCurve: 'P-384',
    hash: 'SHA-384'
  },
  /** [ECDSA](https://tools.ietf.org/html/rfc7518#section-3.4) using P-521 curve and SHA-512 hash algorithm */
  ES512: {
    name: 'ECDSA',
    namedCurve: 'P-521',
    hash: 'SHA-512'
  },
  /**  [RSASSA-PSS](https://tools.ietf.org/html/rfc7518#section-3.5) using SHA-256 and MGF1 with SHA-256   */
  PS256: {
    name: 'RSA-PSS',
    saltLength: 256, // or 128?
    hash: 'SHA-256'
  },
  /**  [RSASSA-PSS](https://tools.ietf.org/html/rfc7518#section-3.5) using SHA-384 and MGF1 with SHA-384  */
  PS384: {
    name: 'RSA-PSS',
    saltLength: 384,
    hash: 'SHA-384'
  },
  /**  [RSASSA-PSS](https://tools.ietf.org/html/rfc7518#section-3.5) using SHA-512 and MGF1 with SHA-512  */
  PS512: {
    name: 'RSA-PSS',
    saltLength: 512,
    hash: 'SHA-512'
  }
}

// correspondence between JWA name ("alg" in  JWK) and Web Crypto Encryption algorithm
const JWA_ENCRYPTION = {
  /** [HMAC](https://tools.ietf.org/html/rfc7518#section-3.2) using SHA-256 hash algorithm (default) */
  HS256: { name: 'HMAC', hash: 'SHA-256' },
  /** [HMAC](https://tools.ietf.org/html/rfc7518#section-3.2) using SHA-384 hash algorithm */
  HS384: { name: 'HMAC', hash: 'SHA-384' },
  /** [HMAC](https://tools.ietf.org/html/rfc7518#section-3.2) using SHA-512 hash algorithm */
  HS512: { name: 'HMAC', hash: 'SHA-512' },
  /** [RSASSA](https://tools.ietf.org/html/rfc7518#section-3.3) for signature and [RSAOAEP](https://tools.ietf.org/html/rfc2437#section-7.1) for encryptyion using SHA-256 hash algorithm */
  RS256: { name: 'RSA-OAEP', hash: 'SHA-256' },
  /**  [RSASSA](https://tools.ietf.org/html/rfc7518#section-3.3) for signature and [RSAOAEP](https://tools.ietf.org/html/rfc2437#section-7.1) for encryptyion using SHA-384 hash algorithm */
  RS384: { name: 'RSA-OAEP', hash: 'SHA-384' },
  /**   [RSASSA](https://tools.ietf.org/html/rfc7518#section-3.3) for signature and [RSAOAEP](https://tools.ietf.org/html/rfc2437#section-7.1) for encryptyion using SHA-512 hash algorithm */
  RS512: { name: 'RSA-OAEP', hash: 'SHA-512' },
  /** [ECDSA](https://tools.ietf.org/html/rfc7518#section-3.4) using P-256 curve and SHA-256 hash algorithm */
  ES256: {
    name: 'ECDSA',
    namedCurve: 'P-256',
    hash: 'SHA-256'
  },
  /** [ECDSA](https://tools.ietf.org/html/rfc7518#section-3.4) using P-384 curve and SHA-384 hash algorithm */
  ES384: {
    name: 'ECDSA',
    namedCurve: 'P-384',
    hash: 'SHA-384'
  },
  /** [ECDSA](https://tools.ietf.org/html/rfc7518#section-3.4) using P-521 curve and SHA-512 hash algorithm */
  ES512: {
    name: 'ECDSA',
    namedCurve: 'P-521',
    hash: 'SHA-512'
  },
  /**  [RSASSA-PSS](https://tools.ietf.org/html/rfc7518#section-3.5) using SHA-256 and MGF1 with SHA-256   */
  PS256: {
    name: 'RSA-PSS',
    saltLength: 256, // or 128?
    hash: 'SHA-256'
  },
  /**  [RSASSA-PSS](https://tools.ietf.org/html/rfc7518#section-3.5) using SHA-384 and MGF1 with SHA-384  */
  PS384: {
    name: 'RSA-PSS',
    saltLength: 384,
    hash: 'SHA-384'
  },
  /**  [RSASSA-PSS](https://tools.ietf.org/html/rfc7518#section-3.5) using SHA-512 and MGF1 with SHA-512  */
  PS512: {
    name: 'RSA-PSS',
    saltLength: 512,
    hash: 'SHA-512'
  }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/constants/index.ts
/* concated harmony reexport JWA_SIGNING */__webpack_require__.d(__webpack_exports__, "b", function() { return JWA_SIGNING; });
/* concated harmony reexport JWA_ENCRYPTION */__webpack_require__.d(__webpack_exports__, "a", function() { return JWA_ENCRYPTION; });



/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;
var BN = __webpack_require__(30);
var minAssert = __webpack_require__(23);
var minUtils = __webpack_require__(176);

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return nativeFetchJWK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return nativeValidateJWK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return nativeValidateIopaEdgeKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return nativeImportJwk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return nativeGenerateJwkPair; });
/* unused harmony export nativeThumbprint */
/* unused harmony export importPemKey */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return nativeImportPem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return nativeVerifySignature; });
/* unused harmony export nativeSha256 */
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22);
/* harmony import */ var _converters_pem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var _converters_encoding__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);
/* harmony import */ var _converters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18);

















/** Attempts to find a JWK with the specified ID in a JWKs fetched from the specified URL */
async function nativeFetchJWK(
    /**
     * [Key ID](https://tools.ietf.org/html/rfc7515#section-4.1.4)
     *
     * The "kid" (key ID) Header Parameter is a hint indicating which key
     * was used to secure the JWS.
     */
    kid,

    /**
   * [JWK Set URL](https://tools.ietf.org/html/rfc7515#section-4.1.2)
   * 
   *  The "jku" (JWK Set URL) Header Parameter is a URI [RFC3986] that
   refers to a resource for a set of JSON-encoded public keys, one of
   which corresponds to the key used to digitally sign the JWS.
   */
    jku
) {
    const url = new URL(jku)
    if (url.protocol !== 'https:') {
        throw new URIError('Keys should be fetched only over HTTPS.')
    }
    const rawResult = await fetch(jku)
    let jsonResult = await rawResult.json()
    if (jsonResult.keys) { jsonResult = jsonResult.keys} 
    if (!Array.isArray(jsonResult)) {
        throw new TypeError('The specified JWKs is not an Array.')
    }
    const key = jsonResult.find((k) => k.kid === kid)
    if (!key) {
        throw new Error(
            `The JWKs at ${jku} did not contain the key with kid = ${kid}.`
        )
    }
    return nativeValidateJWK(key)
}

/** Checks that an object looks like a genuine JWK with the "sig" use and a supported algorithm */
function nativeValidateJWK(jwk) {
    if (!jwk.kid) {
        throw new Error('The key ID (kid) is missing from the JWK.')
    }
    if (!jwk.kty) {
        throw new Error('The key type (kty) is missing from the JWK.')
    }
    if (!jwk.alg) {
        throw new Error('The key algorithm (alg) is missing from the JWK.')
    }
    if (!/^(?:EC|RSA|oct)$/.test(jwk.kty)) {
        throw new Error(`Unsupported non-standard key type: ${jwk.kty}.`)
    }
    if (!(jwk.alg in _constants__WEBPACK_IMPORTED_MODULE_0__[/* JWA_SIGNING */ "b"])) {
        throw new Error(`Unsupported key algorithm: ${jwk.alg}.`)
    }
    if (!matchAlgKty(jwk.alg, jwk.kty)) {
        throw new Error(
            `The key type (${jwk.kty}) does not match its algorithm (${jwk.alg}).`
        )
    }
    if (!/\bsig\b/.test(jwk.use)) {
        throw new Error('The key does not allow signing/verification.')
    }
    return jwk 
}

/** Checks that a IopaEdgeKey has acceptable properties for verifying JWT signatures */
function nativeValidateIopaEdgeKey(key) {
    const cryptoKey = key._cryptoKey

    if (!cryptoKey.usages.includes('verify')) {
        throw new Error('Cannot use this key for signature verification.')
    }
    const keyAlg = cryptoKey.algorithm 
    const jwa = Object.values(_constants__WEBPACK_IMPORTED_MODULE_0__[/* JWA_SIGNING */ "b"]).find(
        (alg) => alg.name === keyAlg.name && alg.hash === keyAlg.name
    ) 
    if (!jwa) {
        throw new Error(
            "The key uses a combination of algorithm and hash that isn't listed in JWA_SIGNING."
        )
    }
    if (jwa.namedCurve && keyAlg.namedCurve !== jwa.namedCurve) {
        throw new Error(
            `The key's elliptic curve is not the one specified in JWA_SIGNING for ${jwa.hash}.`
        )
    }
    return key
}

/** Imports a verification JWK with the Web Crypto API, saving it in a key dictionary if provided */
async function nativeImportJwk(
    jwk,
    use,
    store
) {
    if (store && store.has(jwk.kid)) {
        return store.get(jwk.kid)
    }

    const cryptoKeyPromise = crypto.subtle.importKey(
        'jwk',
        jwk,
        _constants__WEBPACK_IMPORTED_MODULE_0__[/* JWA_SIGNING */ "b"][jwk.alg],
        false,
        jwk.d
            ? use === 'sig'
                ? ['verify', 'sign']
                : ['encrypt', 'decrypt']
            : use === 'sig'
            ? ['verify']
            : ['encrypt']
    )

    if (store) {
        store.set(jwk.kid, cryptoKeyPromise)
    }

    try {
        const cryptoKey = await cryptoKeyPromise
        if (store) {
            store.set(jwk.kid, cryptoKey)
        }
        return cryptoKeyPromise
    } catch (ex) {
        if (store) {
            store.delete(jwk.kid)
        }
    }
    return null
}

async function nativeGenerateJwkPair({
    alg,
    use,
}


) {
    const algorithm = _constants__WEBPACK_IMPORTED_MODULE_0__[/* JWA_SIGNING */ "b"][alg]

    const keyPair = (await crypto.subtle.generateKey(
        algorithm,
        true, // extractable (i.e. can be used in exportKey to get out the jwk equivalent)
        use === 'sig' ? ['sign', 'verify'] : ['encrypt', 'decrypt']
    )) 

    const jwk = (await crypto.subtle.exportKey(
        'jwk',
        keyPair.privateKey
    )) 

    jwk.kid = jwk.kid || (await nativeThumbprint(jwk))
    jwk.alg = jwk.alg || alg

    return [keyPair, jwk]
}

async function nativeThumbprint(jwk) {
    const { kty } = jwk
    let data

    // RSA JWK Thumbprint Fields
    if (kty === 'RSA') {
        const { e, n } = jwk 
        data = { e, kty, n }

        // ECDSA JWK Thumbprint Fields
    } else if (kty === 'EC') {
        const { crv, x, y } = jwk 
        data = { crv, kty, x, y }

        // Symmetric JWK Thumbprint Fields
    } else if (kty === 'oct') {
        const { k } = jwk 
        data = { k, kty }

        // Invalid kty
    } else {
        return Promise.reject(new _error__WEBPACK_IMPORTED_MODULE_2__[/* JOSENotSupportedError */ "a"]("Invalid 'kty'"))
    }

    const thumbprint = await nativeSha256(JSON.stringify(data))
    return thumbprint
}

async function importPemKey(
    pem,
    usage
) {
    try {
        const jwk = Object(_converters__WEBPACK_IMPORTED_MODULE_4__[/* convertPEMtoJWK */ "b"])(pem, {
            public: usage === 'encrypt' || usage === 'verify',
        })

        const importedKey = await crypto.subtle.importKey(
            'jwk',
            jwk,
            usage === 'sign' || usage === 'verify'
                ? { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' }
                : { name: 'RSA-OAEP', hash: 'SHA-1' },
            true,
            [usage]
        )
        return importedKey
    } catch (ex) {
        console.log(`IMPORT FAILURE ${usage}`, pem.substr(0, 64))
        throw ex
    }
}

async function nativeImportPem(
    pem,
    /**
     * [Algorithm](https://tools.ietf.org/html/rfc7517#section-4.4)
     *
     * The algorithm parameter identifies the algorithm intended for use with the key.
     */
    alg = 'RS256',
    /**
     * [Private Key Use](https://tools.ietf.org/html/rfc7517#section-4.2)
     *
     * The "use" (private key use) parameter identifies the intended use of
     * the private key.
     */
    use
) {
    const key = Object(_converters_pem__WEBPACK_IMPORTED_MODULE_1__[/* parsePemToBytes */ "b"])(pem)

    const jwk = Object(_converters__WEBPACK_IMPORTED_MODULE_4__[/* convertPEMtoJWK */ "b"])(pem, {
        public: false,
    })

    const importedPrivateKey = await crypto.subtle.importKey(
        'pkcs8',
        key,
        use === 'enc' ? _constants__WEBPACK_IMPORTED_MODULE_0__[/* JWA_ENCRYPTION */ "a"][alg] : _constants__WEBPACK_IMPORTED_MODULE_0__[/* JWA_SIGNING */ "b"][alg],
        true,
        use === 'enc' ? ['decrypt'] : ['sign']
    )

    jwk.kid = jwk.kid || (await nativeThumbprint(jwk))

    return [importedPrivateKey, jwk]
}

async function nativeVerifySignature(
    cryptoKey,
    {
        header,
        payload,
        signature,
    }




) {
    try {
    const result = await crypto.subtle.verify(
        _constants__WEBPACK_IMPORTED_MODULE_0__[/* JWA_SIGNING */ "b"][header.alg],
        cryptoKey,
        Object(_converters_encoding__WEBPACK_IMPORTED_MODULE_3__["stringToBytes"])(signature),
        Object(_converters_encoding__WEBPACK_IMPORTED_MODULE_3__["stringToBytes"])([header, payload].join('.'))
    )
    return result
    } catch (ex) {
        console.error(ex)
        throw ex
    }
}

/**
 * Check that the key is the right type for its algorithm
 */
function matchAlgKty(alg, kty) {
    switch (alg[0]) {
        case 'H':
            return kty === 'oct'
        case 'R':
        case 'P':
            return kty === 'RSA'
        case 'E':
            return kty === 'EC'
        default:
            throw new Error(`Unsupported algorithm ${alg}`)
    }
}

const nativeSha256 = async (str) => {
    // Browser docs indicate the first parameter to crypto.subtle.digest to be a
    // DOMString. This was initially implemented as an object and continues to be
    // supported, so we favor the older form for backwards compatibility.
    const hash = await crypto.subtle.digest(
        { name: 'SHA-256' },
        Object(_converters_encoding__WEBPACK_IMPORTED_MODULE_3__["stringToBytes"])(str)
    )

    return Object(_converters_encoding__WEBPACK_IMPORTED_MODULE_3__["bytesToUrlBase64"])(new Uint8Array(hash))
}


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return parsePemToBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return packBlock; });
/* unused harmony export formatPemString */
/* unused harmony export formatPemBytes */
/* harmony import */ var _encoding__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);


function parsePemToBytes(pem) {
  const b64Lines = pem
    .replace(/[\r\n]/g, '')
    .replace(/\s*-----END (.*)-----.*$/, '')
    .replace(/^.*-----BEGIN (.*)-----/, '')

  return _encoding__WEBPACK_IMPORTED_MODULE_0__["b64Decode"](b64Lines)
}

function packBlock(opts) {
  return `-----BEGIN ${opts.type}-----\n${_encoding__WEBPACK_IMPORTED_MODULE_0__["b64Encode"](opts.bytes)
    .match(/.{1,64}/g)
    .join('\n')}\n-----END ${opts.type}-----`
}

function formatPemString(
  b64,
  TYPE
) {
  return `-----BEGIN ${TYPE} KEY-----${b64}-----END ${TYPE} KEY-----`
}

function formatPemBytes(
  key,
  TYPE
) {
  const b64 = _encoding__WEBPACK_IMPORTED_MODULE_0__["b64Encode"](key)
  return formatPemString(b64, TYPE)
}


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(23);
var inherits = __webpack_require__(3);

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RedirectHandlerOptions; });
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @class
 * @implements MiddlewareOptions
 * A class representing RedirectHandlerOptions
 */
class RedirectHandlerOptions {
    /**
     * @public
     * @constructor
     * To create an instance of RedirectHandlerOptions
     * @param {number} [maxRedirects = RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS] - The max redirects value
     * @param {ShouldRedirect} [shouldRedirect = RedirectHandlerOptions.DEFAULT_SHOULD_RETRY] - The should redirect callback
     * @returns An instance of RedirectHandlerOptions
     */
    constructor(maxRedirects = RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS, shouldRedirect = RedirectHandlerOptions.DEFAULT_SHOULD_RETRY) {
        if (maxRedirects > RedirectHandlerOptions.MAX_MAX_REDIRECTS) {
            const error = new Error(`MaxRedirects should not be more than ${RedirectHandlerOptions.MAX_MAX_REDIRECTS}`);
            error.name = "MaxLimitExceeded";
            throw error;
        }
        if (maxRedirects < 0) {
            const error = new Error(`MaxRedirects should not be negative`);
            error.name = "MinExpectationNotMet";
            throw error;
        }
        this.maxRedirects = maxRedirects;
        this.shouldRedirect = shouldRedirect;
    }
}
/**
 * @private
 * @static
 * A member holding default max redirects value
 */
RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS = 5;
/**
 * @private
 * @static
 * A member holding maximum max redirects value
 */
RedirectHandlerOptions.MAX_MAX_REDIRECTS = 20;
/**
 * @private
 * A member holding default shouldRedirect callback
 */
RedirectHandlerOptions.DEFAULT_SHOULD_RETRY = () => true;
//# sourceMappingURL=RedirectHandlerOptions.js.map

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorReportingApi = void 0;
__exportStar(__webpack_require__(218), exports);
var generated_error_reporting_1 = __webpack_require__(222);
Object.defineProperty(exports, "ErrorReportingApi", { enumerable: true, get: function () { return generated_error_reporting_1.ProjectsApi; } });
//# sourceMappingURL=index.js.map

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(298).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)(module)))

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RetryHandlerOptions; });
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @class
 * @implements MiddlewareOptions
 * Class for RetryHandlerOptions
 */
class RetryHandlerOptions {
    /**
     * @public
     * @constructor
     * To create an instance of RetryHandlerOptions
     * @param {number} [delay = RetryHandlerOptions.DEFAULT_DELAY] - The delay value in seconds
     * @param {number} [maxRetries = RetryHandlerOptions.DEFAULT_MAX_RETRIES] - The maxRetries value
     * @param {ShouldRetry} [shouldRetry = RetryHandlerOptions.DEFAULT_SHOULD_RETRY] - The shouldRetry callback function
     * @returns An instance of RetryHandlerOptions
     */
    constructor(delay = RetryHandlerOptions.DEFAULT_DELAY, maxRetries = RetryHandlerOptions.DEFAULT_MAX_RETRIES, shouldRetry = RetryHandlerOptions.DEFAULT_SHOULD_RETRY) {
        if (delay > RetryHandlerOptions.MAX_DELAY && maxRetries > RetryHandlerOptions.MAX_MAX_RETRIES) {
            const error = new Error(`Delay and MaxRetries should not be more than ${RetryHandlerOptions.MAX_DELAY} and ${RetryHandlerOptions.MAX_MAX_RETRIES}`);
            error.name = "MaxLimitExceeded";
            throw error;
        }
        else if (delay > RetryHandlerOptions.MAX_DELAY) {
            const error = new Error(`Delay should not be more than ${RetryHandlerOptions.MAX_DELAY}`);
            error.name = "MaxLimitExceeded";
            throw error;
        }
        else if (maxRetries > RetryHandlerOptions.MAX_MAX_RETRIES) {
            const error = new Error(`MaxRetries should not be more than ${RetryHandlerOptions.MAX_MAX_RETRIES}`);
            error.name = "MaxLimitExceeded";
            throw error;
        }
        else if (delay < 0 && maxRetries < 0) {
            const error = new Error(`Delay and MaxRetries should not be negative`);
            error.name = "MinExpectationNotMet";
            throw error;
        }
        else if (delay < 0) {
            const error = new Error(`Delay should not be negative`);
            error.name = "MinExpectationNotMet";
            throw error;
        }
        else if (maxRetries < 0) {
            const error = new Error(`MaxRetries should not be negative`);
            error.name = "MinExpectationNotMet";
            throw error;
        }
        this.delay = Math.min(delay, RetryHandlerOptions.MAX_DELAY);
        this.maxRetries = Math.min(maxRetries, RetryHandlerOptions.MAX_MAX_RETRIES);
        this.shouldRetry = shouldRetry;
    }
    /**
     * @public
     * To get the maximum delay
     * @returns A maximum delay
     */
    getMaxDelay() {
        return RetryHandlerOptions.MAX_DELAY;
    }
}
/**
 * @private
 * @static
 * A member holding default delay value in seconds
 */
RetryHandlerOptions.DEFAULT_DELAY = 3;
/**
 * @private
 * @static
 * A member holding default maxRetries value
 */
RetryHandlerOptions.DEFAULT_MAX_RETRIES = 3;
/**
 * @private
 * @static
 * A member holding maximum delay value in seconds
 */
RetryHandlerOptions.MAX_DELAY = 180;
/**
 * @private
 * @static
 * A member holding maximum maxRetries value
 */
RetryHandlerOptions.MAX_MAX_RETRIES = 10;
/**
 * @private
 * A member holding default shouldRetry callback
 */
RetryHandlerOptions.DEFAULT_SHOULD_RETRY = () => true;
//# sourceMappingURL=RetryHandlerOptions.js.map

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _native_crypto_jwk_native_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _converters_clear_private_entries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53);
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);















const Jwk = class {
    //
    // JWK public implementation
    //

    static isIopaEdgeKey(object) {
        return !!object._cryptoKey
    }

    static asIopaEdgeKey(
        pemOrJwk,
        options = {
            alg: 'RS256',
            use: 'sig',
        }
    ) {
        if (typeof pemOrJwk === 'string') {
            return this.createKeyFromPEM(pemOrJwk, options)
        }
        return this.createKeyFromJWK(pemOrJwk)
    }

    









    static generate(parameters


) {
        return this.createKeyFromScratch(parameters)
    }

    /** Attempts to find a JWK with the specified ID in a JWKs fetched from the specified URL */
    static async fetch(
        /**
         * [Key ID](https://tools.ietf.org/html/rfc7515#section-4.1.4)
         *
         * The "kid" (key ID) Header Parameter is a hint indicating which key
         * was used to secure the JWS.
         */
        kid,

        /**
     * [JWK Set URL](https://tools.ietf.org/html/rfc7515#section-4.1.2)
     * 
     *  The "jku" (JWK Set URL) Header Parameter is a URI [RFC3986] that
     refers to a resource for a set of JSON-encoded public keys, one of
     which corresponds to the key used to digitally sign the JWS.
     */
        jku
    ) {
        return Object(_native_crypto_jwk_native_helpers__WEBPACK_IMPORTED_MODULE_0__[/* nativeFetchJWK */ "a"])(kid, jku)
    }

    /** Checks that a IopaEdgeKey has acceptable properties for verifying JWT signatures */
    static validateJsonWebKey(key) {
        return Object(_native_crypto_jwk_native_helpers__WEBPACK_IMPORTED_MODULE_0__[/* nativeValidateJWK */ "f"])(key)
    }

    /** Checks that a IopaEdgeKey has acceptable properties for verifying JWT signatures */
    static validateIopaEdgeKey(key) {
        return Object(_native_crypto_jwk_native_helpers__WEBPACK_IMPORTED_MODULE_0__[/* nativeValidateIopaEdgeKey */ "e"])(key)
    }

    //
    // Private methods
    //

     static async createKeyFromPEM(
        pem,
        { alg, use }
    ) {
        if (!alg.startsWith('RS')) {
            throw new _error__WEBPACK_IMPORTED_MODULE_2__[/* JOSENotSupportedError */ "a"](
                `Unsupported signing algorithm: ${alg}`
            )
        }
        if (['RS256'].indexOf(alg) === -1) {
            throw new _error__WEBPACK_IMPORTED_MODULE_2__[/* JOSENotSupportedError */ "a"](
                `Unsupported signing algorithm: ${alg}`
            )
        }
        const [cryptoKey, jwk] = await Object(_native_crypto_jwk_native_helpers__WEBPACK_IMPORTED_MODULE_0__[/* nativeImportPem */ "d"])(pem, alg, use)

        return new EdgeKey(cryptoKey, jwk)
    }

     static async createKeyFromJWK(
        jwk
    ) {
        const cryptoKey = await Object(_native_crypto_jwk_native_helpers__WEBPACK_IMPORTED_MODULE_0__[/* nativeImportJwk */ "c"])(jwk, 'sig')
        return new EdgeKey(cryptoKey, jwk)
    }

     static async createKeyFromScratch(options


) {
        const [cryptoKeyPair, jwk] = await Object(_native_crypto_jwk_native_helpers__WEBPACK_IMPORTED_MODULE_0__[/* nativeGenerateJwkPair */ "b"])(options)
        return new EdgeKey(cryptoKeyPair.privateKey, jwk)
    }
}

class EdgeKey  {
    

    

    

    

    

    

    

    constructor(cryptoKey, jwk) {
        this._cryptoKey = cryptoKey
        this._jwk = jwk
        this.isPrivate = cryptoKey.type === 'private'
        this.isPublic = cryptoKey.type === 'public'
        this.type = cryptoKey.type
        this.kid = jwk.kid
        this.createdAt = new Date().getTime() / 1000
    }

    toJsonWebKey(isPrivate) {
        if (isPrivate) {
            return this._jwk
        }
        return Object(_converters_clear_private_entries__WEBPACK_IMPORTED_MODULE_1__[/* clearPrivateEntries */ "a"])({ ...this._jwk })
    }
}

/* harmony default export */ __webpack_exports__["a"] = (Jwk);


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema/dist/index.js
var dist = __webpack_require__(5);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/index.ts + 3 modules
var src = __webpack_require__(0);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-cards/src/cardFactory.ts





/**
 * A set of utility functions designed to assist with the formatting of the various card types a
 * bot can return.
 *
 * @remarks
 * All of these functions return an `Attachment` which can be added to an `Activity` directly or
 * passed as input to a `MessageFactory` method.
 *
 * The following example shows sending a message containing a single hero card:
 *
 * ```javascript
 * const { MessageFactory, CardFactory } = require('iopa-botadapter');
 *
 * const card = CardFactory.heroCard(
 *      'White T-Shirt',
 *      ['https://example.com/whiteShirt.jpg'],
 *      ['buy']
 * );
 * const message = MessageFactory.attachment(card);
 * await context.sendActivity(message);
 * ```
 */
class cardFactory_CardFactory {
    /**
     * List of content types for each card style.
     */
     static __initStatic() {this.contentTypes = {
        adaptiveCard: 'application/vnd.microsoft.card.adaptive',
        animationCard: 'application/vnd.microsoft.card.animation',
        audioCard: 'application/vnd.microsoft.card.audio',
        heroCard: 'application/vnd.microsoft.card.hero',
        receiptCard: 'application/vnd.microsoft.card.receipt',
        oauthCard: 'application/vnd.microsoft.card.oauth',
        o365ConnectorCard: 'application/vnd.microsoft.teams.card.o365connector',
        signinCard: 'application/vnd.microsoft.card.signin',
        thumbnailCard: 'application/vnd.microsoft.card.thumbnail',
        videoCard: 'application/vnd.microsoft.card.video',
    }}

    /**
     * Returns an attachment for an adaptive card.
     *
     * @remarks
     * Adaptive Cards are a new way for bots to send interactive and immersive card content to
     * users. For channels that don't yet support Adaptive Cards natively, the Bot Framework will
     * down render the card to an image that's been styled to look good on the target channel. For
     * channels that support [hero cards](#herocards) you can continue to include Adaptive Card
     * actions and they will be sent as buttons along with the rendered version of the card.
     *
     * For more information about Adaptive Cards and to download the latest SDK, visit
     * [adaptivecards.io](http://adaptivecards.io/).
     *
     * ```JavaScript
     * const card = CardFactory.adaptiveCard({
     *   "$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
     *   "type": "AdaptiveCard",
     *   "version": "1.0",
     *   "body": [
     *       {
     *          "type": "TextBlock",
     *          "text": "Default text input"
     *       }
     *   ],
     *   "actions": [
     *       {
     *          "type": "Action.Submit",
     *          "title": "OK"
     *       }
     *   ]
     * });
     * ```
     * @param card The adaptive card to return as an attachment.
     */
     static adaptiveCard(card) {
        return {
            contentType: cardFactory_CardFactory.contentTypes.adaptiveCard,
            content: card,
        }
    }

    /**
     * Returns an attachment for a reactive card.
     *
     * @remarks
     * Reactive Cards are a new way for bots to send interactive and immersive card content to
     * users. For channels that don't yet support Adaptive Cards natively, the Bot Framework will
     * down render the card to an image that's been styled to look good on the target channel. For
     * channels that support [hero cards](#herocards) you can continue to include Reactive Card
     * actions and they will be sent as buttons along with the rendered version of the card.
     *
     * Reactive Cards are just Adaptive Cards written in easier to write and read JSX
     *
     * They allow (future use) automatic updating of activity content when paired with React.js
     *
     * For more information about Adaptive Cards and to download the latest SDK, visit
     * [adaptivecards.io](http://adaptivecards.io/).
     *
     * ```JavaScript
     * const card = CardFactory.reactiveCard(
     * <card><body><text>Default text input</text></body><action type="submit">OK</action></card>
     * );
     * ```
     * @param card The reactive card JSX element to return as an attachment.
     */
     static reactiveCard(card, resourceRoot) {
        return {
            contentType: cardFactory_CardFactory.contentTypes.adaptiveCard,
            content: Object(src["renderToObject"])(card, resourceRoot),
        }
    }

    /**
     * Returns an attachment for an animation card.
     * @param title The cards title.
     * @param media Media URL's for the card.
     * @param buttons (Optional) set of buttons to include on the card.
     * @param other (Optional) additional properties to include on the card.
     */
     static animationCard(
        title,
        media,
        buttons,
        other
    ) {
        return mediaCard(
            cardFactory_CardFactory.contentTypes.animationCard,
            title,
            media,
            buttons,
            other
        )
    }

    /**
     * Returns an attachment for an audio card.
     * @param title The cards title.
     * @param media Media URL's for the card.
     * @param buttons (Optional) set of buttons to include on the card.
     * @param other (Optional) additional properties to include on the card.
     */
     static audioCard(
        title,
        media,
        buttons,
        other
    ) {
        return mediaCard(
            cardFactory_CardFactory.contentTypes.audioCard,
            title,
            media,
            buttons,
            other
        )
    }

    /**
     * Returns an attachment for a hero card.
     *
     * @remarks
     * Hero cards tend to have one dominant full width image and the cards text & buttons can
     * usually be found below the image.
     *
     * ```javascript
     * const card = CardFactory.heroCard(
     *      'White T-Shirt',
     *      ['https://example.com/whiteShirt.jpg'],
     *      ['buy']
     * );
     * ```
     * @param title The cards title.
     * @param text (Optional) text field for the card.
     * @param images (Optional) set of images to include on the card.
     * @param buttons (Optional) set of buttons to include on the card.
     * @param other (Optional) additional properties to include on the card.
     */
    














     static heroCard(
        title,
        text,
        images,
        buttons,
        other
    ) {
        const a = cardFactory_CardFactory.thumbnailCard(
            title,
            text,
            images,
            buttons,
            other
        )
        a.contentType = cardFactory_CardFactory.contentTypes.heroCard

        return a
    }

    /**
     * Returns an attachment for an OAuth card used by the Bot Frameworks Single Sign On (SSO)
     * service.
     * @param connectionName The name of the OAuth connection to use.
     * @param title Title of the cards signin button.
     * @param text (Optional) additional text to include on the card.
     * @param link (Optional) the sign in link to follow
     */
     static oauthCard(
        connectionName,
        title,
        text,
        link
    ) {
        const card = {
            buttons: [
                {
                    type: dist["ActionTypes"].Signin,
                    title,
                    value: link,
                    channelData: undefined,
                },
            ],
            connectionName,
        }
        if (text) {
            card.text = text
        }

        return {
            contentType: cardFactory_CardFactory.contentTypes.oauthCard,
            content: card,
        }
    }

    /**
     * Returns an attachment for an 0365Connector card.
     *
     * @remarks
     * ```JavaScript
     * const card = CardFactory.o365ConnectorCard({
     *   "title": "card title",
     *   "text": "card text",
     *   "summary": "O365 card summary",
     *   "themeColor": "#E67A9E",
     *   "sections": [
     *       {
     *           "title": "**section title**",
     *           "text": "section text",
     *           "activityTitle": "activity title",
     *       }
     *   ]
     * });
     * ```
     * @param card The o365Connector card to return as an attachment.
     */
     static o365ConnectorCard(card) {
        return {
            contentType: cardFactory_CardFactory.contentTypes.o365ConnectorCard,
            content: card,
        }
    }

    /**
     * Returns an attachment for a receipt card.
     * @param card The adaptive card to return as an attachment.
     */
     static receiptCard(card) {
        return {
            contentType: cardFactory_CardFactory.contentTypes.receiptCard,
            content: card,
        }
    }

    /**
     * Returns an attachment for a signin card.
     *
     * @remarks
     * For channels that don't natively support signin cards an alternative message will be
     * rendered.
     * @param title Title of the cards signin button.
     * @param url The link to the signin page the user needs to visit.
     * @param text (Optional) additional text to include on the card.
     */
     static signinCard(
        title,
        url,
        text
    ) {
        const card = {
            buttons: [
                {
                    type: dist["ActionTypes"].Signin,
                    title,
                    value: url,
                    channelData: undefined,
                },
            ],
        }
        if (text) {
            card.text = text
        }

        return {
            contentType: cardFactory_CardFactory.contentTypes.signinCard,
            content: card,
        }
    }

    /**
     * Returns an attachment for a thumbnail card.
     *
     * @remarks
     * Thumbnail cards are similar to [hero cards](#herocard) but instead of a full width image,
     * they're typically rendered with a smaller thumbnail version of the image on either side
     * and the text will be rendered in column next to the image. Any buttons will typically
     * show up under the card.
     * @param title The cards title.
     * @param text (Optional) text field for the card.
     * @param images (Optional) set of images to include on the card.
     * @param buttons (Optional) set of buttons to include on the card.
     * @param other (Optional) additional properties to include on the card.
     */
    














     static thumbnailCard(
        title,
        text,
        images,
        buttons,
        other
    ) {
        if (typeof text !== 'string') {
            other = buttons
            buttons = images
            images = text
            text = undefined
        }
        const card = { ...other }
        if (title) {
            card.title = title
        }
        if (text) {
            card.text = text
        }
        if (images) {
            card.images = cardFactory_CardFactory.images(images)
        }
        if (buttons) {
            card.buttons = cardFactory_CardFactory.actions(buttons)
        }

        return {
            contentType: cardFactory_CardFactory.contentTypes.thumbnailCard,
            content: card,
        }
    }

    /**
     * Returns an attachment for a video card.
     * @param title The cards title.
     * @param media Media URLs for the card.
     * @param buttons (Optional) set of buttons to include on the card.
     * @param other (Optional) additional properties to include on the card.
     */
     static videoCard(
        title,
        media,
        buttons,
        other
    ) {
        return mediaCard(
            cardFactory_CardFactory.contentTypes.videoCard,
            title,
            media,
            buttons,
            other
        )
    }

    /**
     * Returns a properly formatted array of actions.
     *
     * @remarks
     * Supports converting strings to `messageBack` actions (note: using 'imBack' for now as
     * 'messageBack' doesn't work properly in emulator.)
     * @param actions Array of card actions or strings. Strings will be converted to `messageBack` actions.
     */
     static actions(
        actions
    ) {
        const list = []
        ;(actions || []).forEach((a) => {
            if (typeof a === 'object') {
                list.push(a)
            } else {
                list.push({
                    type: dist["ActionTypes"].ImBack,
                    value: a.toString(),
                    title: a.toString(),
                    channelData: undefined,
                })
            }
        })

        return list
    }

    /**
     * Returns a properly formatted array of card images.
     * @param images Array of card images or strings. Strings will be converted to card images.
     */
     static images(
        images
    ) {
        const list = []
        ;(images || []).forEach((img) => {
            if (typeof img === 'object') {
                list.push(img)
            } else {
                list.push({ url: img })
            }
        })

        return list
    }

    /**
     * Returns a properly formatted array of media url objects.
     * @param links Array of media url objects or strings. Strings will be converted to a media url object.
     */
     static media(links) {
        const list = []
        ;(links || []).forEach((lnk) => {
            if (typeof lnk === 'object') {
                list.push(lnk)
            } else {
                list.push({ url: lnk })
            }
        })

        return list
    }
} cardFactory_CardFactory.__initStatic();

/**
 * @private
 */
function mediaCard(
    contentType,
    title,
    media,
    buttons,
    other
) {
    const card = { ...other }
    if (title) {
        card.title = title
    }
    card.media = cardFactory_CardFactory.media(media)
    if (buttons) {
        card.buttons = cardFactory_CardFactory.actions(buttons)
    }

    return { contentType, content: card }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-cards/src/messageFactory.ts



/**
 * A set of utility functions to assist with the formatting of the various message types a bot can
 * return.
 *
 * @remarks
 * The following example shows sending a message containing a single hero card:
 *
 * ```javascript
 * const { MessageFactory, CardFactory } = require('botbuilder');
 *
 * const card = CardFactory.heroCard(
 *      'White T-Shirt',
 *      ['https://example.com/whiteShirt.jpg'],
 *      ['buy']
 * );
 * const message = MessageFactory.attachment(card);
 * await context.sendActivity(message);
 * ```
 */
class messageFactory_MessageFactory {
    /**
     * Returns a simple text message.
     *
     * @remarks
     * This example shows sending a simple text message:
     *
     * ```JavaScript
     * const message = MessageFactory.text('Greetings from example message');
     * ```
     * @param text Text to include in the message.
     * @param speak (Optional) SSML to include in the message.
     * @param inputHint (Optional) input hint for the message. Defaults to `acceptingInput`.
     */
     static text(
        text,
        speak,
        inputHint
    ) {
        const msg = {
            type: dist["ActivityTypes"].Message,
            text,
            inputHint: (inputHint ) || dist["InputHints"].AcceptingInput,
        }
        if (speak) {
            msg.speak = speak
        }

        return msg
    }

    /**
     * Returns a message that includes a set of suggested actions and optional text.
     *
     * @remarks
     * This example shows creating a message with suggested actions:
     *
     * ```JavaScript
     * const message = MessageFactory.suggestedActions(['red', 'green', 'blue'], `Choose a color`);
     * ```
     * @param actions Array of card actions or strings to include. Strings will be converted to `messageBack` actions.
     * @param text (Optional) text of the message.
     * @param speak (Optional) SSML to include with the message.
     * @param inputHint (Optional) input hint for the message. Defaults to `acceptingInput`.
     */
     static suggestedActions(
        actions,
        text,
        speak,
        inputHint
    ) {
        const msg = {
            type: dist["ActivityTypes"].Message,
            inputHint: (inputHint ) || dist["InputHints"].AcceptingInput,
            suggestedActions: {
                actions: cardFactory_CardFactory.actions(actions),
            } ,
        }
        if (text) {
            msg.text = text
        }
        if (speak) {
            msg.speak = speak
        }

        return msg
    }

    /**
     * Returns a single message activity containing an attachment.
     *
     * @remarks
     * This example shows creating a message with a hero card attachment:
     *
     * ```JavaScript
     * const message = MessageFactory.attachment(
     *     CardFactory.heroCard(
     *         'White T-Shirt',
     *         ['https://example.com/whiteShirt.jpg'],
     *         ['buy']
     *      )
     * );
     * ```
     * @param attachment Adaptive card to include in the message.
     * @param text (Optional) text of the message.
     * @param speak (Optional) SSML to include with the message.
     * @param inputHint (Optional) input hint for the message. Defaults to `acceptingInput`.
     */
     static attachment(
        attachment,
        text,
        speak,
        inputHint
    ) {
        return attachmentActivity(
            dist["AttachmentLayoutTypes"].List,
            [attachment],
            text,
            speak,
            inputHint
        )
    }

    /**
     * Returns a message that will display a set of attachments in list form.
     *
     * @remarks
     * This example shows creating a message with a list of hero cards:
     *
     * ```JavaScript
     * const message = MessageFactory.list([
     *    CardFactory.heroCard('title1', ['imageUrl1'], ['button1']),
     *    CardFactory.heroCard('title2', ['imageUrl2'], ['button2']),
     *    CardFactory.heroCard('title3', ['imageUrl3'], ['button3'])
     * ]);
     * ```
     * @param attachments Array of attachments to include in the message.
     * @param text (Optional) text of the message.
     * @param speak (Optional) SSML to include with the message.
     * @param inputHint (Optional) input hint for the message.
     */
     static list(
        attachments,
        text,
        speak,
        inputHint
    ) {
        return attachmentActivity(
            dist["AttachmentLayoutTypes"].List,
            attachments,
            text,
            speak,
            inputHint
        )
    }

    /**
     * Returns a message that will display a set of attachments using a carousel layout.
     *
     * @remarks
     * This example shows creating a message with a carousel of hero cards:
     *
     * ```JavaScript
     * const message = MessageFactory.carousel([
     *    CardFactory.heroCard('title1', ['imageUrl1'], ['button1']),
     *    CardFactory.heroCard('title2', ['imageUrl2'], ['button2']),
     *    CardFactory.heroCard('title3', ['imageUrl3'], ['button3'])
     * ]);
     * ```
     * @param attachments Array of attachments to include in the message.
     * @param text (Optional) text of the message.
     * @param speak (Optional) SSML to include with the message.
     * @param inputHint (Optional) input hint for the message.
     */
     static carousel(
        attachments,
        text,
        speak,
        inputHint
    ) {
        return attachmentActivity(
            dist["AttachmentLayoutTypes"].Carousel,
            attachments,
            text,
            speak,
            inputHint
        )
    }

    /**
     * Returns a message that will display a single image or video to a user.
     *
     * @remarks
     * This example shows sending an image to the user:
     *
     * ```JavaScript
     * const message = MessageFactory.contentUrl('https://example.com/hawaii.jpg', 'image/jpeg', 'Hawaii Trip', 'A photo from our family vacation.');
     * ```
     * @param url Url of the image/video to send.
     * @param contentType The MIME type of the image/video.
     * @param name (Optional) Name of the image/video file.
     * @param text (Optional) text of the message.
     * @param speak (Optional) SSML to include with the message.
     * @param inputHint (Optional) input hint for the message.
     */
     static contentUrl(
        url,
        contentType,
        name,
        text,
        speak,
        inputHint
    ) {
        const a = { contentType, contentUrl: url }
        if (name) {
            a.name = name
        }

        return attachmentActivity(
            dist["AttachmentLayoutTypes"].List,
            [a],
            text,
            speak,
            inputHint
        )
    }
}

/**
 * @private
 * @param attachmentLayout the direction in which attachments will be laid out
 * @param attachments an array of attachments
 * @param text the text to include
 * @param speak spoken text
 * @param inputHint input hint
 */
function attachmentActivity(
    attachmentLayout,
    attachments,
    text,
    speak,
    inputHint
) {
    const msg = {
        type: dist["ActivityTypes"].Message,
        attachmentLayout,
        attachments,
        inputHint: (inputHint ) || dist["InputHints"].AcceptingInput,
    }
    if (text) {
        msg.text = text
    }
    if (speak) {
        msg.speak = speak
    }

    return msg
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-cards/src/index.ts
/* concated harmony reexport CardFactory */__webpack_require__.d(__webpack_exports__, "a", function() { return cardFactory_CardFactory; });
/* concated harmony reexport MessageFactory */__webpack_require__.d(__webpack_exports__, "b", function() { return messageFactory_MessageFactory; });




/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(6).Buffer
var Transform = __webpack_require__(67).Transform
var StringDecoder = __webpack_require__(39).StringDecoder
var inherits = __webpack_require__(3)

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return oDataQueryNames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return urlJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return serializeContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isGraphURL; });
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @module GraphRequestUtil
 */

/**
 * To hold list of OData query params
 */
const oDataQueryNames = ["$select", "$expand", "$orderby", "$filter", "$top", "$skip", "$skipToken", "$count"];
/**
 * To construct the URL by appending the segments with "/"
 * @param {string[]} urlSegments - The array of strings
 * @returns The constructed URL string
 */
const urlJoin = (urlSegments) => {
    const removePostSlash = (s) => s.replace(/\/+$/, "");
    const removePreSlash = (s) => s.replace(/^\/+/, "");
    const joiner = (pre, cur) => [removePostSlash(pre), removePreSlash(cur)].join("/");
    const parts = Array.prototype.slice.call(urlSegments);
    return parts.reduce(joiner);
};
/**
 * Serializes the content
 * @param {any} content - The content value that needs to be serialized
 * @returns The serialized content
 *
 * Note:
 * This conversion is required due to the following reasons:
 * Body parameter of Request method of isomorphic-fetch only accepts Blob, ArrayBuffer, FormData, TypedArrays string.
 * Node.js platform does not support Blob, FormData. Javascript File object inherits from Blob so it is also not supported in node. Therefore content of type Blob, File, FormData will only come from browsers.
 * Parallel to ArrayBuffer in javascript, node provides Buffer interface. Node's Buffer is able to send the arbitrary binary data to the server successfully for both Browser and Node platform. Whereas sending binary data via ArrayBuffer or TypedArrays was only possible using Browser. To support both Node and Browser, `serializeContent` converts TypedArrays or ArrayBuffer to `Node Buffer`.
 * If the data received is in JSON format, `serializeContent` converts the JSON to string.
 */
const serializeContent = (content) => {
    const className = content && content.constructor && content.constructor.name;
    if (className === "Buffer" || className === "Blob" || className === "File" || className === "FormData" || typeof content === "string") {
        return content;
    }
    if (className === "ArrayBuffer") {
        content = Buffer.from(content);
    }
    else if (className === "Int8Array" || className === "Int16Array" || className === "Int32Array" || className === "Uint8Array" || className === "Uint16Array" || className === "Uint32Array" || className === "Uint8ClampedArray" || className === "Float32Array" || className === "Float64Array" || className === "DataView") {
        content = Buffer.from(content.buffer);
    }
    else {
        try {
            content = JSON.stringify(content);
        }
        catch (error) {
            throw new Error("Unable to stringify the content");
        }
    }
    return content;
};
/**
 * Checks if the url is one of the service root endpoints for Microsoft Graph and Graph Explorer.
 * @param {string} url - The url to be verified
 * @returns {boolean} - Returns true if the url is a Graph URL
 */
const isGraphURL = (url) => {
    // Valid Graph URL pattern - https://graph.microsoft.com/{version}/{resource}?{query-parameters}
    // Valid Graph URL example - https://graph.microsoft.com/v1.0/
    url = url.toLowerCase();
    if (url.indexOf("https://") !== -1) {
        url = url.replace("https://", "");
        // Find where the host ends
        const startofPortNoPos = url.indexOf(":");
        const endOfHostStrPos = url.indexOf("/");
        let hostName = "";
        if (endOfHostStrPos !== -1) {
            if (startofPortNoPos !== -1 && startofPortNoPos < endOfHostStrPos) {
                hostName = url.substring(0, startofPortNoPos);
                return _Constants__WEBPACK_IMPORTED_MODULE_0__[/* GRAPH_URLS */ "c"].has(hostName);
            }
            // Parse out the host
            hostName = url.substring(0, endOfHostStrPos);
            return _Constants__WEBPACK_IMPORTED_MODULE_0__[/* GRAPH_URLS */ "c"].has(hostName);
        }
    }
    return false;
};
//# sourceMappingURL=GraphRequestUtil.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };
    var errorListener;

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(68);
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(__webpack_require__(58));
util.inherits = __webpack_require__(3);
/*</replacement>*/

var Readable = __webpack_require__(138);
var Writable = __webpack_require__(89);

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(6).Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/constants/index.ts + 1 modules
var constants = __webpack_require__(22);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/converters/encoding.ts
var converters_encoding = __webpack_require__(1);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/native-crypto/jws-native-helpers.ts




async function nativeSignJWT({
  header,
  payload,
  signingKey,
  encoding
}




) {
  if (encoding !== 'utf8') {
    throw new Error(`encoding ${encoding} not supported`)
  }

  if (!(header.alg in constants["b" /* JWA_SIGNING */])) {
    throw new Error(`Unsupported signing algorithm: ${header.alg}`)
  }

  if (!signingKey) {
    throw new Error(`Missing signing key`)
  }

  if (!signingKey.isPrivate) {
    throw new Error(`Signing key must be private`)
  }

  const jws = {
    protected: Object(converters_encoding["stringToUrlBase64"])(JSON.stringify(header)),
    payload: Object(converters_encoding["stringToUrlBase64"])(JSON.stringify(payload))
  }

  // Convert UTF-8 to Uint8Array ArrayBuffer
  const data = Object(converters_encoding["stringToBytes"])(`${jws.protected}.${jws.payload}`)

  const signature = await crypto.subtle.sign(
    constants["b" /* JWA_SIGNING */][header.alg],
    signingKey._cryptoKey,
    data
  )
  jws.signature = Object(converters_encoding["bytesToUrlBase64"])(new Uint8Array(signature))

  // JWT is a "compressed", "protected" JWS
  return `${jws.protected}.${jws.payload}.${jws.signature}`
}

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/jwk.ts
var src_jwk = __webpack_require__(32);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/native-crypto/jwk-native-helpers.ts
var jwk_native_helpers = __webpack_require__(25);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/error.ts
var error = __webpack_require__(13);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/jws-parser.ts
/* eslint-disable no-restricted-syntax */




















/**
 * Configure a parser that can validate signed JSON Web Tokens (JWS only for now) and manage verification keys.
 * Unsigned (insecure) JWTs are disallowed by default.
 * The parser can automatically fetch additional keys from the tokens' JOSE header (also disabled by default).
 */
class jws_parser_JWTParser  {
  

  

  

    __init() {this.keyStore = new Map()}

  /** You won't get another chance to set the parser's options */
  constructor(options = {}) {;jws_parser_JWTParser.prototype.__init.call(this);
    for (const opt of [
      'allowInsecure',
      'allowTokenKey',
      'trustKeySetOrigins'
    ]) {
      Object.defineProperty(this, opt, {
        value: options[opt] || false,
        enumerable: true,
        writable: false,
        configurable: false // runtime readonly!
      })
    }
  }

  addKey(key) {
    const iopaEdgeKey = src_jwk["a" /* default */].validateIopaEdgeKey(key )
    this.keyStore.set(key.kid, key)
  }

  deleteKey(key) {
    this.keyStore.delete(key.kid)
  }

  /**
   * Validate a JSON Web Token [RFC 7519] and eventualy returns its Claims object (or rejects if something dosn't check out).
   * Checks the well-formedness and signature of the token, with some extra implementation-specific constraints.
   */
   decode(
    token,
    decodeOptions
  )





 {
    const options = {
      complete: false,
      json: false,
      ...(decodeOptions || {})
    }

    const result = this.decodeComplete(token, options)

    return options.complete ? result : result.payload
  }

  /**
   * Validate a JSON Web Token [RFC 7519] and eventualy returns its Claims object (or rejects if something dosn't check out).
   * Checks the well-formedness and signature of the token, with some extra implementation-specific constraints.
   */
   decodeComplete(
    token,
    decodeOptions
  )



 {
    // validate basic token structure

    if (typeof token !== 'string') {
      throw new TypeError('The token is not a string.')
    }
    const split = token.split('.')
    switch (split.length) {
      case 2:
        if (!this.allowInsecure) {
          throw new Error('The token is not signed')
        }
        break
      case 3:
        break
      default:
        throw new Error(
          "The token doesn't have an acceptable number of segments."
        )
    }
    const [headerRaw, payloadRaw, signatureRaw] = split

    // validate JOSE header
    let header

    try {
      header = JSON.parse(Object(converters_encoding["urlBase64ToString"])(headerRaw))
    } catch (err) {
      throw new Error('Could not decode JOSE header as base64url-encoded JSON.')
    }

    if (
      !header ||
      typeof header !== 'object' ||
      (header.typ && !/^jwt$/i.test(header.typ)) ||
      !header.alg
    ) {
      throw new Error('Malformed JOSE header.')
    }

    // validate Claims
    let payload

    try {
      payload = JSON.parse(Object(converters_encoding["urlBase64ToString"])(payloadRaw))
    } catch (err) {
      throw new Error(
        'Could not decode Claims payload as base64url-encoded JSON.'
      )
    }

    if (
      !payload ||
      typeof payload !== 'object' ||
      (payload.iss && typeof payload.iss !== 'string') ||
      (payload.sub && typeof payload.sub !== 'string') ||
      (payload.aud && typeof payload.aud !== 'string') ||
      (payload.exp && typeof payload.exp !== 'number') ||
      (payload.nbf && typeof payload.nbf !== 'number') ||
      (payload.iat && typeof payload.iat !== 'number') ||
      (payload.jti && typeof payload.jti !== 'string')
    ) {
      throw new Error('Malformed Claims payload.')
    }

    // validate signature

    const signLength = +(header.alg ).slice(-3)
    //	if (signLength === 256) signLength = 128;

    let signature

    try {
      signature = Object(converters_encoding["urlBase64ToString"])(signatureRaw)
    } catch (err) {
      throw new Error('Could not decode Signature as base64url.')
    }

    if (signature.length !== signLength) {
      throw new Error(
        `The signature for ${header.alg} should be ${signLength} bytes long, but it was ${signature.length} bytes in the token.`
      )
    }

    return { header, payload, signature }
  }

   async verify(
    token,
    verifyOptions
  ) {
    const options = {
      json: false,
      ...(verifyOptions || {})
    }

    const { header, payload, signature } = this.decodeComplete(token, {
      json: options.json
    })

    if (signature) {
      if (!(header.alg in constants["b" /* JWA_SIGNING */])) {
        throw new Error(`Unsupported signing algorithm: ${header.alg}`)
      }

      const iopaEdgeKey = await this._getKey(header, payload.iss)

      if (!iopaEdgeKey) {
        throw new error["b" /* JWSInvalidError */]('Could not verify signature')
      }
      this.keyStore.set(iopaEdgeKey.kid, iopaEdgeKey)

      // verify signature
      const result = await Object(jwk_native_helpers["g" /* nativeVerifySignature */])(
        iopaEdgeKey._cryptoKey,
        {
          header,
          payload,
          signature
        }
      )

      if (result) {
        return payload
      }

      console.log(iopaEdgeKey)

      throw new error["b" /* JWSInvalidError */]('Unable to verify')
    } else if (header.alg !== 'none') {
      throw new Error(
        'A signing algorithm is declared but there is no signature.'
      )
    }
    return payload
  }

  /**
   * Attempt to get the key specified by the header's "kid", "jku" or "jwk" fields, fetching if needed (and if allowed).
   */
   async _getKey(jose, iss) {
    let jwk
    if (this.keyStore.has(jose.kid)) {
      return this.keyStore.get(jose.kid)
    }
    if (jose.jwk) {
      if (!this.allowTokenKey) {
        throw new Error(
          "The token bears its own verification key, but we don't trust that."
        )
      }
      jwk = Object(jwk_native_helpers["f" /* nativeValidateJWK */])(jose.jwk)
      if (jose.kid && jose.kid !== jwk.kid) {
        throw new Error('The supplied JWK has a different key ID than the JWT.')
      }
    } else if (jose.kid && jose.jku) {
      if (
        this.trustKeySetOrigins &&
        !this.trustKeySetOrigins.test(new URL(jose.jku).host)
      ) {
        throw new Error(
          `The token points to a JWK set at ${jose.jku}, but we don't trust the network to get them.`
        )
      }
      jwk = await Object(jwk_native_helpers["a" /* nativeFetchJWK */])(jose.kid, jose.jku)
    } else if (iss) {
      if (
        this.trustKeySetOrigins &&
        !this.trustKeySetOrigins.test(new URL(iss).host)
      ) {
        throw new Error(
          `The token issuer is set at ${iss}, but we don't trust the network to get them.`
        )
      }
      jwk = await Object(jwk_native_helpers["a" /* nativeFetchJWK */])(jose.kid, iss)
    } else {
      throw new Error(
        "The token doesn't have a JWK and doesn't say where it can be found, so we can't verify it."
      )
    }

    if (jwk.alg !== jose.alg) {
      throw new Error(
        'The key has a different algorithm than specified by the header.'
      )
    }

    // eslint-disable-next-line no-return-await
    jwk.use = 'sig'
    return src_jwk["a" /* default */].asIopaEdgeKey(jwk)
  }
}

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/converters/index.ts + 7 modules
var converters = __webpack_require__(18);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/jws.ts














const OPTIONS_TO_PAYLOAD = {
  audience: 'aud',
  issuer: 'iss',
  subject: 'sub',
  jwtid: 'jti'
}

const Jws = class {
  //
  // Public JWS methods
  //

  /**
   * Create a custom signer configured with given keypair
   * @param options usage and algorotihm of the key to generate
   */
  static createSigner(key) {
    return new JwsSigner(key)
  }

  /**
   * Create a custom parser with its own keystore
   * @param options usage and algorotihm of the parser
   */
  static createParser(options) {
    return new jws_parser_JWTParser()
  }

  /**
   * Sign the given payload asynchronously into a JSON Web Token String
   * @param payload - Payload to sign
   * @param key - the private key to use for signing
   * @param [options] - Options for the signature
   * @returns A promise providing JSON Web Token string in compact format
   */
  static sign(
    signingKey,
    payload,
    options
  ) {
    const header = {
      alg: options.algorithm || 'HS256',
      typ: 'JWT',
      kid: options.keyid,
      ...options.header
    }

    if (typeof payload === 'undefined') {
      throw new error["c" /* JWTClaimInvalidError */]('payload is required')
    }

    if (
      !payload ||
      typeof payload !== 'object' ||
      (payload.iss && typeof payload.iss !== 'string') ||
      (payload.sub && typeof payload.sub !== 'string') ||
      (payload.aud && typeof payload.aud !== 'string') ||
      (payload.exp && typeof payload.exp !== 'number') ||
      (payload.nbf && typeof payload.nbf !== 'number') ||
      (payload.iat && typeof payload.iat !== 'number') ||
      (payload.jti && typeof payload.jti !== 'string')
    ) {
      throw new error["c" /* JWTClaimInvalidError */]('Malformed Claims payload.')
    }

    if (
      typeof payload.exp !== 'undefined' &&
      typeof options.expiresIn !== 'undefined'
    ) {
      throw new error["c" /* JWTClaimInvalidError */](
        'Bad "options.expiresIn" option the payload already has an "exp" property.'
      )
    }

    if (
      typeof payload.nbf !== 'undefined' &&
      typeof options.notBefore !== 'undefined'
    ) {
      throw new error["c" /* JWTClaimInvalidError */](
        'Bad "options.notBefore" option the payload already has an "nbf" property.'
      )
    }

    if (
      !options ||
      typeof options !== 'object' ||
      (options.expiresIn &&
        typeof options.expiresIn !== 'string' &&
        typeof options.expiresIn !== 'number') ||
      (options.notBefore &&
        typeof options.notBefore !== 'string' &&
        typeof options.notBefore !== 'number') ||
      (options.audience &&
        typeof options.audience !== 'string' &&
        !Array.isArray(options.audience)) ||
      (options.algorithm && typeof options.algorithm !== 'string') ||
      (options.header && typeof options.header !== 'object') ||
      (options.encoding && typeof options.encoding !== 'string') ||
      (options.issuer && typeof options.issuer !== 'string') ||
      (options.subject && typeof options.subject !== 'string') ||
      (options.issuer && typeof options.issuer !== 'string') ||
      (options.jwtid && typeof options.jwtid !== 'string') ||
      (options.noTimestamp && typeof options.noTimestamp !== 'boolean') ||
      (options.keyid && typeof options.keyid !== 'string') ||
      (payload.jti && typeof payload.jti !== 'string')
    ) {
      throw new error["c" /* JWTClaimInvalidError */]('Malformed Claims payload.')
    }

    const timestamp = payload.iat || converters["a" /* TimeUtil */].now()

    if (options.noTimestamp) {
      delete payload.iat
    } else {
      payload.iat = timestamp
    }

    if (typeof options.notBefore !== 'undefined') {
      payload.nbf = converters["a" /* TimeUtil */].timespan(options.notBefore, timestamp)

      if (typeof payload.nbf === 'undefined') {
        throw new error["d" /* JWTMalformed */](
          '"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'
        )
      }
    }

    if (
      typeof options.expiresIn !== 'undefined' &&
      typeof payload === 'object'
    ) {
      payload.exp = converters["a" /* TimeUtil */].timespan(options.expiresIn, timestamp)

      if (typeof payload.exp === 'undefined') {
        throw new error["d" /* JWTMalformed */](
          '"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'
        )
      }
    }

    Object.keys(OPTIONS_TO_PAYLOAD).forEach((key) => {
      const claim = OPTIONS_TO_PAYLOAD[key]
      if (typeof options[key] !== 'undefined') {
        if (typeof payload[claim] !== 'undefined') {
          throw new error["d" /* JWTMalformed */](
            `Bad "options.${key}" option. The payload already has an "${claim}" property.`
          )
        }
        payload[claim] = options[key]
      }
    })

    const encoding = options.encoding || 'utf8'

    return nativeSignJWT({
      header,
      payload,
      signingKey,
      encoding
    })
  }
}

/**
 * Configure a parser that can validate signed JSON Web Tokens (JWS only for now) and manage verification keys.
 * Unsigned (insecure) JWTs are disallowed by default.
 * The parser can automatically fetch additional keys from the tokens' JOSE header (also disabled by default).
 */
class JwsSigner  {
  

  constructor(signingKey) {
    this.signingKey = signingKey
  }

   sign(
    payload,
    options
  ) {
    return Jws.sign(this.signingKey, payload, options)
  }
}

/* harmony default export */ var src_jws = __webpack_exports__["a"] = (Jws);


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
__webpack_require__(220);
module.exports = self.fetch.bind(self);


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = __webpack_require__(6).Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16), __webpack_require__(10)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = __webpack_require__(144);

var Writable = __webpack_require__(148);

__webpack_require__(3)(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(6).Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = __webpack_require__(170);

var Writable = __webpack_require__(174);

__webpack_require__(3)(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AuthenticationHandler; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _MiddlewareControl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _MiddlewareUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19);
/* harmony import */ var _options_AuthenticationHandlerOptions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(79);
/* harmony import */ var _options_TelemetryHandlerOptions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(21);
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */





/**
 * @class
 * @implements Middleware
 * Class representing AuthenticationHandler
 */
class AuthenticationHandler {
    /**
     * @public
     * @constructor
     * Creates an instance of AuthenticationHandler
     * @param {AuthenticationProvider} authenticationProvider - The authentication provider for the authentication handler
     */
    constructor(authenticationProvider) {
        this.authenticationProvider = authenticationProvider;
    }
    /**
     * @public
     * @async
     * To execute the current middleware
     * @param {Context} context - The context object of the request
     * @returns A Promise that resolves to nothing
     */
    execute(context) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            try {
                let options;
                if (context.middlewareControl instanceof _MiddlewareControl__WEBPACK_IMPORTED_MODULE_1__[/* MiddlewareControl */ "a"]) {
                    options = context.middlewareControl.getMiddlewareOptions(_options_AuthenticationHandlerOptions__WEBPACK_IMPORTED_MODULE_3__[/* AuthenticationHandlerOptions */ "a"]);
                }
                let authenticationProvider;
                let authenticationProviderOptions;
                if (typeof options !== "undefined") {
                    authenticationProvider = options.authenticationProvider;
                    authenticationProviderOptions = options.authenticationProviderOptions;
                }
                if (typeof authenticationProvider === "undefined") {
                    authenticationProvider = this.authenticationProvider;
                }
                const token = yield authenticationProvider.getAccessToken(authenticationProviderOptions);
                const bearerKey = `Bearer ${token}`;
                Object(_MiddlewareUtil__WEBPACK_IMPORTED_MODULE_2__[/* appendRequestHeader */ "a"])(context.request, context.options, AuthenticationHandler.AUTHORIZATION_HEADER, bearerKey);
                _options_TelemetryHandlerOptions__WEBPACK_IMPORTED_MODULE_4__[/* TelemetryHandlerOptions */ "b"].updateFeatureUsageFlag(context, _options_TelemetryHandlerOptions__WEBPACK_IMPORTED_MODULE_4__[/* FeatureUsageFlag */ "a"].AUTHENTICATION_HANDLER_ENABLED);
                return yield this.nextMiddleware.execute(context);
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * To set the next middleware in the chain
     * @param {Middleware} next - The middleware instance
     * @returns Nothing
     */
    setNext(next) {
        this.nextMiddleware = next;
    }
}
/**
 * @private
 * A member representing the authorization header name
 */
AuthenticationHandler.AUTHORIZATION_HEADER = "Authorization";
//# sourceMappingURL=AuthenticationHandler.js.map

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HTTPMessageHandler; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */

/**
 * @class
 * @implements Middleware
 * Class for HTTPMessageHandler
 */
class HTTPMessageHandler {
    /**
     * @public
     * @async
     * To execute the current middleware
     * @param {Context} context - The request context object
     * @returns A promise that resolves to nothing
     */
    execute(context) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            try {
                context.response = yield fetch(context.request, context.options);
                return;
            }
            catch (error) {
                throw error;
            }
        });
    }
}
//# sourceMappingURL=HTTPMessageHandler.js.map

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RetryHandler; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _RequestMethod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);
/* harmony import */ var _MiddlewareControl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _MiddlewareUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);
/* harmony import */ var _options_RetryHandlerOptions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31);
/* harmony import */ var _options_TelemetryHandlerOptions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(21);
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */






/**
 * @class
 * @implements Middleware
 * Class for RetryHandler
 */
class RetryHandler {
    /**
     * @public
     * @constructor
     * To create an instance of RetryHandler
     * @param {RetryHandlerOptions} [options = new RetryHandlerOptions()] - The retry handler options value
     * @returns An instance of RetryHandler
     */
    constructor(options = new _options_RetryHandlerOptions__WEBPACK_IMPORTED_MODULE_4__[/* RetryHandlerOptions */ "a"]()) {
        this.options = options;
    }
    /**
     *
     * @private
     * To check whether the response has the retry status code
     * @param {Response} response - The response object
     * @returns Whether the response has retry status code or not
     */
    isRetry(response) {
        return RetryHandler.RETRY_STATUS_CODES.indexOf(response.status) !== -1;
    }
    /**
     * @private
     * To check whether the payload is buffered or not
     * @param {RequestInfo} request - The url string or the request object value
     * @param {FetchOptions} options - The options of a request
     * @returns Whether the payload is buffered or not
     */
    isBuffered(request, options) {
        const method = typeof request === "string" ? options.method : request.method;
        const isPutPatchOrPost = method === _RequestMethod__WEBPACK_IMPORTED_MODULE_1__[/* RequestMethod */ "a"].PUT || method === _RequestMethod__WEBPACK_IMPORTED_MODULE_1__[/* RequestMethod */ "a"].PATCH || method === _RequestMethod__WEBPACK_IMPORTED_MODULE_1__[/* RequestMethod */ "a"].POST;
        if (isPutPatchOrPost) {
            const isStream = Object(_MiddlewareUtil__WEBPACK_IMPORTED_MODULE_3__[/* getRequestHeader */ "d"])(request, options, "Content-Type") === "application/octet-stream";
            if (isStream) {
                return false;
            }
        }
        return true;
    }
    /**
     * @private
     * To get the delay for a retry
     * @param {Response} response - The response object
     * @param {number} retryAttempts - The current attempt count
     * @param {number} delay - The delay value in seconds
     * @returns A delay for a retry
     */
    getDelay(response, retryAttempts, delay) {
        const getRandomness = () => Number(Math.random().toFixed(3));
        const retryAfter = response.headers !== undefined ? response.headers.get(RetryHandler.RETRY_AFTER_HEADER) : null;
        let newDelay;
        if (retryAfter !== null) {
            // tslint:disable: prefer-conditional-expression
            if (Number.isNaN(Number(retryAfter))) {
                newDelay = Math.round((new Date(retryAfter).getTime() - Date.now()) / 1000);
            }
            else {
                newDelay = Number(retryAfter);
            }
            // tslint:enable: prefer-conditional-expression
        }
        else {
            // Adding randomness to avoid retrying at a same
            newDelay = retryAttempts >= 2 ? this.getExponentialBackOffTime(retryAttempts) + delay + getRandomness() : delay + getRandomness();
        }
        return Math.min(newDelay, this.options.getMaxDelay() + getRandomness());
    }
    /**
     * @private
     * To get an exponential back off value
     * @param {number} attempts - The current attempt count
     * @returns An exponential back off value
     */
    getExponentialBackOffTime(attempts) {
        return Math.round((1 / 2) * (Math.pow(2, attempts) - 1));
    }
    /**
     * @private
     * @async
     * To add delay for the execution
     * @param {number} delaySeconds - The delay value in seconds
     * @returns Nothing
     */
    sleep(delaySeconds) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            const delayMilliseconds = delaySeconds * 1000;
            return new Promise((resolve) => setTimeout(resolve, delayMilliseconds));
        });
    }
    getOptions(context) {
        let options;
        if (context.middlewareControl instanceof _MiddlewareControl__WEBPACK_IMPORTED_MODULE_2__[/* MiddlewareControl */ "a"]) {
            options = context.middlewareControl.getMiddlewareOptions(this.options.constructor);
        }
        if (typeof options === "undefined") {
            options = Object.assign(new _options_RetryHandlerOptions__WEBPACK_IMPORTED_MODULE_4__[/* RetryHandlerOptions */ "a"](), this.options);
        }
        return options;
    }
    /**
     * @private
     * @async
     * To execute the middleware with retries
     * @param {Context} context - The context object
     * @param {number} retryAttempts - The current attempt count
     * @param {RetryHandlerOptions} options - The retry middleware options instance
     * @returns A Promise that resolves to nothing
     */
    executeWithRetry(context, retryAttempts, options) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            try {
                yield this.nextMiddleware.execute(context);
                if (retryAttempts < options.maxRetries && this.isRetry(context.response) && this.isBuffered(context.request, context.options) && options.shouldRetry(options.delay, retryAttempts, context.request, context.options, context.response)) {
                    ++retryAttempts;
                    Object(_MiddlewareUtil__WEBPACK_IMPORTED_MODULE_3__[/* setRequestHeader */ "e"])(context.request, context.options, RetryHandler.RETRY_ATTEMPT_HEADER, retryAttempts.toString());
                    const delay = this.getDelay(context.response, retryAttempts, options.delay);
                    yield this.sleep(delay);
                    return yield this.executeWithRetry(context, retryAttempts, options);
                }
                else {
                    return;
                }
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * @async
     * To execute the current middleware
     * @param {Context} context - The context object of the request
     * @returns A Promise that resolves to nothing
     */
    execute(context) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            try {
                const retryAttempts = 0;
                const options = this.getOptions(context);
                _options_TelemetryHandlerOptions__WEBPACK_IMPORTED_MODULE_5__[/* TelemetryHandlerOptions */ "b"].updateFeatureUsageFlag(context, _options_TelemetryHandlerOptions__WEBPACK_IMPORTED_MODULE_5__[/* FeatureUsageFlag */ "a"].RETRY_HANDLER_ENABLED);
                return yield this.executeWithRetry(context, retryAttempts, options);
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * To set the next middleware in the chain
     * @param {Middleware} next - The middleware instance
     * @returns Nothing
     */
    setNext(next) {
        this.nextMiddleware = next;
    }
}
/**
 * @private
 * @static
 * A list of status codes that needs to be retried
 */
RetryHandler.RETRY_STATUS_CODES = [
    429,
    503,
    504,
];
/**
 * @private
 * @static
 * A member holding the name of retry attempt header
 */
RetryHandler.RETRY_ATTEMPT_HEADER = "Retry-Attempt";
/**
 * @private
 * @static
 * A member holding the name of retry after header
 */
RetryHandler.RETRY_AFTER_HEADER = "Retry-After";
//# sourceMappingURL=RetryHandler.js.map

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RedirectHandler; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _RequestMethod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);
/* harmony import */ var _MiddlewareControl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _MiddlewareUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);
/* harmony import */ var _options_RedirectHandlerOptions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(28);
/* harmony import */ var _options_TelemetryHandlerOptions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(21);
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */






/**
 * @class
 * Class
 * @implements Middleware
 * Class representing RedirectHandler
 */
class RedirectHandler {
    /**
     * @public
     * @constructor
     * To create an instance of RedirectHandler
     * @param {RedirectHandlerOptions} [options = new RedirectHandlerOptions()] - The redirect handler options instance
     * @returns An instance of RedirectHandler
     */
    constructor(options = new _options_RedirectHandlerOptions__WEBPACK_IMPORTED_MODULE_4__[/* RedirectHandlerOptions */ "a"]()) {
        this.options = options;
    }
    /**
     * @private
     * To check whether the response has the redirect status code or not
     * @param {Response} response - The response object
     * @returns A boolean representing whether the response contains the redirect status code or not
     */
    isRedirect(response) {
        return RedirectHandler.REDIRECT_STATUS_CODES.indexOf(response.status) !== -1;
    }
    /**
     * @private
     * To check whether the response has location header or not
     * @param {Response} response - The response object
     * @returns A boolean representing the whether the response has location header or not
     */
    hasLocationHeader(response) {
        return response.headers.has(RedirectHandler.LOCATION_HEADER);
    }
    /**
     * @private
     * To get the redirect url from location header in response object
     * @param {Response} response - The response object
     * @returns A redirect url from location header
     */
    getLocationHeader(response) {
        return response.headers.get(RedirectHandler.LOCATION_HEADER);
    }
    /**
     * @private
     * To check whether the given url is a relative url or not
     * @param {string} url - The url string value
     * @returns A boolean representing whether the given url is a relative url or not
     */
    isRelativeURL(url) {
        return url.indexOf("://") === -1;
    }
    /**
     * @private
     * To check whether the authorization header in the request should be dropped for consequent redirected requests
     * @param {string} requestUrl - The request url value
     * @param {string} redirectUrl - The redirect url value
     * @returns A boolean representing whether the authorization header in the request should be dropped for consequent redirected requests
     */
    shouldDropAuthorizationHeader(requestUrl, redirectUrl) {
        const schemeHostRegex = /^[A-Za-z].+?:\/\/.+?(?=\/|$)/;
        const requestMatches = schemeHostRegex.exec(requestUrl);
        let requestAuthority;
        let redirectAuthority;
        if (requestMatches !== null) {
            requestAuthority = requestMatches[0];
        }
        const redirectMatches = schemeHostRegex.exec(redirectUrl);
        if (redirectMatches !== null) {
            redirectAuthority = redirectMatches[0];
        }
        return typeof requestAuthority !== "undefined" && typeof redirectAuthority !== "undefined" && requestAuthority !== redirectAuthority;
    }
    /**
     * @private
     * @async
     * To update a request url with the redirect url
     * @param {string} redirectUrl - The redirect url value
     * @param {Context} context - The context object value
     * @returns Nothing
     */
    updateRequestUrl(redirectUrl, context) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            context.request = typeof context.request === "string" ? redirectUrl : yield Object(_MiddlewareUtil__WEBPACK_IMPORTED_MODULE_3__[/* cloneRequestWithNewUrl */ "b"])(redirectUrl, context.request);
        });
    }
    /**
     * @private
     * To get the options for execution of the middleware
     * @param {Context} context - The context object
     * @returns A options for middleware execution
     */
    getOptions(context) {
        let options;
        if (context.middlewareControl instanceof _MiddlewareControl__WEBPACK_IMPORTED_MODULE_2__[/* MiddlewareControl */ "a"]) {
            options = context.middlewareControl.getMiddlewareOptions(_options_RedirectHandlerOptions__WEBPACK_IMPORTED_MODULE_4__[/* RedirectHandlerOptions */ "a"]);
        }
        if (typeof options === "undefined") {
            options = Object.assign(new _options_RedirectHandlerOptions__WEBPACK_IMPORTED_MODULE_4__[/* RedirectHandlerOptions */ "a"](), this.options);
        }
        return options;
    }
    /**
     * @private
     * @async
     * To execute the next middleware and to handle in case of redirect response returned by the server
     * @param {Context} context - The context object
     * @param {number} redirectCount - The redirect count value
     * @param {RedirectHandlerOptions} options - The redirect handler options instance
     * @returns A promise that resolves to nothing
     */
    executeWithRedirect(context, redirectCount, options) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            try {
                yield this.nextMiddleware.execute(context);
                const response = context.response;
                if (redirectCount < options.maxRedirects && this.isRedirect(response) && this.hasLocationHeader(response) && options.shouldRedirect(response)) {
                    ++redirectCount;
                    if (response.status === RedirectHandler.STATUS_CODE_SEE_OTHER) {
                        context.options.method = _RequestMethod__WEBPACK_IMPORTED_MODULE_1__[/* RequestMethod */ "a"].GET;
                        delete context.options.body;
                    }
                    else {
                        const redirectUrl = this.getLocationHeader(response);
                        if (!this.isRelativeURL(redirectUrl) && this.shouldDropAuthorizationHeader(response.url, redirectUrl)) {
                            delete context.options.headers[RedirectHandler.AUTHORIZATION_HEADER];
                        }
                        yield this.updateRequestUrl(redirectUrl, context);
                    }
                    yield this.executeWithRedirect(context, redirectCount, options);
                }
                else {
                    return;
                }
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * @async
     * To execute the current middleware
     * @param {Context} context - The context object of the request
     * @returns A Promise that resolves to nothing
     */
    execute(context) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            try {
                const redirectCount = 0;
                const options = this.getOptions(context);
                context.options.redirect = RedirectHandler.MANUAL_REDIRECT;
                _options_TelemetryHandlerOptions__WEBPACK_IMPORTED_MODULE_5__[/* TelemetryHandlerOptions */ "b"].updateFeatureUsageFlag(context, _options_TelemetryHandlerOptions__WEBPACK_IMPORTED_MODULE_5__[/* FeatureUsageFlag */ "a"].REDIRECT_HANDLER_ENABLED);
                return yield this.executeWithRedirect(context, redirectCount, options);
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * To set the next middleware in the chain
     * @param {Middleware} next - The middleware instance
     * @returns Nothing
     */
    setNext(next) {
        this.nextMiddleware = next;
    }
}
/**
 * @private
 * @static
 * A member holding the array of redirect status codes
 */
RedirectHandler.REDIRECT_STATUS_CODES = [
    301,
    302,
    303,
    307,
    308,
];
/**
 * @private
 * @static
 * A member holding SeeOther status code
 */
RedirectHandler.STATUS_CODE_SEE_OTHER = 303;
/**
 * @private
 * @static
 * A member holding the name of the location header
 */
RedirectHandler.LOCATION_HEADER = "Location";
/**
 * @private
 * @static
 * A member representing the authorization header name
 */
RedirectHandler.AUTHORIZATION_HEADER = "Authorization";
/**
 * @private
 * @static
 * A member holding the manual redirect value
 */
RedirectHandler.MANUAL_REDIRECT = "manual";
//# sourceMappingURL=RedirectHandler.js.map

/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(2);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/GraphRequestUtil.js
var GraphRequestUtil = __webpack_require__(36);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/Version.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
// THIS FILE IS AUTO GENERATED
// ANY CHANGES WILL BE LOST DURING BUILD
/**
 * @module Version
 */
const PACKAGE_VERSION = "2.2.1";
//# sourceMappingURL=Version.js.map
// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/MiddlewareControl.js
var MiddlewareControl = __webpack_require__(17);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/MiddlewareUtil.js
var MiddlewareUtil = __webpack_require__(19);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/options/TelemetryHandlerOptions.js
var TelemetryHandlerOptions = __webpack_require__(21);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/TelemetryHandler.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TelemetryHandler_TelemetryHandler; });
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */

/**
 * @module TelemetryHandler
 */





/**
 * @class
 * @implements Middleware
 * Class for TelemetryHandler
 */
class TelemetryHandler_TelemetryHandler {
    /**
     * @public
     * @async
     * To execute the current middleware
     * @param {Context} context - The context object of the request
     * @returns A Promise that resolves to nothing
     */
    execute(context) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                const url = typeof context.request === "string" ? context.request : context.request.url;
                if (Object(GraphRequestUtil["a" /* isGraphURL */])(url)) {
                    // Add telemetry only if the request url is a Graph URL.
                    // Errors are reported as in issue #265 if headers are present when redirecting to a non Graph URL
                    let clientRequestId = Object(MiddlewareUtil["d" /* getRequestHeader */])(context.request, context.options, TelemetryHandler_TelemetryHandler.CLIENT_REQUEST_ID_HEADER);
                    if (!clientRequestId) {
                        clientRequestId = Object(MiddlewareUtil["c" /* generateUUID */])();
                        Object(MiddlewareUtil["e" /* setRequestHeader */])(context.request, context.options, TelemetryHandler_TelemetryHandler.CLIENT_REQUEST_ID_HEADER, clientRequestId);
                    }
                    let sdkVersionValue = `${TelemetryHandler_TelemetryHandler.PRODUCT_NAME}/${PACKAGE_VERSION}`;
                    let options;
                    if (context.middlewareControl instanceof MiddlewareControl["a" /* MiddlewareControl */]) {
                        options = context.middlewareControl.getMiddlewareOptions(TelemetryHandlerOptions["b" /* TelemetryHandlerOptions */]);
                    }
                    if (options) {
                        const featureUsage = options.getFeatureUsage();
                        sdkVersionValue += ` (${TelemetryHandler_TelemetryHandler.FEATURE_USAGE_STRING}=${featureUsage})`;
                    }
                    Object(MiddlewareUtil["a" /* appendRequestHeader */])(context.request, context.options, TelemetryHandler_TelemetryHandler.SDK_VERSION_HEADER, sdkVersionValue);
                }
                else {
                    // Remove telemetry headers if present during redirection.
                    delete context.options.headers[TelemetryHandler_TelemetryHandler.CLIENT_REQUEST_ID_HEADER];
                    delete context.options.headers[TelemetryHandler_TelemetryHandler.SDK_VERSION_HEADER];
                }
                return yield this.nextMiddleware.execute(context);
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * To set the next middleware in the chain
     * @param {Middleware} next - The middleware instance
     * @returns Nothing
     */
    setNext(next) {
        this.nextMiddleware = next;
    }
}
/**
 * @private
 * @static
 * A member holding the name of the client request id header
 */
TelemetryHandler_TelemetryHandler.CLIENT_REQUEST_ID_HEADER = "client-request-id";
/**
 * @private
 * @static
 * A member holding the name of the sdk version header
 */
TelemetryHandler_TelemetryHandler.SDK_VERSION_HEADER = "SdkVersion";
/**
 * @private
 * @static
 * A member holding the language prefix for the sdk version header value
 */
TelemetryHandler_TelemetryHandler.PRODUCT_NAME = "graph-js";
/**
 * @private
 * @static
 * A member holding the key for the feature usage metrics
 */
TelemetryHandler_TelemetryHandler.FEATURE_USAGE_STRING = "featureUsage";
//# sourceMappingURL=TelemetryHandler.js.map

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return clearPrivateEntries; });


function clearPrivateEntries(jwk) {
  ;['p', 'q', 'd', 'dp', 'dq', 'qi'].forEach((key) => {
    if (key in jwk) {
      delete jwk[key]
    }
  })
  return jwk
}


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  decode: __webpack_require__(135),
  verify: __webpack_require__(338),
  sign: __webpack_require__(341),
  JsonWebTokenError: __webpack_require__(74),
  NotBeforeError: __webpack_require__(192),
  TokenExpiredError: __webpack_require__(193),
};


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return toArray; });
/* eslint-disable no-bitwise */
/* eslint-disable prefer-rest-params */
/* eslint-disable no-extend-native */
function toArray(x) {
  if (Array.isArray(x)) {
    return x.flat()
  }
  return [x]
}

if (!Array.prototype.flat) {
  Object.defineProperty(Array.prototype, 'flat', {
    enumerable: false,
    value() {
      let depth = arguments[0]
      depth = depth === undefined ? 1 : Math.floor(depth)
      if (depth < 1) {
        return Array.prototype.slice.call(this)
      }
      return (function flat(arr, flatDepth) {
        const len = arr.length >>> 0
        let flattened = []
        let i = 0
        while (i < len) {
          if (i in arr) {
            const el = arr[i]
            if (Array.isArray(el) && flatDepth > 0) {
              flattened = flattened.concat(flat(el, flatDepth - 1))
            } else {
              flattened.push(el)
            }
          }
          i++
        }
        return flattened
      })(this, depth)
    }
  })
}


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GRAPH_API_VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return GRAPH_BASE_URL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return GRAPH_URLS; });
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @module Constants
 */
/**
 * @constant
 * A Default API endpoint version for a request
 */
const GRAPH_API_VERSION = "v1.0";
/**
 * @constant
 * A Default base url for a request
 */
const GRAPH_BASE_URL = "https://graph.microsoft.com/";
/**
 * To hold list of the service root endpoints for Microsoft Graph and Graph Explorer for each national cloud.
 * Set(iterable:Object) is not supported in Internet Explorer. The consumer is recommended to use a suitable polyfill.
 */
const GRAPH_URLS = new Set(["graph.microsoft.com", "graph.microsoft.us", "dod-graph.microsoft.us", "graph.microsoft.de", "microsoftgraph.chinacloudapi.cn"]);
//# sourceMappingURL=Constants.js.map

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(9)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(3)
var MD5 = __webpack_require__(91)
var RIPEMD160 = __webpack_require__(93)
var sha = __webpack_require__(94)
var Base = __webpack_require__(35)

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(27);
var assert = __webpack_require__(23);

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const inherits = __webpack_require__(3);
const Reporter = __webpack_require__(108).Reporter;
const Buffer = __webpack_require__(106).Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
  if (data instanceof DecoderBuffer) {
    return true;
  }

  // Or accept compatible API
  const isCompatible = typeof data === 'object' &&
    Buffer.isBuffer(data.base) &&
    data.constructor.name === 'DecoderBuffer' &&
    typeof data.offset === 'number' &&
    typeof data.length === 'number' &&
    typeof data.save === 'function' &&
    typeof data.restore === 'function' &&
    typeof data.isEmpty === 'function' &&
    typeof data.readUInt8 === 'function' &&
    typeof data.skip === 'function' &&
    typeof data.raw === 'function';

  return isCompatible;
};

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  const res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
};

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  const res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
};

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!EncoderBuffer.isEncoderBuffer(item))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
  if (data instanceof EncoderBuffer) {
    return true;
  }

  // Or accept compatible API
  const isCompatible = typeof data === 'object' &&
    data.constructor.name === 'EncoderBuffer' &&
    typeof data.length === 'number' &&
    typeof data.join === 'function';

  return isCompatible;
};

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = Buffer.alloc(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ContextBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ResponseBase; });
/* harmony import */ var _util_cancellation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);
/* harmony import */ var _util_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14);





























/** Represents IOPA Context object for any State Flow or REST Request/Response */
class ContextBase
  extends _map__WEBPACK_IMPORTED_MODULE_3__[/* default */ "b"]
 {
  

  

  

  

  

  

  

  

  

  

  /** Initialize blank IopaContext object;  Generic properties common to all server types included */
   init() {
    const tokensource = new _util_cancellation__WEBPACK_IMPORTED_MODULE_0__[/* default */ "c"]()

    this.set('server.Timestamp', Date.now())
    this.set('iopa.Events', new _util_events__WEBPACK_IMPORTED_MODULE_1__[/* EventEmitter */ "b"]())
    this.set('iopa.Version', _constants__WEBPACK_IMPORTED_MODULE_2__["VERSION"])
    this.set('server.CancelTokenSource', tokensource)
    this.set('server.CancelToken', tokensource.token)
    this.set('server.Capabilities', new _map__WEBPACK_IMPORTED_MODULE_3__[/* default */ "b"]())
    return this
  }

   using(appFuncPromiseOrValue) {
    if (typeof appFuncPromiseOrValue === 'function') {
      return _using({ context: this, p: appFuncPromiseOrValue(this) })
    }
    return _using({ context: this, p: appFuncPromiseOrValue })
  }

   get 'server.TimeElapsed'() {
    return Date.now() - this['server.Timestamp']
  }

  capability(keyOrRef, value) {
    if (typeof keyOrRef === 'string') {
      return this.get('server.Capabilities').get(keyOrRef )
    }
    return this[(keyOrRef ).id]
  }

  setCapability(keyOrRef, value) {
    if (typeof keyOrRef === 'string') {
      this.get('server.Capabilities').set(keyOrRef , value)
      return
    }
    this.get('server.Capabilities')[(keyOrRef ).id] = value
  }
}

/** Represents IOPA Context object for any State Flow or REST Request/Response */
class ResponseBase
  extends _map__WEBPACK_IMPORTED_MODULE_3__[/* default */ "b"]
 {
  

  

  

  

  

  /** Initialize blank IopaContext object;  Generic properties common to all server types included */
   init() {
    return this
  }
}

/* ES6 finally/dispose pattern for IOPA Context */
function _using({
  context,
  p
}


) {
  return new Promise((resolve, reject) => {
    if (typeof p === 'undefined') {
      p = null
    }
    resolve(p)
  }).then(
    (value) => {
      return Promise.resolve(
        (() => {
          process.nextTick(() => {
            if (context.dispose) {
              context.dispose()
            }
          })
          return value
        })()
      )
    },
    (err) => {
      console.error(err)
      process.nextTick(() => {
        if (context.dispose) {
          context.dispose()
        }
      })
      throw err
    }
  )
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return Fragment; });
const Fragment = Symbol('Fragment')


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return TokenSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Token; });
/* unused harmony export empty */



















/**  A Cancellation Token Source */
class TokenSource  {
  





  constructor() {
    this.data = {
      reason: null,
      isCancelled: false,
      listeners: []
    }
  }

  /**  cancel  :signals cancel for all tokens issued by this source */
   cancel(reason) {
    this.data.isCancelled = true
    this.data.reason = reason
    // eslint-disable-next-line no-plusplus
    for (let i = 0; i < this.data.listeners.length; i++) {
      if (typeof this.data.listeners[i] === 'function') {
        this.data.listeners[i](reason)
      }
    }
  }

   get token() {
    return new Token(this)
  }

   get isCancelled() {
    return this.data.isCancelled
  }

   get reason() {
    return this.data.reason
  }

   register(cb) {
    this.data.listeners.push(cb)
  }
}

/** Helper Method to return a Cancellation Token */
class Token  {
  

  constructor(source) {
    this.source = source
  }

  get isCancelled() {
    return this.source.isCancelled
  }

  onCancelled(callback) {
    this.source.register(callback)
  }

  throwIfCancelled() {
    if (this.isCancelled) {
      throw new Error(this.source.reason)
    }

    this.onCancelled((reason) => {
      throw new Error(reason)
    })
  }
}

const empty = Object.freeze(new TokenSource().token)

/* harmony default export */ __webpack_exports__["c"] = (TokenSource);


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Disposable; });
/* unused harmony export DisposablesComposite */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return EventEmitter; });



















/* Polyfill EventEmitter. */

class Disposable  {
  

  constructor(disposer) {
    this.disposer = disposer
  }

  dispose() {
    this.disposer.apply(this.disposer)
  }
}

class DisposablesComposite {
  

  constructor() {
    this.disposables = new Set()
  }

  add(disposable) {
    this.disposables.add(disposable)
    return disposable
  }

  dispose() {
    this.disposables.forEach((disposable) => {
      disposable.dispose.apply(disposable)
    })
  }
}

class EventEmitter  {
  

  

  constructor() {
    this.listeners = new Map()
    this.onceListeners = new Map()
  }

  emit(event, ...args) {
    const callbacks = this.listeners.get(event)
    if (callbacks) {
      callbacks.forEach((cb) => cb(...args))
    }
    const onceCallbacks = this.onceListeners.get(event)
    if (onceCallbacks) {
      onceCallbacks.forEach((cb) => cb(...args))
      this.onceListeners.delete(event)
    }
  }

  on(event, cb) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set())
    }
    const existing = this.listeners.get(event)
    existing.add(cb)
    return new Disposable(() => {
      existing.delete(cb)
    })
  }

  once(event, cb) {
    if (!this.onceListeners.has(event)) {
      this.onceListeners.set(event, new Set())
    }
    const existing = this.onceListeners.get(event)
    existing.add(cb)
    return new Disposable(() => {
      existing.delete(cb)
    })
  }

  emitWithReturn(event, ...args) {
    const callbacks = Array.from(this.listeners.get(event) || [])
    return callbacks.map((cb) => cb(...args))
  }

  clear(event) {
    if (event) {
      this.listeners.delete(event)
      this.onceListeners.delete(event)
    } else {
      this.listeners.clear()
      this.onceListeners.clear()
    }
  }
}


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(37).EventEmitter;
var inherits = __webpack_require__(3);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(88);
Stream.Writable = __webpack_require__(240);
Stream.Duplex = __webpack_require__(241);
Stream.Transform = __webpack_require__(242);
Stream.PassThrough = __webpack_require__(243);

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(244);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(245);

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb, null, ret) },
            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = __webpack_require__(6).Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(6).Buffer
var MD5 = __webpack_require__(91)

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(30);
var utils = __webpack_require__(24);
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(316)
var aesid = __webpack_require__(324)
var fixProc = __webpack_require__(325)
var ciphers = __webpack_require__(96)
var compat = __webpack_require__(155)
var Buffer = __webpack_require__(6).Buffer
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      // throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      // throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}


/***/ }),
/* 74 */
/***/ (function(module, exports) {

var JsonWebTokenError = function (message, error) {
  Error.call(this, message);
  if(Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  }
  this.name = 'JsonWebTokenError';
  this.message = message;
  if (error) this.inner = error;
};

JsonWebTokenError.prototype = Object.create(Error.prototype);
JsonWebTokenError.prototype.constructor = JsonWebTokenError;

module.exports = JsonWebTokenError;


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return setLocalResourceProtocolMapper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return renderToObject; });
/* harmony import */ var _util_rhast2jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85);
/* harmony import */ var _util_rcast2rhast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/* harmony import */ var _util_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
/* harmony import */ var _util_children__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55);
/* harmony import */ var _util_to_absolute_url__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(116);







// important must use commonjs required Symbol in case running under webpack
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { Fragment } = __webpack_require__(64)

const EMPTY_OBJECT = Object.freeze({})

const AbsoluteRegExp = new RegExp('^(?:[a-z]+:)', 'i')

let localResourceProtocolMapper = null

function setLocalResourceProtocolMapper(
  mapper
) {
  localResourceProtocolMapper = mapper
}

function renderToObject(
  element,
  resourceRoot,
  _parent
) {
  if (
    element === null ||
    typeof element === 'string' ||
    typeof element === 'number' ||
    typeof element === 'boolean' ||
    element === null
  ) {
    return element
  }
  if (Array.isArray(element)) {
    const result = []

    for (let i = 0, len = element.length; i < len; i++) {
      const item = renderToObject(element[i], resourceRoot, element)
      if (item) {
        result.push(item)
      }
    }

    return result 
  }

  const { type } = element

  if (type) {
    const props = element.props || EMPTY_OBJECT

    if (
      type === 'image' &&
      props.url &&
      global.process &&
      (global.process.platform === 'darwin' ||
        global.process.platform === 'android')
      // running on mobile or non html based browser
      // https://github.com/microsoft/AdaptiveCards/issues/777
    ) {
      props.url = props.url.replace(/\.svg$/, '.png')
      console.log(`SVG not supported on mobile. Converted to ${props.url}`)
    }

    if (
      type === 'image' &&
      localResourceProtocolMapper &&
      !AbsoluteRegExp.test(props.url)
    ) {
      props.url = Object(_util_to_absolute_url__WEBPACK_IMPORTED_MODULE_4__[/* toAbsoluteUrl */ "a"])(
        props.url,
        localResourceProtocolMapper(resourceRoot || '')
      )
    }

    if (
      props.backgroundImage &&
      localResourceProtocolMapper &&
      !AbsoluteRegExp.test(props.backgroundImage)
    ) {
      props.backgroundImage = Object(_util_to_absolute_url__WEBPACK_IMPORTED_MODULE_4__[/* toAbsoluteUrl */ "a"])(
        props.backgroundImage,
        localResourceProtocolMapper(resourceRoot || '')
      )
    }

    if (
      type === 'action' &&
      props.children &&
      (Object.keys(props).length === 1 ||
        (props.intents && Object.keys(props).length === 2))
    ) {
      props.type = 'submit'
      props.data = props.children.join(' ')
    }

    if (type === 'action') {
      props.style =
        // eslint-disable-next-line no-self-assign
        props.style /** uncomment to default to "positive" if needed: || 'positive' */
    }

    Object.keys(props).forEach((prop) => {
      if (prop.startsWith('__')) {
        delete props[prop]
      }
    })

    if (typeof type === 'function') {
      return renderToObject(type(props), resourceRoot, element)
    }
    if (type === Fragment) {
      return renderToObject(props.children, resourceRoot, element)
    }
    if (typeof type === 'string') {
      const result = {}

      let { children } = props // always an array
      if (children.length > 0 && type in _util_constants__WEBPACK_IMPORTED_MODULE_2__[/* PROMOTE_ALIASES */ "i"]) {
        const MY_PROMOTE_ALIASES = _util_constants__WEBPACK_IMPORTED_MODULE_2__[/* PROMOTE_ALIASES */ "i"][type]
        const promote = children.filter(
          (child) => child && child.type in MY_PROMOTE_ALIASES
        )
        if (promote.length > 0) {
          children = children.filter(
            (child) => !(child && child.type in MY_PROMOTE_ALIASES)
          )

          promote.forEach((child, i) => {
            if (child.type in _util_constants__WEBPACK_IMPORTED_MODULE_2__[/* RAW_ALIASES */ "j"]) {
              result[MY_PROMOTE_ALIASES[child.type]] = Object(_util_rhast2jsx__WEBPACK_IMPORTED_MODULE_0__[/* rhast2jsx */ "a"])(
                Object(_util_rcast2rhast__WEBPACK_IMPORTED_MODULE_1__[/* rcast2rhast */ "a"])(child.props.children[0] || {}) 
              )
            } else {
              const childresult = renderToObject(
                child.props.children,
                resourceRoot,
                element
              )
              result[MY_PROMOTE_ALIASES[child.type]] =
                childresult.length === 1 && typeof childresult[0] !== 'object'
                  ? childresult[0]
                  : childresult
            }
          })
        }
      }

      children = renderToObject(children, resourceRoot, element)

      let newType = type

      if (type in _util_constants__WEBPACK_IMPORTED_MODULE_2__[/* SPLIT_ALIASES */ "k"] && props.type in _util_constants__WEBPACK_IMPORTED_MODULE_2__[/* SPLIT_ALIASES */ "k"][type]) {
        newType = _util_constants__WEBPACK_IMPORTED_MODULE_2__[/* SPLIT_ALIASES */ "k"][type][props.type]
      } else if (_util_constants__WEBPACK_IMPORTED_MODULE_2__[/* CLASS_ALIASES */ "f"][type]) {
        newType = _util_constants__WEBPACK_IMPORTED_MODULE_2__[/* CLASS_ALIASES */ "f"][type]
      }

      if (children.length > 0 && type in _util_constants__WEBPACK_IMPORTED_MODULE_2__[/* CHILDREN_PROPS */ "d"]) {
        const firstchild = children[0]

        if (typeof firstchild === null) {
          children = []
        } else if (
          typeof firstchild === 'string' ||
          typeof firstchild === 'number' ||
          typeof firstchild === 'boolean'
        ) {
          children = firstchild
        }

        result[_util_constants__WEBPACK_IMPORTED_MODULE_2__[/* CHILDREN_PROPS */ "d"][type]] = Object(_util_children__WEBPACK_IMPORTED_MODULE_3__[/* toArray */ "a"])(children)
      } else if (children.length > 0 && props.type in _util_constants__WEBPACK_IMPORTED_MODULE_2__[/* CHILDREN_PROPS */ "d"]) {
        const firstchild = children[0]

        if (typeof firstchild === null) {
          children = []
        } else if (
          typeof firstchild === 'string' ||
          typeof firstchild === 'number' ||
          typeof firstchild === 'boolean'
        ) {
          children = firstchild
        }

        result[_util_constants__WEBPACK_IMPORTED_MODULE_2__[/* CHILDREN_PROPS */ "d"][props.type]] = Object(_util_children__WEBPACK_IMPORTED_MODULE_3__[/* toArray */ "a"])(children)
      } else if (children.length > 0 && type in _util_constants__WEBPACK_IMPORTED_MODULE_2__[/* CHILDREN_TEXT_PROPS */ "e"]) {
        const firstchild = children.join('')

        if (typeof firstchild === null) {
          children = ''
        } else if (
          typeof firstchild === 'string' ||
          typeof firstchild === 'number' ||
          typeof firstchild === 'boolean'
        ) {
          children = firstchild
        }

        result[_util_constants__WEBPACK_IMPORTED_MODULE_2__[/* CHILDREN_TEXT_PROPS */ "e"][type]] = children
      } else if (children.length === 1) {
        const firstchild = children[0]

        if (
          typeof firstchild === 'string' ||
          typeof firstchild === 'number' ||
          typeof firstchild === 'boolean' ||
          firstchild === null
        ) {
          children = firstchild
        }

        result[firstchild.type || 'value'] = Object(_util_children__WEBPACK_IMPORTED_MODULE_3__[/* toArray */ "a"])(children)
      }

      result.type = newType

      Object.keys(props).forEach((prop) => {
        const value = props[prop]

        if (
          prop === 'type' ||
          prop === 'children' ||
          prop === 'key' ||
          prop === 'ref'
        ) {
          // ignore
        } else {
          const name = _util_constants__WEBPACK_IMPORTED_MODULE_2__[/* ATTR_ALIASES */ "a"][prop] || prop
          result[name] = value
        }
      })

      if (result.type && _util_constants__WEBPACK_IMPORTED_MODULE_2__[/* IMPLICIT_ALIASES */ "h"][result.type]) {
        delete result.type
      }

      return result
    }
  } else {
    throw new Error(`Invalid card element type`)
  }

  return undefined
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16)))

/***/ }),
/* 76 */
/***/ (function(module, exports) {

























































































/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IOPA", function() { return IOPA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SERVER", function() { return SERVER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "APPBUILDER", function() { return APPBUILDER; });
/*
 * Internet Open Protocol Abstraction (IOPA)
 * Copyright (c) 2016-2020 Internet Open Protocol Alliance
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const VERSION = '3.0'

const IOPA = Object.freeze({
  // V3 Request / Response
  Headers: 'iopa.Headers',
  Method: 'iopa.Method',
  OriginalUrl: 'iopa.OriginalUrl',
  URL: 'iopa.Url',
  Path: 'iopa.Path',
  Protocol: 'iopa.Protocol',
  QueryString: 'iopa.QueryString',
  Scheme: 'iopa.Scheme',
  Body: 'iopa.Body',
  RemoteAddress: 'iopa.RemoteAddress',
  StatusCode: 'iopa.StatusCode',
  StatusText: 'iopa.StatusText',

  Events: 'iopa.Events',
  Version: 'iopa.Version',
  Error: 'iopa.Error',
  Seq: 'server.Id',

  // V1.4 request response constanst (deprecated)

  Auth: 'iopa.Auth',
  Host: 'iopa.Host',
  Port: 'iopa.Port',
  RawBody: 'iopa.RawBody',

  METHODS: {
    data: 'urn:io.iopa:data',
    GET: 'GET',
    PUT: 'PUT',
    DELETE: 'DELETE',
    POST: 'POST'
  },

  CAPABILITIES: {
    App: 'urn:io.iopa:app'
  }
})

const SERVER = Object.freeze({
  Id: 'server.Id',
  Capabilities: 'server.Capabilities',
  IsBuilt: 'server.IsBuilt',
  Pipeline: 'server.Pipeline',
  Factory: 'server.Factory',
  CancelToken: 'server.CancelToken',
  CancelTokenSource: 'server.CancelTokenSource',
  AppId: 'server.AppId',
  AppType: 'server.AppType',
  AppDescription: 'server.AppDescription',
  IsChild: 'server.IsChild',
  ParentContext: 'server.ParentContext',
  RawStream: 'server.RawStream',
  RawTransport: 'server.RawTransport',
  IsLocalOrigin: 'server.IsLocalOrigin',
  IsRequest: 'server.IsRequest',
  Events: 'server.Events',
  Version: 'server.Version'
})

const APPBUILDER = Object.freeze({
  DefaultApp: 'app.DefaultApp',
  DefaultMiddleware: 'app.DefaultMiddleware'
})


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
// The Teams schemas was manually added to botframework-schema.
// This file has been updated imported from the botframework-schema and the extension folder
// and updated with swagger like typescript fetch api (see api file)
__exportStar(__webpack_require__(353), exports);
__exportStar(__webpack_require__(354), exports);
//# sourceMappingURL=index.js.map

/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AuthenticationHandlerOptions; });
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @class
 * @implements MiddlewareOptions
 * Class representing AuthenticationHandlerOptions
 */
class AuthenticationHandlerOptions {
    /**
     * @public
     * @constructor
     * To create an instance of AuthenticationHandlerOptions
     * @param {AuthenticationProvider} [authenticationProvider] - The authentication provider instance
     * @param {AuthenticationProviderOptions} [authenticationProviderOptions] - The authentication provider options instance
     * @returns An instance of AuthenticationHandlerOptions
     */
    constructor(authenticationProvider, authenticationProviderOptions) {
        this.authenticationProvider = authenticationProvider;
        this.authenticationProviderOptions = authenticationProviderOptions;
    }
}
//# sourceMappingURL=AuthenticationHandlerOptions.js.map

/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(2);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/Range.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @module Range
 */
/**
 * @class
 * Class representing Range
 */
class Range {
    /**
     * @public
     * @constructor
     * Creates a range for given min and max values
     * @param {number} [minVal = -1] - The minimum value.
     * @param {number} [maxVal = -1] - The maximum value.
     * @returns An instance of a Range
     */
    constructor(minVal = -1, maxVal = -1) {
        this.minValue = minVal;
        this.maxValue = maxVal;
    }
}
//# sourceMappingURL=Range.js.map
// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/tasks/LargeFileUploadTask.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LargeFileUploadTask_LargeFileUploadTask; });
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */


/**
 * @class
 * Class representing LargeFileUploadTask
 */
class LargeFileUploadTask_LargeFileUploadTask {
    /**
     * @public
     * @constructor
     * Constructs a LargeFileUploadTask
     * @param {Client} client - The GraphClient instance
     * @param {FileObject} file - The FileObject holding details of a file that needs to be uploaded
     * @param {LargeFileUploadSession} uploadSession - The upload session to which the upload has to be done
     * @param {LargeFileUploadTaskOptions} options - The upload task options
     * @returns An instance of LargeFileUploadTask
     */
    constructor(client, file, uploadSession, options = {}) {
        /**
         * @private
         * Default value for the rangeSize
         */
        this.DEFAULT_FILE_SIZE = 5 * 1024 * 1024;
        this.client = client;
        this.file = file;
        if (options.rangeSize === undefined) {
            options.rangeSize = this.DEFAULT_FILE_SIZE;
        }
        this.options = options;
        this.uploadSession = uploadSession;
        this.nextRange = new Range(0, this.options.rangeSize - 1);
    }
    /**
     * @public
     * @static
     * @async
     * Makes request to the server to create an upload session
     * @param {Client} client - The GraphClient instance
     * @param {any} payload - The payload that needs to be sent
     * @param {KeyValuePairObjectStringNumber} headers - The headers that needs to be sent
     * @returns The promise that resolves to LargeFileUploadSession
     */
    static createUploadSession(client, requestUrl, payload, headers = {}) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                const session = yield client
                    .api(requestUrl)
                    .headers(headers)
                    .post(payload);
                const largeFileUploadSession = {
                    url: session.uploadUrl,
                    expiry: new Date(session.expirationDateTime),
                };
                return largeFileUploadSession;
            }
            catch (err) {
                throw err;
            }
        });
    }
    /**
     * @private
     * Parses given range string to the Range instance
     * @param {string[]} ranges - The ranges value
     * @returns The range instance
     */
    parseRange(ranges) {
        const rangeStr = ranges[0];
        if (typeof rangeStr === "undefined" || rangeStr === "") {
            return new Range();
        }
        const firstRange = rangeStr.split("-");
        const minVal = parseInt(firstRange[0], 10);
        let maxVal = parseInt(firstRange[1], 10);
        if (Number.isNaN(maxVal)) {
            maxVal = this.file.size - 1;
        }
        return new Range(minVal, maxVal);
    }
    /**
     * @private
     * Updates the expiration date and the next range
     * @param {UploadStatusResponse} response - The response of the upload status
     * @returns Nothing
     */
    updateTaskStatus(response) {
        this.uploadSession.expiry = new Date(response.expirationDateTime);
        this.nextRange = this.parseRange(response.nextExpectedRanges);
    }
    /**
     * @public
     * Gets next range that needs to be uploaded
     * @returns The range instance
     */
    getNextRange() {
        if (this.nextRange.minValue === -1) {
            return this.nextRange;
        }
        const minVal = this.nextRange.minValue;
        let maxValue = minVal + this.options.rangeSize - 1;
        if (maxValue >= this.file.size) {
            maxValue = this.file.size - 1;
        }
        return new Range(minVal, maxValue);
    }
    /**
     * @public
     * Slices the file content to the given range
     * @param {Range} range - The range value
     * @returns The sliced ArrayBuffer or Blob
     */
    sliceFile(range) {
        const blob = this.file.content.slice(range.minValue, range.maxValue + 1);
        return blob;
    }
    /**
     * @public
     * @async
     * Uploads file to the server in a sequential order by slicing the file
     * @returns The promise resolves to uploaded response
     */
    upload() {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                while (true) {
                    const nextRange = this.getNextRange();
                    if (nextRange.maxValue === -1) {
                        const err = new Error("Task with which you are trying to upload is already completed, Please check for your uploaded file");
                        err.name = "Invalid Session";
                        throw err;
                    }
                    const fileSlice = this.sliceFile(nextRange);
                    const response = yield this.uploadSlice(fileSlice, nextRange, this.file.size);
                    // Upon completion of upload process incase of onedrive, driveItem is returned, which contains id
                    if (response.id !== undefined) {
                        return response;
                    }
                    else {
                        this.updateTaskStatus(response);
                    }
                }
            }
            catch (err) {
                throw err;
            }
        });
    }
    /**
     * @public
     * @async
     * Uploads given slice to the server
     * @param {ArrayBuffer | Blob | File} fileSlice - The file slice
     * @param {Range} range - The range value
     * @param {number} totalSize - The total size of a complete file
     */
    uploadSlice(fileSlice, range, totalSize) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                return yield this.client
                    .api(this.uploadSession.url)
                    .headers({
                    "Content-Length": `${range.maxValue - range.minValue + 1}`,
                    "Content-Range": `bytes ${range.minValue}-${range.maxValue}/${totalSize}`,
                })
                    .put(fileSlice);
            }
            catch (err) {
                throw err;
            }
        });
    }
    /**
     * @public
     * @async
     * Deletes upload session in the server
     * @returns The promise resolves to cancelled response
     */
    cancel() {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                return yield this.client.api(this.uploadSession.url).delete();
            }
            catch (err) {
                throw err;
            }
        });
    }
    /**
     * @public
     * @async
     * Gets status for the upload session
     * @returns The promise resolves to the status enquiry response
     */
    getStatus() {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                const response = yield this.client.api(this.uploadSession.url).get();
                this.updateTaskStatus(response);
                return response;
            }
            catch (err) {
                throw err;
            }
        });
    }
    /**
     * @public
     * @async
     * Resumes upload session and continue uploading the file from the last sent range
     * @returns The promise resolves to the uploaded response
     */
    resume() {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                yield this.getStatus();
                return yield this.upload();
            }
            catch (err) {
                throw err;
            }
        });
    }
}
//# sourceMappingURL=LargeFileUploadTask.js.map

/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return rcast2rhast; });
/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64);










const EMPTY_OBJECT = Object.freeze({})

/* Transform Reactive Cards Abstract Syntax Tree to ReactiveCards HAST (Html-Like Abstract Syntax Tree) */
function rcast2rhast(
  element
) {
  const props = (element ).props || EMPTY_OBJECT

  if (typeof element === 'string') {
    return {
      type: 'text',
      value: element
    }
  }
  if (typeof element === 'number' || typeof element === 'boolean') {
    return {
      type: 'text',
      value: element
    }
  }
  if (element == null) {
    return null
  }
  if (element.type === Function) {
    // in this case eval the functions with the known props

    return rcast2rhast(element.type(props))
  }
  const { children, ...rest } = props 
  let newChildren

  if (children && Array.isArray(children)) {
    newChildren = children
      ? (children.map((child) => rcast2rhast(child)).filter(Boolean) )
      : []
  } else if (children) {
    newChildren = [children]
  } else {
    newChildren = []
  }

  const result = {
    type: 'element',
    tagName: element.type,
    properties: rest,
    children: newChildren
  } 

  if ((result.tagName ) === _fragment__WEBPACK_IMPORTED_MODULE_0__["Fragment"]) {
    result.tagName = 'ReactiveCards.Fragment'
  }

  return result
}


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _carrier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(113);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CarrierMiddleware", function() { return _carrier__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "URN_CARRIER", function() { return _carrier__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony import */ var iopa_carrier_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(198);
/* harmony import */ var iopa_carrier_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(iopa_carrier_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var iopa_carrier_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var iopa_carrier_schema__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(iopa_carrier_schema__WEBPACK_IMPORTED_MODULE_2__);




// note: do not export testing-framework as msw distorts response in cloudlfare environment


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HTTPClient; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */

/**
 * @class
 * Class representing HTTPClient
 */
class HTTPClient {
    /**
     * @public
     * @constructor
     * Creates an instance of a HTTPClient
     * @param {...Middleware} middleware - The first middleware of the middleware chain or a sequence of all the Middleware handlers
     */
    constructor(...middleware) {
        if (!middleware || !middleware.length) {
            const error = new Error();
            error.name = "InvalidMiddlewareChain";
            error.message = "Please provide a default middleware chain or custom middleware chain";
            throw error;
        }
        this.setMiddleware(...middleware);
    }
    /**
     * @private
     * Processes the middleware parameter passed to set this.middleware property
     * The calling function should validate if middleware is not undefined or not empty.
     * @param {...Middleware} middleware - The middleware passed
     * @returns Nothing
     */
    setMiddleware(...middleware) {
        if (middleware.length > 1) {
            this.parseMiddleWareArray(middleware);
        }
        else {
            this.middleware = middleware[0];
        }
    }
    /**
     * @private
     * Processes the middleware array to construct the chain
     * and sets this.middleware property to the first middlware handler of the array
     * The calling function should validate if middleware is not undefined or not empty
     * @param {Middleware[]} middlewareArray - The array of middleware handlers
     * @returns Nothing
     */
    parseMiddleWareArray(middlewareArray) {
        middlewareArray.forEach((element, index) => {
            if (index < middlewareArray.length - 1) {
                element.setNext(middlewareArray[index + 1]);
            }
        });
        this.middleware = middlewareArray[0];
    }
    /**
     * @public
     * @async
     * To send the request through the middleware chain
     * @param {Context} context - The context of a request
     * @returns A promise that resolves to the Context
     */
    sendRequest(context) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            try {
                if (typeof context.request === "string" && context.options === undefined) {
                    const error = new Error();
                    error.name = "InvalidRequestOptions";
                    error.message = "Unable to execute the middleware, Please provide valid options for a request";
                    throw error;
                }
                yield this.middleware.execute(context);
                return context;
            }
            catch (error) {
                throw error;
            }
        });
    }
}
//# sourceMappingURL=HTTPClient.js.map

/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa/src/index.ts + 7 modules
var src = __webpack_require__(20);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botcommander/src/parser.ts
/* eslint-disable no-cond-assign */
/* eslint-disable no-bitwise */
/* eslint-disable prefer-destructuring */
/* eslint-disable no-continue */
/* eslint-disable no-async-promise-executor */
/**
 * BOT COMMANDER ASYNC
 *
 * TypeScript library for parsing commands from interactive interfaces (bot chats)
 * Based on and inspired by [tj/commander.js] and [friscoMad/botCommander]
 *
 * (1) Added async functionality for embedding within iopa-bot or Microsoft botbuilder frameworks:
 *        Resolves promise once command has been actioned (or help/error displayed)
 * (2) Updated to tj/commander V3 without version functionality
 * (3) Added bot.apicommand and bot.parseapi methods
 *
 * LICENSE AND COPYRIGHT FOR THIS FILE ONLY:  MIT
 *
 * Copyright (c) Guy Barnard 2019
 * Portions Copyright (c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * Portions Copyright (c) 2017 Ramiro Aparicio rapariciog@gmail.com
 *
 */



const { EventEmitter } = src["g" /* util */]






































class Option {
    

    

    

    

    

    

    

    

    

    

    /** Initialize a new `Option` with the given `flags` and `description` */
    constructor(flags, description) {
        this.flags = flags
        this.required = flags.indexOf('<') >= 0
        this.optional = flags.indexOf('[') >= 0
        this.negate = flags.indexOf('-no-') !== -1
        const flagsArray = flags.split(/[ ,|]+/)
        if (flagsArray.length > 1 && !/^[[<]/.test(flagsArray[1])) {
            this.short = flagsArray.shift()
        }
        this.long = flagsArray.shift()
        this.description = description || ''
        this.parseValue = (arg) => arg
    }

    /** Initialize a new `Option` with the given `flags` and `description` */
    name() {
        return this.long.replace(/^--/, '')
    }

    /**
     * Return option name, in a camelcase format that can be used
     * as a object attribute key.
     */
     attributeName() {
        return camelcase(this.name().replace(/^no-/, ''))
    }

    /** Check if `arg` matches the short or long flag  */
     is(arg) {
        return this.short === arg || this.long === arg
    }
}

class BotCommand extends EventEmitter {
    //
    // Command Meta Data
    //

    

     __init() {this._alias = null}

    

    

    

     __init2() {this._noHelp = false}

     __init3() {this._prefixes = null}

    //
    // Command definition (arguments and options)
    //

     __init4() {this._cmdArgs = []}

     __init5() {this._cmdOptions = []}

    //
    // Command hierarchy (children and parent)

     __init6() {this._commands = []}

    

    //
    // Help flags
    //
     __init7() {this._helpFlags = '-h, --help'}

     __init8() {this._helpDescription = 'output usage information'}

     __init9() {this._helpShortFlag = '-h'}

     __init10() {this._helpLongFlag = '--help'}

    //
    // Overall parser configurgation (for this command and subsequent)
    //
     __init11() {this.parserConfig = {
        send: null ,
        allowUnknownOption: false,
        showHelpOnError: true,
        lowerCase: false,
        showHelpOnEmpty: false,
    }}

    //
    // CONSTRUCTOR
    //

    constructor(name) {
        super();BotCommand.prototype.__init.call(this);BotCommand.prototype.__init2.call(this);BotCommand.prototype.__init3.call(this);BotCommand.prototype.__init4.call(this);BotCommand.prototype.__init5.call(this);BotCommand.prototype.__init6.call(this);BotCommand.prototype.__init7.call(this);BotCommand.prototype.__init8.call(this);BotCommand.prototype.__init9.call(this);BotCommand.prototype.__init10.call(this);BotCommand.prototype.__init11.call(this);
        this._name = name || ''
    }

    /** Initialize a new `BotCommand` */
     command(
        nameAndArgs,
        config = {}
    ) {
        const args = nameAndArgs.split(/ +/)
        const cmd = new BotCommand(args.shift())
        cmd.setParserConfig(this.parserConfig)
        cmd._noHelp = !!config.noHelp
        cmd._helpFlags = this._helpFlags
        cmd._helpDescription = this._helpDescription
        cmd._helpShortFlag = this._helpShortFlag
        cmd._helpLongFlag = this._helpLongFlag
        this._commands.push(cmd)
        cmd.parseExpectedArgs(args)
        cmd._parent = this

        if (this._commands.length === 1 && args[0] !== 'help') {
            this.addImplicitHelpCommand()
        }

        return cmd
    }

    //
    // PUBLIC METHODS
    //

    /** Overwrite all parse options for a command and the subcommands created afterwards */
     setParserConfig(parserConfig) {
        this.parserConfig = parserConfig
    }

    /** Define argument syntax for the top-level command */
     arguments(desc) {
        return this.parseExpectedArgs(desc.split(/ +/))
    }

    /** Add an implicit `help [cmd]` subcommand which invokes `--help` for the given command. */
     addImplicitHelpCommand() {
        this.command('help [cmd]').description('display help for [cmd]')
    }

    /** Parse expected `args`.  For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`. */
     parseExpectedArgs(args) {
        if (!args.length) {
            return this
        }
        args.forEach((arg) => {
            const argDetails = {
                required: false,
                name: '',
                variadic: false,
            }

            switch (arg[0]) {
                case '<':
                    argDetails.required = true
                    argDetails.name = arg.slice(1, -1)
                    break
                case '[':
                    argDetails.name = arg.slice(1, -1)
                    break
                default:
                /** noop */
            }

            if (
                argDetails.name.length > 3 &&
                argDetails.name.slice(-3) === '...'
            ) {
                argDetails.variadic = true
                argDetails.name = argDetails.name.slice(0, -3)
            }
            if (argDetails.name) {
                this._cmdArgs.push(argDetails)
            }
        })
        return this
    }

    /** Register callback `fn` for the command */
     action(fn) {
        const listener = async (
            prevParsed,
            metadata
        ) => {
            let args = prevParsed.args || []

            const parsed = this.parseLine((prevParsed.unknown || []).join(' '))

            if (parsed.errors.length > 0) {
                this._checkShowHelp(parsed.errors)
                await this.send(metadata, parsed.errors.join('\n'))
                return
            }

            const helptext = this.outputHelpIfNecessary(parsed.unknown)

            if (helptext) {
                await this.send(metadata, helptext)
                return
            }

            if (
                parsed.unknown.length > 0 &&
                !this.parserConfig.allowUnknownOption
            ) {
                const msg = []
                msg.push(this.unknownOption(parsed.unknown[0]))
                this._checkShowHelp(msg)
                await this.send(metadata, msg.join('\n'))
                return
            }

            args = prevParsed.args.concat(parsed.args)
            const data = this.cmdOptionsObject(prevParsed.data, parsed.data)

            const errors = []
            this._cmdArgs.forEach((arg, i) => {
                if (args[i] && args[i].match(/["'].+["']/)) {
                    data[arg.name] = args[i].substring(1, args[i].length - 1)
                } else if (args[i] && args[i].startsWith('@')) {
                    data[arg.name] = args[i].substring(1)
                } else {
                    data[arg.name] = args[i] || null
                }
                if (arg.required && args[i] == null) {
                    errors.push(this.missingArgument(arg.name))
                } else if (arg.variadic) {
                    if (i !== this._cmdArgs.length - 1) {
                        errors.push(this.variadicArgNotLast(arg.name))
                    }
                    data[arg.name] = args.splice(i) 
                }
            })
            if (errors.length > 0) {
                this._checkShowHelp(errors)
                await this.send(metadata, errors.join('\n'))
                return
            }
            data.raw = prevParsed.line
            try {
                await fn.call(this, metadata.context, data)
            } catch (ex) {
                console.error(ex)
                await this.send(
                    metadata,
                    `${ex.statusText || ex.message || ex.toString()}`
                )
            }
            metadata.resolve()
        }

        const parent = this._parent || this
        const name = parent === this ? '*' : this._name
        this.on(`command:${name}`, listener)
        if (this._alias) {
            this.on(`command:${this._alias}`, listener)
        }
        return this
    }

    /** Register callback `fn` for the api */
     api(fn) {
        const parent = this._parent || this
        const name = parent === this ? '*' : this._name

        this._noHelp = true

        const listener = async (metadata, data) => {
            await fn.call(this, metadata.context, data)
            metadata.resolve()
        }

        this._parent.on(`api:${name}`, listener)
        if (this._alias) {
            parent.on(`api:${this._alias}`, listener)
        }

        return this
    }

    /** Register callback `fn` for the api */
     async invoke(name, context, data) {
        let metadata

        await new Promise((resolve, reject) => {
            metadata = { context, resolve, reject }

            const command = this._commands.find(
                (cmd) => cmd._name === name || cmd._alias === name
            )

            if (command) {
                this.emit(`api:${name}`, metadata, data)
            } else {
                resolve(null)
            }
        })

        context.log('botcommander action  complete')

        metadata = null
    }

    /** Define option with `flags`, `description` and optional coercion `fn`.
     *
     * The `flags` string should contain both the short and long flags,
     * separated by comma, a pipe or space. The following are all valid
     * all will output this way when `--help` is used.
     *
     *    "-p, --pepper"
     *    "-p|--pepper"
     *    "-p --pepper"
     *
     * Examples:
     *
     *     // simple boolean defaulting to undefined
     *     bot.option('-p, --pepper', 'add pepper');
     *
     *     bot.pepper
     *     // => undefined
     *
     *     --pepper
     *     bot.pepper
     *     // => true
     *
     *     // simple boolean defaulting to true (unless non-negated option is also defined)
     *     bot.option('-C, --no-cheese', 'remove cheese');
     *
     *     bot.cheese
     *     // => true
     *
     *     --no-cheese
     *     bot.cheese
     *     // => false
     *
     *     // required argument
     *     bot.option('-C, --chdir <path>', 'change the working directory');
     *
     *     --chdir /tmp
     *     bot.chdir
     *     // => "/tmp"
     *
     *     // optional argument
     *     bot.option('-c, --cheese [type]', 'add cheese [marble]');
     *
     */
    





     option(
        flags,
        description,
        fn,
        defaultValue
    ) {
        const option = new Option(flags, description)
        const oname = option.name()
        const name = option.attributeName()

        // default as 3rd arg
        if (typeof fn !== 'function') {
            if (fn instanceof RegExp) {
                // This is a bit simplistic (especially no error messages), and probably better handled by caller using custom option processing.
                // No longer documented in README, but still present for backwards compatibility.
                const regex = fn
                fn = (val, def) => {
                    const m = regex.exec(val)
                    return m ? m[0] : def
                }
            } else {
                defaultValue = fn
                fn = null
            }
        }

        if (
            option.negate ||
            option.optional ||
            option.required ||
            typeof defaultValue === 'boolean'
        ) {
            if (option.negate) {
                const opts = this.cmdOptionsObject({}, {})
                defaultValue = Object.prototype.hasOwnProperty.call(opts, name)
                    ? opts[name]
                    : true
            }
            if (defaultValue !== undefined) {
                this[name] = defaultValue
                option.defaultValue = defaultValue
            }
        }

        this._cmdOptions.push(option)

        this.on(`option:${oname}`, (val) => {
            if (val !== null && fn) {
                val = (fn )(
                    val,
                    this[name] === undefined ? defaultValue : this[name]
                )
            }

            if (
                typeof this[name] === 'boolean' ||
                typeof this[name] === 'undefined'
            ) {
                if (val == null) {
                    this[name] = option.negate ? false : defaultValue || true
                } else {
                    this[name] = val
                }
            } else if (val !== null) {
                this[name] = option.negate ? false : val
            }
        })

        return this
    }

    /**
     * Allow unknown _cmdOptions on the command line.
     */
     configAllowUnknownOption(arg = true) {
        this.parserConfig.allowUnknownOption = arg
        return this
    }

    /**  Configure output function for errors */
     configSetSend(cb) {
        this.parserConfig.send = cb
        return this
    }

    /**  Show full command help when an error occurs */
     configShowHelpOnError(arg = true) {
        this.parserConfig.showHelpOnError = arg
        return this
    }

    /** Show full command help when no command is found */
     configShowHelpOnEmpty(arg = true) {
        this.parserConfig.showHelpOnEmpty = arg
        return this
    }

    /**
     * Sets the prefix to search when parsing a line of text, this option is not inherited by subcommands otherwise it would
     * require double prefix for subcomands something like !command !subcommad
     */
     configPrefix(prefix) {
        if (typeof prefix === 'string') {
            this._prefixes = [prefix]
        } else {
            this._prefixes = prefix
        }
        return this
    }

    /**
     * Parse line of text, settings _cmdOptions and invoking commands actions when defined.
     * If there is no command defined in the line or there is some error the help will be sent.
     */
     async parse(line, context) {
        return new Promise(async (resolve, reject) => {
            const metadata = { context, resolve, reject }

            if (this._prefixes) {
                const prefixFound = this._prefixes.find((prefix) =>
                    line.startsWith(prefix)
                )
                if (prefixFound == null) {
                    resolve() // or reject?
                    return
                }
                line = line.substring(prefixFound.length)
            }

            const parsed = this.parseLine(line)

            if (parsed.errors.length > 0) {
                this._checkShowHelp(parsed.errors)
                this.send(metadata, parsed.errors.join('\n'))
                return
            }

            delete parsed.errors

            this.parseCommand(parsed, metadata)
        })
    }

    /** Parse _cmdOptions from `argv` returning `argv`  void of these _cmdOptions  */
     parseLine(line, prevResult) {
        const rawArgs = line
            .split(/(".+?")|('.+?')|\s+/g)
            .filter((a) => a && a.length > 0)

        const argv = this.normalize(rawArgs)
        const args = []

        const errors = []
        const data = prevResult ? prevResult.data : {}
        const len = argv.length
        let literal
        let option
        let arg

        const unknownOptions = []

        for (let i = 0; i < len; ++i) {
            arg = argv[i]

            if (literal) {
                args.push(arg)
                continue
            }

            if (arg === '--') {
                literal = true
                continue
            }

            option = this.cmdOptionFor(arg)

            if (option) {
                const name = option.name()
                if (option.required) {
                    arg = argv[++i]
                    if (arg == null) {
                        errors.push(this.optionMissingArgument(option))
                    } else {
                        this.emit(`option:${name}`, arg)
                    }
                    data[name] = option.parseValue(arg, data[name])
                } else if (option.optional) {
                    arg = argv[i + 1]
                    if (arg == null || (arg[0] === '-' && arg !== '-')) {
                        arg = null
                    } else {
                        ++i
                    }
                    data[name] = option.parseValue(arg, data[name])
                    this.emit(`option:${option.name()}`, arg)
                } else {
                    data[name] = option.parseValue(null, data[name])
                    this.emit(`option:${option.name()}`)
                }
                continue
            }

            if (arg.length > 1 && arg[0] === '-') {
                unknownOptions.push(arg)
                if (
                    i + 1 < argv.length &&
                    (argv[i + 1][0] !== '-' || argv[i + 1] === '-')
                ) {
                    unknownOptions.push(argv[++i])
                }
                continue
            }

            args.push(arg)
        }

        return {
            line: prevResult ? prevResult.line : line,
            args,
            data,
            rawArgs: prevResult ? prevResult.rawArgs : rawArgs,
            unknown: unknownOptions,
            errors,
        }
    }

    /**
     * Parse command `args`.
     *
     * If help it is requested or there is no argument to parse sends help, otherwise tries to invoke listener(s) when available, then it
     * checks if a subcommand is the first arg and delegates the parsing to that subcomand, otherwise the "*"
     * event is emitted and those actions are invoked.
     */
     async parseCommand(
        parsed,
        metadata
    ) {
        const { args } = parsed
        let name
        if (args.length && args[0] !== '') {
            name = args[0]
            if (this.parserConfig.lowerCase) {
                name = name.toLowerCase()
            }
            if (name === 'help' && args.length === 1) {
                this.outputHelp(metadata)
                return
            }
            if (name === 'help') {
                args.shift()
                name = args[0]
                parsed.unknown.push('--help')
                parsed.rawArgs = parsed.rawArgs.slice(1)
                parsed.rawArgs.push('--help')
            }
            if (this.listeners.has(`command:${name}`)) {
                args.shift()
                this.emit(`command:${name}`, parsed, metadata)
            } else {
                const command = this._commands.find(
                    (cmd) => cmd._name === name || cmd._alias === name
                )
                if (command) {
                    const line = parsed.rawArgs.slice(1).join(' ')
                    const newResult = command.parseLine(line, parsed)
                    command.emit(`command:${name}`, newResult, metadata)
                } else {
                    this.emit('command:*', parsed, metadata)
                }
            }
        } else if (this.parserConfig.showHelpOnEmpty) {
            const helptext = this.outputHelpIfNecessary(parsed.unknown)
            if (helptext) {
                await this.send(metadata, helptext)
            }
        }
    }

    /** Normalize `args`, splitting joined short flags   */
     normalize(args) {
        let ret = []
        let arg
        let lastOpt
        let index
        let short
        let opt

        for (let i = 0, len = args.length; i < len; ++i) {
            arg = args[i]
            if (i > 0) {
                lastOpt = this.cmdOptionFor(args[i - 1])
            }

            if (arg === '--') {
                ret = ret.concat(args.slice(i))
                break
            } else if (lastOpt && lastOpt.required) {
                ret.push(arg)
            } else if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
                short = arg.slice(0, 2)
                opt = this.cmdOptionFor(short)
                if (opt && (opt.required || opt.optional)) {
                    ret.push(short)
                    ret.push(arg.slice(2))
                } else {
                    arg.slice(1)
                        .split('')
                        // eslint-disable-next-line no-loop-func
                        .forEach((c) => {
                            ret.push(`-${c}`)
                        })
                }
            } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {
                ret.push(arg.slice(0, index), arg.slice(index + 1))
            } else {
                ret.push(arg)
            }
        }

        return ret
    }

    /** Return an option matching `arg` if any */
     cmdOptionFor(arg) {
        for (let i = 0, len = this._cmdOptions.length; i < len; ++i) {
            if (this._cmdOptions[i].is(arg)) {
                return this._cmdOptions[i]
            }
        }
        return null
    }

    /** Return an object containing _cmdOptions as key-value pairs */
     cmdOptionsObject(
        prevData,
        data
    ) {
        return this._cmdOptions.reduce(
            (accum, opt) => {
                const key = opt.attributeName()
                if (accum[key] == null) {
                    accum[key] = opt.defaultValue
                }
                return accum
            },
            { ...prevData, ...data }
        )
    }

    /** Argument `name` is missing */
     missingArgument(name) {
        return `  error: required argument ${name} `
    }

    /** `Option` is missing an argument, but received `flag` or nothing */
     optionMissingArgument(option, flag) {
        if (flag) {
            return `  error: option ${option.flags} argument missing, got ${flag}`
        }
        return `  error: option ${option.flags} argument missing`
    }

    /** Unknown option `flag` */
     unknownOption(flag) {
        return `error: unknown option '${flag}'`
    }

    /** Variadic argument with `name` is not the last argument as required */
     variadicArgNotLast(name) {
        return `error: variadic arguments must be last '${name}'`
    }

     get meta() {
        const args = this._cmdArgs.map((arg) => {
            return humanReadableArgName(arg)
        })

        const usage = `[--Options]${this._commands.length ? ' [command]' : ''}${
            this._cmdArgs.length ? ` ${args.join(' ')}` : ''
        }`

        return {
            description: this._description,
            alias: this._alias,
            usage: this._usage || usage,
            name: this._name,
        }
    }

    /**
     * Set the description to `str`.
     */
     description(
        str,
        argsDescription
    ) {
        this._description = str
        this._argsDescription = argsDescription
        return this
    }

    /**
     * Set an alias for the command
     */
     alias(alias) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let command = this

        if (this._commands.length !== 0) {
            command = this._commands[this._commands.length - 1]
        }

        if (arguments.length === 0) {
            return command._alias 
        }

        if (alias === command._name) {
            throw new Error("BotCommand alias can't be the same as its name")
        }

        command._alias = alias

        return this
    }

    /**
     * Set / get the command usage `str`.
     */
     usage(str) {
        this._usage = str

        return this
    }

    /**
     * Get or set the name of the command
     */
     name(str) {
        this._name = str
        return this
    }

    /** Return prepared commands */
     prepareCommands() {
        return this._commands
            .filter((cmd) => {
                return !cmd._noHelp
            })
            .map((cmd) => {
                const args = cmd._cmdArgs
                    .map((arg) => {
                        return humanReadableArgName(arg)
                    })
                    .join(' ')

                return [
                    cmd._name +
                        (cmd._alias ? `|${cmd._alias}` : '') +
                        (cmd._cmdOptions.length ? ' [_cmdOptions]' : '') +
                        (args ? ` ${args}` : ''),
                    cmd._description,
                ]
            })
    }

    /** Return the largest command length */
     largestCommandLength() {
        const commands = this.prepareCommands()
        return commands.reduce((max, command) => {
            return Math.max(max, command[0].length)
        }, 0)
    }

    /** Return the largest option length */
     largestOptionLength() {
        const _cmdOptions = [].slice.call(this._cmdOptions)
        _cmdOptions.push({
            flags: this._helpFlags,
        })

        return _cmdOptions.reduce((max, option) => {
            return Math.max(max, option.flags.length)
        }, 0)
    }

    /**  Return the largest arg length */
     largestArgLength() {
        return this._cmdArgs.reduce((max, arg) => {
            return Math.max(max, arg.name.length)
        }, 0)
    }

    /** Return the pad width */
     padWidth() {
        let width = this.largestOptionLength()
        if (this._argsDescription && this._cmdArgs.length) {
            if (this.largestArgLength() > width) {
                width = this.largestArgLength()
            }
        }

        if (this._commands && this._commands.length) {
            if (this.largestCommandLength() > width) {
                width = this.largestCommandLength()
            }
        }

        return width
    }

    /** Return help for _cmdOptions */
     optionHelp() {
        const width = this.padWidth()

        // Append the help information
        return this._cmdOptions
            .map((option) => {
                return `${pad(option.flags, width)}  ${option.description}${
                    !option.negate && option.defaultValue !== undefined
                        ? ` (default: ${JSON.stringify(option.defaultValue)})`
                        : ''
                }`
            })
            .concat([
                `${pad(this._helpFlags, width)}  ${this._helpDescription}`,
            ])
            .join('\n')
    }

    /** Return command help documentation */
     commandHelp() {
        if (!this._commands.length) {
            return ''
        }

        const commands = this.prepareCommands()
        const width = this.padWidth()

        return [
            'Commands:',
            commands
                .map((cmd) => {
                    const desc = cmd[1] ? `  ${cmd[1]}` : ''
                    return (desc ? pad(cmd[0], width) : cmd[0]) + desc
                })
                .join('\n\r')
                .replace(/^/gm, '  '),
            '',
        ].join('\n\r')
    }

    /** Return bot help documentation */
     helpInformation() {
        let desc = []
        if (this._description) {
            desc = [this._description, '']

            const argsDescription = this._argsDescription
            if (argsDescription && this._cmdArgs.length) {
                const width = this.padWidth()
                desc.push('Arguments:')
                desc.push('')
                this._cmdArgs.forEach((arg) => {
                    desc.push(
                        `  ${pad(arg.name, width)}  ${
                            argsDescription[arg.name]
                        }`
                    )
                })
                desc.push('')
            }
        }

        let cmdName = this._name
        if (this._alias) {
            cmdName = `${cmdName}|${this._alias}`
        }
        let parentCmdNames = ''
        for (
            let parentCmd = this._parent;
            parentCmd;
            parentCmd = parentCmd._parent
        ) {
            parentCmdNames = `${parentCmd._name} ${parentCmdNames}`
        }
        const usage = [
            `Usage: ${parentCmdNames}${cmdName} ${this.meta.usage}`,
            '',
        ]

        let cmds = []
        const commandHelp = this.commandHelp()
        if (commandHelp) {
            cmds = [commandHelp]
        }

        const optionsText = [
            'Options:',
            `${this.optionHelp().replace(/^/gm, '  ')}`,
            '',
        ]

        return usage.concat(desc).concat(optionsText).concat(cmds).join('\n')
    }

    /**
     * Output help information for this command
     *
     * @api public
     */

    /** Sends a message using the configured send function */
     async send(metadata, msg) {
        if (msg && msg.length > 0) {
            await this.parserConfig.send(metadata.context, msg)
        }
        metadata.resolve()
    }

    /**
    * Output help information for this command

    */
     outputHelp(metadata) {
        return this.send(metadata, this.helpInformation())
    }

    /**
     * You can pass in flags and a description to override the help
     * flags and help description for your command.
     */
     helpOption(flags, description) {
        this._helpFlags = flags || this._helpFlags
        this._helpDescription = description || this._helpDescription

        const splitFlags = this._helpFlags.split(/[ ,|]+/)

        if (splitFlags.length > 1) {
            this._helpShortFlag = splitFlags.shift()
        }

        this._helpLongFlag = splitFlags.shift()

        return this
    }

    /** Checks if showHelpOnError is true and in that case adds the help to the error string */
     _checkShowHelp(arr) {
        if (this.parserConfig.showHelpOnError) {
            arr.push(this.helpInformation())
        }
    }

    /**
     * Output help information if necessary
     */
     outputHelpIfNecessary(optionParams) {
        optionParams = optionParams || []

        for (let i = 0; i < optionParams.length; i++) {
            if (
                optionParams[i] === this._helpLongFlag ||
                optionParams[i] === this._helpShortFlag
            ) {
                return this.helpInformation()
            }
        }

        return null
    }
}

/**
 * Camel-case the given `flag`
 */
function camelcase(flag) {
    return flag.split('-').reduce((str, word) => {
        return str + word[0].toUpperCase() + word.slice(1)
    })
}

/**
 * Pad `str` to `width`.
 */
function pad(str, width) {
    const len = Math.max(0, width - str.length)
    return str + Array(len + 1).join(' ')
}

/**
 * Takes an argument and returns its human readable equivalent for help usage.
 */
function humanReadableArgName(arg) {
    const nameOutput = arg.name + (arg.variadic === true ? '...' : '')

    return arg.required ? `<${nameOutput}>` : `[${nameOutput}]`
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botcommander/src/index.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return URN_BOTINTENT_LITERAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return src_BotCommanderMiddleware; });
/* unused concated harmony import BotCommand */
/* unused concated harmony import MetaData */
/* unused concated harmony import Option */
/* unused concated harmony import ParserConfig */



const URN_BOTINTENT_LITERAL = 'urn:io.iopa.bot:intent:literal'

class src_BotCommanderMiddleware {
    

    constructor(app) {
        this.app = app

        app.bot = new BotCommand()

        app.bot.configSetSend(async (context, msg) => {
            await context.response.send(msg)
        })
    }

    async invoke(
        context,
        next
    ) {
        if (
            context['bot.Intent'] === 'urn:io.iopa.bot:intent:literal' &&
            context['bot.Text']
        ) {
            await this.app.bot.parse(context['bot.Text'], context)
            // never call next as we always complete inside the bot
        } else {
            await next()
        }
    }
}




/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/util/escape-string.ts
const ESCAPE_REGEXP = /["&<>]/g

const ESCAPE_MAP = {
  '"': '&quot;',
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;'
}

function escapeChar(char) {
  return ESCAPE_MAP[char]
}

function escapeString(value) {
  if (!ESCAPE_REGEXP.test(value)) {
    return value
  }

  return String(value).replace(ESCAPE_REGEXP, escapeChar)
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/util/rhast2jsx.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return rhast2jsx; });
/* unused harmony export renderToJSX */



const EMPTY_OBJECT = Object.freeze({})

/* Compile ReactiveCards HAST (Html-Like Abstract Syntax Tree) to JSX source code */
function rhast2jsx(tree) {
  if (tree.tagName === 'card') {
    if (
      tree.properties.$schema ===
      'http://adaptivecards.io/schemas/adaptive-card.json'
    ) {
      delete tree.properties.$schema
    }
  }

  return renderToJSX(tree)
}

function renderToJSX(element) {
  if (typeof element === 'string') {
    return element
  }
  if (typeof element === 'number') {
    return `${element}`
  }
  if (typeof element === 'boolean' || element == null) {
    return `{${element}}`
  }

  if ((element ).type === 'text') {
    const { value } = element 

    if (typeof value === 'string') {
      return value
    }
    if (typeof value === 'number') {
      return `${value}`
    }
    if (typeof value === 'boolean' || value == null) {
      return `{${value}}`
    }

    return value
  }
  if ((element ).type === 'code') {
    return `{${(element ).value}}`
  }
  element = element 

  const { tagName } = element

  const properties = element.properties || EMPTY_OBJECT

  let jsx = `<${tagName}`

  Object.keys(properties).forEach((prop) => {
    const value = properties[prop]

    if (prop === 'children' || prop === 'key' || prop === 'ref') {
      // skip
    } else if (typeof value === 'string') {
      jsx += ` ${prop}="${escapeString(value)}"`
    } else if (typeof value === 'number') {
      jsx += ` ${prop}={${String(value)}}`
    } else if (typeof value === 'boolean' && value) {
      jsx += ` ${prop}`
    } else if (typeof value === 'object' && value && value.type === 'code') {
      jsx += ` ${prop}={${value}}`
    }
  })

  if (!element.children) {
    throw new Error('Children in HAST must be an array')
  }

  if (element.children.length > 0) {
    jsx += '>'
    jsx += element.children.map((child) => renderToJSX(child)).join('')
    jsx += `</${tagName}>`
  } else {
    jsx += ` />`
  }

  return jsx
}


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _capabilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(202);
/* unused harmony reexport * */
/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* unused harmony reexport * */
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(117);
/* unused harmony reexport * */
/*
 * Internet Open Protocol Abstraction (IOPA)
 * Copyright (c) 2016 - 2020 Internet Open Protocol Alliance
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

/*global exports*/
var SignStream = __webpack_require__(231);
var VerifyStream = __webpack_require__(337);

var ALGORITHMS = [
  'HS256', 'HS384', 'HS512',
  'RS256', 'RS384', 'RS512',
  'PS256', 'PS384', 'PS512',
  'ES256', 'ES384', 'ES512'
];

exports.ALGORITHMS = ALGORITHMS;
exports.sign = SignStream.sign;
exports.verify = VerifyStream.verify;
exports.decode = VerifyStream.decode;
exports.isValid = VerifyStream.isValid;
exports.createSign = function createSign(opts) {
  return new SignStream(opts);
};
exports.createVerify = function createVerify(opts) {
  return new VerifyStream(opts);
};


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(138);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(89);
exports.Duplex = __webpack_require__(38);
exports.Transform = __webpack_require__(141);
exports.PassThrough = __webpack_require__(239);


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(68);
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(__webpack_require__(58));
util.inherits = __webpack_require__(3);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(90)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(139);
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(6).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(140);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(38);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(38);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10), __webpack_require__(237).setImmediate, __webpack_require__(16)))

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16)))

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(3)
var HashBase = __webpack_require__(143)
var Buffer = __webpack_require__(6).Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).


var ERR_STREAM_PREMATURE_CLOSE = __webpack_require__(43).codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(9).Buffer
var inherits = __webpack_require__(3)
var HashBase = __webpack_require__(143)

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(257)
exports.sha1 = __webpack_require__(258)
exports.sha224 = __webpack_require__(259)
exports.sha256 = __webpack_require__(150)
exports.sha384 = __webpack_require__(260)
exports.sha512 = __webpack_require__(151)


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(23);

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var ciphers = __webpack_require__(269)
var deciphers = __webpack_require__(277)
var modes = __webpack_require__(164)

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var modeModules = {
  ECB: __webpack_require__(270),
  CBC: __webpack_require__(271),
  CFB: __webpack_require__(272),
  CFB8: __webpack_require__(273),
  CFB1: __webpack_require__(274),
  OFB: __webpack_require__(275),
  CTR: __webpack_require__(162),
  GCM: __webpack_require__(162)
}

var modes = __webpack_require__(164)

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(283);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(9)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).


var ERR_STREAM_PREMATURE_CLOSE = __webpack_require__(46).codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(102)
var randomBytes = __webpack_require__(42)

function blind (priv) {
  var r = getr(priv)
  var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed()
  return { blinder: blinder, unblinder: r.invm(priv.modulus) }
}

function getr (priv) {
  var len = priv.modulus.byteLength()
  var r
  do {
    r = new BN(randomBytes(len))
  } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2))
  return r
}

function crt (msg, priv) {
  var blinds = blind(priv)
  var len = priv.modulus.byteLength()
  var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus)
  var c1 = blinded.toRed(BN.mont(priv.prime1))
  var c2 = blinded.toRed(BN.mont(priv.prime2))
  var qinv = priv.coefficient
  var p = priv.prime1
  var q = priv.prime2
  var m1 = c1.redPow(priv.exponent1).fromRed()
  var m2 = c2.redPow(priv.exponent2).fromRed()
  var h = m1.isub(m2).imul(qinv).umod(p).imul(q)
  return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, 'be', len)
}
crt.getr = getr

module.exports = crt

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(296).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this._strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    var z = 0;
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      var b;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        b = c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }

      r |= b;
      z |= b;
    }

    assert(!(z & 0xf0), 'Invalid character in ' + str);
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)(module)))

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = exports;

elliptic.version = __webpack_require__(297).version;
elliptic.utils = __webpack_require__(24);
elliptic.rand = __webpack_require__(98);
elliptic.curve = __webpack_require__(177);
elliptic.curves = __webpack_require__(104);

// Protocols
elliptic.ec = __webpack_require__(309);
elliptic.eddsa = __webpack_require__(313);


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curves = exports;

var hash = __webpack_require__(105);
var curve = __webpack_require__(177);
var utils = __webpack_require__(24);

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = __webpack_require__(308);
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var hash = exports;

hash.utils = __webpack_require__(27);
hash.common = __webpack_require__(61);
hash.sha = __webpack_require__(302);
hash.ripemd = __webpack_require__(306);
hash.hmac = __webpack_require__(307);

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* eslint-disable node/no-deprecated-api */



var buffer = __webpack_require__(9)
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Reporter = __webpack_require__(108).Reporter;
const EncoderBuffer = __webpack_require__(62).EncoderBuffer;
const DecoderBuffer = __webpack_require__(62).DecoderBuffer;
const assert = __webpack_require__(23);

// Supported tags
const tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
const methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
const overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent, name) {
  const state = {};
  this._baseState = state;

  state.name = name;
  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

const stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  const state = this._baseState;
  const cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  const res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  const state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      const clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  const state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  const state = this._baseState;

  // Filter children and args
  const children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      const res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        const value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    const state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  const state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  const state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  const state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  const state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  const state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  const state = this._baseState;
  const args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  const state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  const state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  const state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  const state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  let result = state['default'];
  let present = true;

  let prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    let tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      const save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  let prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      const explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    const start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      let save;
      if (state.any)
        save = input.save();
      const body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any) {
      // no-op
    } else if (state.choice === null) {
      result = this._decodeGeneric(state.tag, input, options);
    } else {
      result = this._decodeChoice(input, options);
    }

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      const data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
        ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  const state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
      ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  const state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  const state = this._baseState;
  let result = null;
  let match = false;

  Object.keys(state.choice).some(function(key) {
    const save = input.save();
    const node = state.choice[key];
    try {
      const value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  const state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  const result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  let result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default'];
    else
      return;
  }

  // Encode children first
  let content = null;
  let primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      const prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      const res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      const child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        const state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  if (!state.any && state.choice === null) {
    const tag = state.implicit !== null ? state.implicit : state.tag;
    const cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  const state = this._baseState;

  const node = state.choice[data.type];
  if (!node) {
    assert(
      false,
      data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  const state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const inherits = __webpack_require__(3);

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  const state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  const state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  const state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  const state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  const state = this._reporterState;

  const prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  const state = this._reporterState;

  const now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  let err;
  const state = this._reporterState;

  const inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  const state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
}
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Helper
function reverse(map) {
  const res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    const value = map[key];
    res[value] = key;
  });

  return res;
}

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = reverse(exports.tag);


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(332).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)(module)))

/***/ }),
/* 111 */
/***/ (function(module, exports) {






















/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var jwtTokenValidation_namespaceObject = {};
__webpack_require__.r(jwtTokenValidation_namespaceObject);
__webpack_require__.d(jwtTokenValidation_namespaceObject, "authenticateRequest", function() { return authenticateRequest; });
__webpack_require__.d(jwtTokenValidation_namespaceObject, "validateAuthHeader", function() { return validateAuthHeader; });

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema/dist/index.js
var dist = __webpack_require__(5);

// EXTERNAL MODULE: /Users/guy/Library/Caches/.wrangler/wranglerjs-1.13.0/node_modules/url/url.js
var url = __webpack_require__(12);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema-auth/src/authenticationConstants.ts
/**
 * TO CHANNEL FROM BOT: Login URL
 *
 * DEPRECATED: DO NOT USE
 */
const ToChannelFromBotLoginUrl =
    'https://login.microsoftonline.com/botframework.com/oauth2/v2.0/token'

/**
 * TO CHANNEL FROM BOT: Login URL prefix
 */
const ToChannelFromBotLoginUrlPrefix =
    'https://login.microsoftonline.com/'

/**
 * TO CHANNEL FROM BOT: Login URL token endpoint path
 */
const ToChannelFromBotTokenEndpointPath = '/oauth2/v2.0/token'

/**
 * TO CHANNEL FROM BOT: Default tenant from which to obtain a token for bot to channel communication
 */
const DefaultChannelAuthTenant = 'botframework.com'

/**
 * TO CHANNEL FROM BOT: OAuth scope to request
 */
const ToChannelFromBotOAuthScope =
    'https://api.botframework.com/.default'

/**
 * TO BOT FROM CHANNEL: Token issuer
 */
const ToBotFromChannelTokenIssuer = 'https://api.botframework.com'

/**
 * Application Setting Key for the OpenIdMetadataUrl value.
 */
const BotOpenIdMetadataKey = 'BotOpenIdMetadata'

/**
 * Application Setting Key for the ChannelService value.
 */
const ChannelService = 'ChannelService'

/**
 * Application Setting Key for the OAuthUrl value.
 */
const OAuthUrlKey = 'OAuthApiEndpoint'

/**
 * TO BOT FROM CHANNEL: OpenID metadata document for tokens coming from MSA
 */
const ToBotFromChannelOpenIdMetadataUrl =
    'https://login.botframework.com/v1/.well-known/openidconfiguration'

/**
 * TO BOT FROM ENTERPRISE CHANNEL: OpenID metadata document for tokens coming from MSA
 */
const ToBotFromEnterpriseChannelOpenIdMetadataUrlFormat =
    'https://{channelService}.enterprisechannel.botframework.com/v1/.well-known/openidconfiguration'

/**
 * TO BOT FROM EMULATOR: OpenID metadata document for tokens coming from MSA
 */
const ToBotFromEmulatorOpenIdMetadataUrl =
    'https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration'

/**
 * Allowed token signing algorithms. Tokens come from channels to the bot. The code
 * that uses this also supports tokens coming from the emulator.
 */
const AllowedSigningAlgorithms = ['RS256', 'RS384', 'RS512']

/**
 * "azp" Claim.
 * Authorized party - the party to which the ID Token was issued.
 * This claim follows the general format set forth in the OpenID Spec.
 *     http://openid.net/specs/openid-connect-core-1_0.html#IDToken
 */
const AuthorizedParty = 'azp'

/**
 * Audience Claim. From RFC 7519.
 *     https://tools.ietf.org/html/rfc7519#section-4.1.3
 * The "aud" (audience) claim identifies the recipients that the JWT is
 * intended for.  Each principal intended to process the JWT MUST
 * identify itself with a value in the audience claim.If the principal
 * processing the claim does not identify itself with a value in the
 * "aud" claim when this claim is present, then the JWT MUST be
 * rejected.In the general case, the "aud" value is an array of case-
 * sensitive strings, each containing a StringOrURI value.In the
 * special case when the JWT has one audience, the "aud" value MAY be a
 * single case-sensitive string containing a StringOrURI value.The
 * interpretation of audience values is generally application specific.
 * Use of this claim is OPTIONAL.
 */
const AudienceClaim = 'aud'

/**
 * Issuer Claim. From RFC 7519.
 *     https://tools.ietf.org/html/rfc7519#section-4.1.1
 * The "iss" (issuer) claim identifies the principal that issued the
 * JWT.  The processing of this claim is generally application specific.
 * The "iss" value is a case-sensitive string containing a StringOrURI
 * value.  Use of this claim is OPTIONAL.
 */
const IssuerClaim = 'iss'

/**
 * From RFC 7515
 *     https://tools.ietf.org/html/rfc7515#section-4.1.4
 * The "kid" (key ID) Header Parameter is a hint indicating which key
 * was used to secure the JWS. This parameter allows originators to
 * explicitly signal a change of key to recipients. The structure of
 * the "kid" value is unspecified. Its value MUST be a case-sensitive
 * string. Use of this Header Parameter is OPTIONAL.
 * When used with a JWK, the "kid" value is used to match a JWK "kid"
 * parameter value.
 */
const KeyIdHeader = 'kid'

/**
 * Token version claim name. As used in Microsoft AAD tokens.
 */
const VersionClaim = 'ver'

/**
 * App ID claim name. As used in Microsoft AAD 1.0 tokens.
 */
const AppIdClaim = 'appid'

/**
 * Service URL claim name. As used in Microsoft Bot Framework v3.1 auth.
 */
const ServiceUrlClaim = 'serviceurl'

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema-auth/src/httpAuthCredentials.ts








/**
 * HttpAuthAppCredentials auth implementation and cache
 */
class httpAuthCredentials_HttpAuthAppCredentials  {
     static  __initStatic() {this.trustedHostNames = new Map


([
        ['state.botframework.com', new Date(8640000000000000)], // Date.MAX_VALUE,
        ['api.botframework.com', new Date(8640000000000000)], // Date.MAX_VALUE,
        ['token.botframework.com', new Date(8640000000000000)], // Date.MAX_VALUE,
        ['state.botframework.azure.us', new Date(8640000000000000)], // Date.MAX_VALUE,
        ['api.botframework.azure.us', new Date(8640000000000000)], // Date.MAX_VALUE,
        ['token.botframework.azure.us', new Date(8640000000000000)], // Date.MAX_VALUE,
        ['smba.trafficmanager.net', new Date(8640000000000000)], // Date.MAX_VALUE,
    ])}

     static  __initStatic2() {this.cache = new Map


()}

    

    

    

     __init() {this.oAuthScope =
        ToChannelFromBotOAuthScope}

    

     __init2() {this.refreshingToken = null}

    constructor(
        appId,
        appPassword,
        channelAuthTenant
    ) {;httpAuthCredentials_HttpAuthAppCredentials.prototype.__init.call(this);httpAuthCredentials_HttpAuthAppCredentials.prototype.__init2.call(this);
        this.appId = appId
        this.appPassword = appPassword
        const tenant =
            channelAuthTenant && channelAuthTenant.length > 0
                ? channelAuthTenant
                : DefaultChannelAuthTenant
        this.oAuthEndpoint =
            ToChannelFromBotLoginUrlPrefix +
            tenant +
            ToChannelFromBotTokenEndpointPath
        this.tokenCacheKey = `${appId}-cache`
    }

    /**
     * Adds the host of service url to trusted hosts.
     * If expiration time is not provided, the expiration date will be current (utc) date + 1 day.
     * @param  {string} serviceUrl The service url
     * @param  {Date} expiration? The expiration date after which this service url is not trusted anymore
     */
     static trustServiceUrl(serviceUrl, expiration) {
        if (!expiration) {
            expiration = new Date(Date.now() + 86400000) // 1 day
        }

        const uri = url["parse"](serviceUrl)
        if (uri.host) {
            httpAuthCredentials_HttpAuthAppCredentials.trustedHostNames.set(uri.host, expiration)
        }
    }

    /**
     * Checks if the service url is for a trusted host or not.
     * @param  {string} serviceUrl The service url
     * @returns {boolean} True if the host of the service url is trusted; False otherwise.
     */
     static isTrustedServiceUrl(serviceUrl) {
        try {
            const uri = url["parse"](serviceUrl)
            if (uri.host) {
                return httpAuthCredentials_HttpAuthAppCredentials.isTrustedUrl(uri.host)
            }
        } catch (e) {
            // tslint:disable-next-line:no-console
            console.error(e)
        }

        return false
    }

     static isTrustedUrl(uri) {
        const expiration = httpAuthCredentials_HttpAuthAppCredentials.trustedHostNames.get(
            uri
        )
        if (expiration) {
            // check if the trusted service url is still valid
            return expiration.getTime() > Date.now() - 300000 // 5 Minutes
        }

        console.log(`Untrusted uri ${uri}`)

        return false
    }

     async signRequest(
        url,
        request
    ) {
        if (this.shouldSetToken(url)) {
            const token = await this.getToken()
            if (request.headers.set) {
                request.headers.set('authorization', `Bearer ${token}`)
            } else {
                ;(request.headers ).authorization = `Bearer ${token}`
            }
        }
    }

     async getToken(forceRefresh = false) {
        if (!forceRefresh) {
            // check the global cache for the token. If we have it, and it's valid, we're done.
            const oAuthToken = httpAuthCredentials_HttpAuthAppCredentials.cache.get(
                this.tokenCacheKey
            )
            if (oAuthToken) {
                // we have the token. Is it valid?
                if (oAuthToken.expiration_time > Date.now()) {
                    return oAuthToken.access_token
                }
            }
        }

        // We need to refresh the token, because:
        // 1. The user requested it via the forceRefresh parameter
        // 2. We have it, but it's expired
        // 3. We don't have it in the cache.
        const res = await this.refreshToken()
        this.refreshingToken = null

        let oauthResponse
        if (res && res.status === 200) {
            // `res` is equalivent to the results from the cached promise `this.refreshingToken`.
            // Because the promise has been cached, we need to see if the body has been read.
            // If the body has not been read yet, we can call res.json() to get the access_token.
            // If the body has been read, the OAuthResponse for that call should have been cached already,
            // in which case we can return the cache from there. If a cached OAuthResponse does not exist,
            // call getToken() again to retry the authentication process.
            if (!httpAuthCredentials_HttpAuthAppCredentials.cache.has(this.tokenCacheKey)) {
                if (res.bodyUsed) {
                    // ** not in cache but not used so likely just too close
                    // so come round again
                    return this.getToken()
                }

                oauthResponse = await res.json()

                // Subtract 5 minutes from expires_in so they'll we'll get a
                // new token before it expires.
                // eslint-disable-next-line @typescript-eslint/camelcase
                oauthResponse.expiration_time =
                    Date.now() + oauthResponse.expires_in * 1000 - 300000
                httpAuthCredentials_HttpAuthAppCredentials.cache.set(
                    this.tokenCacheKey,
                    oauthResponse
                )

                return oauthResponse.access_token
            }
            const oAuthToken = httpAuthCredentials_HttpAuthAppCredentials.cache.get(
                this.tokenCacheKey
            )

            if (oAuthToken) {
                return oAuthToken.access_token
            }
            return this.getToken()
        }
        throw new Error(
            (res && res.statusText) || 'Unknown Fetch Error Getting Token'
        )
    }

     async refreshToken() {
        if (!this.refreshingToken) {
            const params = new url["URLSearchParams"]() 
            params.append('grant_type', 'client_credentials')
            params.append('client_id', this.appId)
            params.append('client_secret', this.appPassword)
            params.append('scope', this.oAuthScope)

            this.refreshingToken = fetch(this.oAuthEndpoint, {
                method: 'POST',
                headers: [
                    [
                        'Content-Type',
                        'application/x-www-form-urlencoded; charset=UTF-8',
                    ],
                ],
                body: params,
            })
        }
        return (this.refreshingToken ) 
    }

     shouldSetToken(url) {
        return httpAuthCredentials_HttpAuthAppCredentials.isTrustedServiceUrl(url)
    }
} httpAuthCredentials_HttpAuthAppCredentials.__initStatic(); httpAuthCredentials_HttpAuthAppCredentials.__initStatic2();

/**
 * Member variables to this class follow the RFC Naming conventions, rather than C# naming conventions.
 */







// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema-auth/src/credentialProvider.ts
/**
 * CredentialProvider interface. This interface allows Bots to provide their own
 * implementation of what is, and what is not, a valid appId and password. This is
 * useful in the case of multi-tenant bots, where the bot may need to call
 * out to a service to determine if a particular appid/password pair
 * is valid.
 *
 * For Single Tenant bots (the vast majority) the simple static providers
 * are sufficient.
 */
































class SimpleCredentialProvider  {
    

    

    constructor(appId, appPassword) {
        this.appId = appId
        this.appPassword = appPassword
    }

    /**
     * Validate AppId.
     *
     * This method is async to enable custom implementations
     * that may need to call out to serviced to validate the appId / password pair.
     * @param  {string} appId bot appid
     * @returns {Promise<boolean>} true if it is a valid AppId
     */
     isValidAppId(appId) {
        return Promise.resolve(this.appId === appId)
    }

    /**
     * Get the app password for a given bot appId, if it is not a valid appId, return Null
     *
     * This method is async to enable custom implementations
     * that may need to call out to serviced to validate the appId / password pair.
     * @param  {string} appId bot appid
     * @returns {Promise<string|null>} password or null for invalid appid
     */
     getAppPassword(appId) {
        return Promise.resolve(this.appId === appId ? this.appPassword : null)
    }

    /**
     * Checks if bot authentication is disabled.
     * Return true if bot authentication is disabled.
     *
     * This method is async to enable custom implementations
     * that may need to call out to serviced to validate the appId / password pair.
     * @returns {Promise<boolean>} true if bot authentication is disabled.
     */
     isAuthenticationDisabled() {
        if (
            true
        ) {
            return Promise.resolve(true)
        }
        return Promise.resolve(false)
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema-auth/src/claimsIdentity.ts





/**
 * Represents a claims-based identity.
 */
class ClaimsIdentity {
    
    

    constructor(claims, isAuthenticated) {
        this.claims = claims
        this.isAuthenticated = isAuthenticated
    }

    /**
     * Returns a claim value (if its present)
     * @param  {string} claimType The claim type to look for
     * @returns {string|null} The claim value or null if not found
     */
     getClaimValue(claimType) {
        const claim = this.claims.find(
            (c) => c.type === claimType
        )

        return claim ? claim.value : null
    }
}

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/jsonwebtoken/index.js
var jsonwebtoken = __webpack_require__(54);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema-auth/src/endorsementsValidator.ts
class EndorsementsValidator {
    /**
     * Verify that the set of ChannelIds, which come from the incoming activities,
     * all match the endorsements found on the JWT Token.
     * For example, if an Activity comes from webchat, that channelId says
     * says "webchat" and the jwt token endorsement MUST match that.
     * @param channelId The channel name, typically extracted from the activity.ChannelId field, that to which the Activity is affinitized.
     * @param endorsements Whoever signed the JWT token is permitted to send activities only for
     * some specific channels. That list is the endorsement list, and is validated here against the channelId.
     * @returns {boolean} True is the channelId is found in the Endorsement set. False if the channelId is not found.
     */
     static validate(channelId, endorsements) {
        // If the Activity came in and doesn't have a Channel ID then it's making no
        // assertions as to who endorses it. This means it should pass.
        if (channelId === null || channelId.trim() === '') {
            return true
        }

        if (endorsements === null) {
            throw new Error('endorsements required')
        }

        // The Call path to get here is:
        // JwtTokenValidation.AuthenticateRequest
        //  ->
        //   JwtTokenValidation.ValidateAuthHeader
        //    ->
        //      ChannelValidation.AuthenticateChannelToken
        //       ->
        //          JWTTokenExtractor

        // Does the set of endorsements match the channelId that was passed in?

        // ToDo: Consider moving this to a HashSet instead of a string
        // array, to make lookups O(1) instead of O(N). To give a sense
        // of scope, tokens from WebChat have about 10 endorsements, and
        // tokens coming from Teams have about 20.

        return endorsements.some((value) => value === channelId)
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema-auth/src/openIdMetadata.ts
/**
 * @module botbuilder
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
// tslint:disable-next-line:no-var-requires no-require-imports
const getPem = __webpack_require__(349)
// tslint:disable-next-line:no-var-requires no-require-imports
const base64url = __webpack_require__(350)

class OpenIdMetadata {
    
     __init() {this.lastUpdated = 0}
    

    constructor(url) {;OpenIdMetadata.prototype.__init.call(this);
        this.url = url
    }

     async getKey(keyId) {
        // If keys are more than 5 days old, refresh them
        if (this.lastUpdated < Date.now() - 1000 * 60 * 60 * 24 * 5) {
            try {
                await this.refreshCache()

                // Search the cache even if we failed to refresh
                const key = this.findKey(keyId)
                return key
            } catch (err) {
                //logger.error('Error retrieving OpenId metadata at ' + this.url + ', error: ' + err.toString());
                // fall through and return cached key on error
                throw err
            }
        } else {
            // Otherwise read from cache
            const key = this.findKey(keyId)
            return key
        }
    }

     async refreshCache() {
        try {
            const res = await fetch(this.url)

            if (res.ok) {
                const openIdConfig = (await res.json()) 

                const getKeyResponse = await fetch(openIdConfig.jwks_uri)
                if (getKeyResponse.ok) {
                    this.lastUpdated = Date.now()
                    this.keys = (await getKeyResponse.json()).keys 
                } else {
                    throw new Error(
                        `Failed to load Keys: ${getKeyResponse.status}`
                    )
                }
            } else {
                throw new Error(`Failed to load openID config: ${res.status}`)
            }
        } catch (ex) {
            console.error(ex)
        }
    }

     findKey(keyId) {
        if (!this.keys) {
            return null
        }

        for (const key of this.keys) {
            if (key.kid === keyId) {
                if (!key.n || !key.e) {
                    // Return null for non-RSA keys
                    return null
                }

                const modulus = base64url.toBase64(key.n)
                const exponent = key.e

                return {
                    key: getPem(modulus, exponent),
                    endorsements: key.endorsements,
                } 
            }
        }

        return null
    }
}

























// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema-auth/src/jwtTokenExtractor.ts
/**
 * @module botbuilder
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */





class jwtTokenExtractor_JwtTokenExtractor {
    // Cache for OpenIdConnect configuration managers (one per metadata URL)
     static __initStatic() {this.openIdMetadataCache = new Map


()}

    // Token validation parameters for this instance
    

    // OpenIdMetadata for this instance
    

    constructor(
        tokenValidationParameters,
        metadataUrl,
        allowedSigningAlgorithms
    ) {
        this.tokenValidationParameters = { ...tokenValidationParameters }
        this.tokenValidationParameters.algorithms = allowedSigningAlgorithms
        this.openIdMetadata = jwtTokenExtractor_JwtTokenExtractor.getOrAddOpenIdMetadata(
            metadataUrl
        )
    }

     static getOrAddOpenIdMetadata(metadataUrl) {
        let metadata = jwtTokenExtractor_JwtTokenExtractor.openIdMetadataCache.get(
            metadataUrl
        )
        if (!metadata) {
            metadata = new OpenIdMetadata(metadataUrl)
            jwtTokenExtractor_JwtTokenExtractor.openIdMetadataCache.set(metadataUrl, metadata)
        }

        return metadata
    }

     async getIdentityFromAuthHeader(
        authorizationHeader,
        channelId
    ) {
        if (!authorizationHeader) {
            return null
        }

        const parts = authorizationHeader.split(' ')
        if (parts.length === 2) {
            return await this.getIdentity(parts[0], parts[1], channelId)
        }

        return null
    }

     async getIdentity(
        scheme,
        parameter,
        channelId
    ) {
        // No header in correct scheme or no token
        if (scheme !== 'Bearer' || !parameter) {
            return null
        }

        // Issuer isn't allowed? No need to check signature
        if (!this.hasAllowedIssuer(parameter)) {
            return null
        }

        try {
            return await this.validateToken(parameter, channelId)
        } catch (err) {
            // tslint:disable-next-line:no-console
            console.error('JwtTokenExtractor.getIdentity:err!', err)
            throw err
        }
    }

     hasAllowedIssuer(jwtToken) {
        const decoded = jsonwebtoken["decode"](jwtToken, { complete: true })
        const issuer = decoded.payload.iss

        if (Array.isArray(this.tokenValidationParameters.issuer)) {
            return this.tokenValidationParameters.issuer.indexOf(issuer) !== -1
        }

        if (typeof this.tokenValidationParameters.issuer === 'string') {
            return this.tokenValidationParameters.issuer === issuer
        }

        return false
    }

     async validateToken(
        jwtToken,
        channelId
    ) {
        const decodedToken = jsonwebtoken["decode"](jwtToken, { complete: true })

        // Update the signing tokens from the last refresh
        const keyId = decodedToken.header.kid
        const metadata = await this.openIdMetadata.getKey(keyId)
        if (!metadata) {
            throw new Error('Signing Key could not be retrieved.')
        }

        try {
            const decodedPayload = jsonwebtoken["verify"](
                jwtToken,
                metadata.key,
                this.tokenValidationParameters
            )

            // enforce endorsements in openIdMetadadata if there is any endorsements associated with the key
            const endorsements = metadata.endorsements

            if (Array.isArray(endorsements) && endorsements.length !== 0) {
                const isEndorsed = EndorsementsValidator.validate(
                    channelId,
                    endorsements
                )
                if (!isEndorsed) {
                    throw new Error(
                        `Could not validate endorsement for key: ${keyId} with endorsements: ${endorsements.join(
                            ','
                        )}`
                    )
                }
            }

            if (this.tokenValidationParameters.algorithms) {
                if (
                    this.tokenValidationParameters.algorithms.indexOf(
                        decodedToken.header.alg
                    ) === -1
                ) {
                    throw new Error(
                        `"Token signing algorithm '${decodedToken.header.alg}' not in allowed list`
                    )
                }
            }

            const claims = Object.keys(decodedPayload).reduce(
                (acc, key) => {
                    acc.push({ type: key, value: decodedPayload[key] })

                    return acc
                },
                [] 
            )

            return new ClaimsIdentity(claims, true)
        } catch (err) {
            // tslint:disable-next-line:no-console
            console.error(
                `Error finding key for token. Available keys: ${metadata.key}`
            )
            throw err
        }
    }
} jwtTokenExtractor_JwtTokenExtractor.__initStatic();

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema-auth/src/channelValidation.ts






let OpenIdMetadataEndpoint

/**
 * TO BOT FROM CHANNEL: Token validation parameters when connecting to a bot
 */
const ToBotFromChannelTokenValidationParameters = {
    issuer: [ToBotFromChannelTokenIssuer],
    audience: undefined, // Audience validation takes place manually in code.
    clockTolerance: 5 * 60,
    ignoreExpiration: false,
}

/**
 * Validate the incoming Auth Header as a token sent from the Bot Framework Service.
 * A token issued by the Bot Framework emulator will FAIL this check.
 * @param  {string} authHeader The raw HTTP header in the format: "Bearer [longString]"
 * @param  {ICredentialProvider} credentials The user defined set of valid credentials, such as the AppId.
 * @param  {string} serviceUrl The ServiceUrl Claim value that must match in the identity.
 * @returns {Promise<ClaimsIdentity>} A valid ClaimsIdentity.
 */
async function authenticateChannelTokenWithServiceUrl(
    authHeader,
    credentials,
    serviceUrl,
    channelId
) {
    const identity = await authenticateChannelToken(
        authHeader,
        credentials,
        channelId
    )

    const serviceUrlClaim = identity.getClaimValue(
        ServiceUrlClaim
    )
    if (serviceUrlClaim !== serviceUrl) {
        // Claim must match. Not Authorized.
        throw new Error('Unauthorized. ServiceUrl claim do not match.')
    }

    return identity
}

/**
 * Validate the incoming Auth Header as a token sent from the Bot Framework Service.
 * A token issued by the Bot Framework emulator will FAIL this check.
 * @param  {string} authHeader The raw HTTP header in the format: "Bearer [longString]"
 * @param  {ICredentialProvider} credentials The user defined set of valid credentials, such as the AppId.
 * @returns {Promise<ClaimsIdentity>} A valid ClaimsIdentity.
 */
async function authenticateChannelToken(
    authHeader,
    credentials,
    channelId
) {
    const tokenExtractor = new jwtTokenExtractor_JwtTokenExtractor(
        ToBotFromChannelTokenValidationParameters,
        OpenIdMetadataEndpoint
            ? OpenIdMetadataEndpoint
            : ToBotFromChannelOpenIdMetadataUrl,
        AllowedSigningAlgorithms
    )

    const identity = await tokenExtractor.getIdentityFromAuthHeader(
        authHeader,
        channelId
    )

    return await validateIdentity(identity, credentials)
}

/**
 * Validate the ClaimsIdentity to ensure it came from the channel service.
 * @param  {ClaimsIdentity} identity The identity to validate
 * @param  {ICredentialProvider} credentials The user defined set of valid credentials, such as the AppId.
 * @returns {Promise<ClaimsIdentity>} A valid ClaimsIdentity.
 */
async function validateIdentity(
    identity,
    credentials
) {
    if (!identity || !identity.isAuthenticated) {
        // The token is in some way invalid. Not Authorized.
        throw new Error('Unauthorized. Is not authenticated')
    }

    // Now check that the AppID in the claimset matches
    // what we're looking for. Note that in a multi-tenant bot, this value
    // comes from developer code that may be reaching out to a service, hence the
    // Async validation.

    // Look for the "aud" claim, but only if issued from the Bot Framework
    if (
        identity.getClaimValue(IssuerClaim) !==
        ToBotFromChannelTokenIssuer
    ) {
        // The relevant Audiance Claim MUST be present. Not Authorized.
        throw new Error('Unauthorized. Issuer Claim MUST be present.')
    }

    // The AppId from the claim in the token must match the AppId specified by the developer.
    // In this case, the token is destined for the app, so we find the app ID in the audience claim.
    const audClaim = identity.getClaimValue(
        AudienceClaim
    )
    if (!(await credentials.isValidAppId(audClaim || ''))) {
        // The AppId is not valid or not present. Not Authorized.
        throw new Error(
            `Unauthorized. Invalid AppId passed on token: ${audClaim}`
        )
    }

    return identity
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema-auth/src/emulatorValidation.ts
/**
 * @module botbuilder
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */






/**
 * Validates and Examines JWT tokens from the Bot Framework Emulator
 */

/**
 * TO BOT FROM EMULATOR: Token validation parameters when connecting to a channel.
 */
const ToBotFromEmulatorTokenValidationParameters = {
    issuer: [
        'https://sts.windows.net/d6d49420-f39b-4df7-a1dc-d59a935871db/', // Auth v3.1, 1.0 token
        'https://login.microsoftonline.com/d6d49420-f39b-4df7-a1dc-d59a935871db/v2.0', // Auth v3.1, 2.0 token
        'https://sts.windows.net/f8cdef31-a31e-4b4a-93e4-5f571e91255a/', // Auth v3.2, 1.0 token
        'https://login.microsoftonline.com/f8cdef31-a31e-4b4a-93e4-5f571e91255a/v2.0', // Auth v3.2, 2.0 token
        'https://sts.windows.net/72f988bf-86f1-41af-91ab-2d7cd011db47/', // ???
        'https://sts.windows.net/cab8a31a-1906-4287-a0d8-4eef66b95f6e/', // US Gov Auth, 1.0 token
        'https://login.microsoftonline.us/cab8a31a-1906-4287-a0d8-4eef66b95f6e/v2.0', // US Gov Auth, 2.0 token
    ],
    audience: undefined, // Audience validation takes place manually in code.
    clockTolerance: 5 * 60,
    ignoreExpiration: false,
}

/**
 * Determines if a given Auth header is from the Bot Framework Emulator
 * @param  {string} authHeader Bearer Token, in the "Bearer [Long String]" Format.
 * @returns {boolean} True, if the token was issued by the Emulator. Otherwise, false.
 */
function isTokenFromEmulator(authHeader) {
    // The Auth Header generally looks like this:
    // "Bearer eyJ0e[...Big Long String...]XAiO"
    if (!authHeader) {
        // No token. Can't be an emulator token.
        return false
    }

    const parts = authHeader.split(' ')
    if (parts.length !== 2) {
        // Emulator tokens MUST have exactly 2 parts. If we don't have 2 parts, it's not an emulator token
        return false
    }

    const authScheme = parts[0]
    const bearerToken = parts[1]

    // We now have an array that should be:
    // [0] = "Bearer"
    // [1] = "[Big Long String]"
    if (authScheme !== 'Bearer') {
        // The scheme from the emulator MUST be "Bearer"
        return false
    }

    // Parse the Big Long String into an actual token.
    const token = jsonwebtoken["decode"](bearerToken, { complete: true })
    if (!token) {
        return false
    }

    // Is there an Issuer?
    const issuer = token.payload.iss
    if (!issuer) {
        // No Issuer, means it's not from the Emulator.
        return false
    }

    // Is the token issues by a source we consider to be the emulator?
    if (
        ToBotFromEmulatorTokenValidationParameters.issuer &&
        ToBotFromEmulatorTokenValidationParameters.issuer.indexOf(issuer) === -1
    ) {
        // Not a Valid Issuer. This is NOT a Bot Framework Emulator Token.
        return false
    }

    // The Token is from the Bot Framework Emulator. Success!
    return true
}

/**
 * Validate the incoming Auth Header as a token sent from the Bot Framework Emulator.
 * A token issued by the Bot Framework will FAIL this check. Only Emulator tokens will pass.
 * @param  {string} authHeader The raw HTTP header in the format: "Bearer [longString]"
 * @param  {ICredentialProvider} credentials The user defined set of valid credentials, such as the AppId.
 * @returns {Promise<ClaimsIdentity>} A valid ClaimsIdentity.
 */
async function authenticateEmulatorToken(
    authHeader,
    credentials,
    channelId
) {
    try {
        const openIdMetadataUrl =
            ToBotFromEmulatorOpenIdMetadataUrl

        const tokenExtractor = new jwtTokenExtractor_JwtTokenExtractor(
            ToBotFromEmulatorTokenValidationParameters,
            openIdMetadataUrl,
            AllowedSigningAlgorithms
        )

        const identity = await tokenExtractor.getIdentityFromAuthHeader(
            authHeader,
            channelId
        )
        if (!identity) {
            // No valid identity. Not Authorized.
            throw new Error('Unauthorized. No valid identity.')
        }

        if (!identity.isAuthenticated) {
            // The token is in some way invalid. Not Authorized.
            throw new Error('Unauthorized. Is not authenticated')
        }

        // Now check that the AppID in the claimset matches
        // what we're looking for. Note that in a multi-tenant bot, this value
        // comes from developer code that may be reaching out to a service, hence the
        // Async validation.
        const versionClaim = identity.getClaimValue(
            VersionClaim
        )
        if (versionClaim === null) {
            throw new Error(
                'Unauthorized. "ver" claim is required on Emulator Tokens.'
            )
        }

        let appId = ''

        // The Emulator, depending on Version, sends the AppId via either the
        // appid claim (Version 1) or the Authorized Party claim (Version 2).
        if (!versionClaim || versionClaim === '1.0') {
            // either no Version or a version of "1.0" means we should look for
            // the claim in the "appid" claim.
            const appIdClaim = identity.getClaimValue(
                AppIdClaim
            )
            if (!appIdClaim) {
                // No claim around AppID. Not Authorized.
                throw new Error(
                    'Unauthorized. "appid" claim is required on Emulator Token version "1.0".'
                )
            }

            appId = appIdClaim
        } else if (versionClaim === '2.0') {
            // Emulator, "2.0" puts the AppId in the "azp" claim.
            const appZClaim = identity.getClaimValue(
                AuthorizedParty
            )
            if (!appZClaim) {
                // No claim around AppID. Not Authorized.
                throw new Error(
                    'Unauthorized. "azp" claim is required on Emulator Token version "2.0".'
                )
            }

            appId = appZClaim
        } else {
            // Unknown Version. Not Authorized.
            throw new Error(
                `Unauthorized. Unknown Emulator Token version "${versionClaim}".`
            )
        }

        if (!(await credentials.isValidAppId(appId))) {
            throw new Error(
                `Unauthorized. Invalid AppId passed on token: ${appId}`
            )
        }

        return identity
    } catch (ex) {
        console.error(ex)
        return null
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema-auth/src/jwtTokenValidation.ts







/**
 * Authenticates the request and sets the service url in the set of trusted urls.
 * @param  {Activity} activity The incoming Activity from the Bot Framework or the Emulator
 * @param  {string} authHeader The Bearer token included as part of the request
 * @param  {ICredentialProvider} credentials The set of valid credentials, such as the Bot Application ID
 * @returns {Promise<ClaimsIdentity>} Promise with ClaimsIdentity for the request.
 */
async function authenticateRequest(
    activity,
    authHeader,
    credentials
) {
    if (!authHeader || !authHeader.trim()) {
        const isAuthDisabled = await credentials.isAuthenticationDisabled()

        if (isAuthDisabled) {
            return new ClaimsIdentity([], true)
        }

        throw new Error('Unauthorized Access. Request is not authorized')
    }

    const claimsIdentity = await validateAuthHeader(
        authHeader,
        credentials,
        activity.channelId,
        activity.serviceUrl
    )

    httpAuthCredentials_HttpAuthAppCredentials.trustServiceUrl(activity.serviceUrl)

    return claimsIdentity
}

async function validateAuthHeader(
    authHeader,
    credentials,
    channelId,
    serviceUrl = ''
) {
    try {
        if (!authHeader.trim()) {
            throw new Error("'authHeader' required.")
        }

        const usingEmulator = isTokenFromEmulator(
            authHeader
        )

        if (usingEmulator) {
            return await authenticateEmulatorToken(
                authHeader,
                credentials,
                channelId
            )
        }

        if (serviceUrl.trim()) {
            return await authenticateChannelTokenWithServiceUrl(
                authHeader,
                credentials,
                serviceUrl,
                channelId
            )
        }

        return await authenticateChannelToken(
            authHeader,
            credentials,
            channelId
        )
    } catch (ex) {
        console.error(ex)
        return null
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema-auth/src/index.ts








// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter/src/util.ts
function shallowCopy(value) {
    if (Array.isArray(value)) {
        return value.slice(0) 
    }
    if (typeof value === 'object') {
        return { ...(value ) }
    }

    return value
}

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-botcommander/src/index.ts + 1 modules
var src = __webpack_require__(84);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-schema-teams/dist/index.js
var iopa_botadapter_schema_teams_dist = __webpack_require__(78);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter/src/context-helpers-teams.ts
















class context_helpers_teams_TeamsHelpers  {
    

    constructor(context) {
        this._context = context
    }

     getChannelId() {
        if (!this._context['bot.Capability'].activity) {
            throw new Error('Missing activity on context')
        }

        const channelData = this._context['bot.Capability']
            .activity.channelData 
        const channel = channelData ? channelData.channel : null
        return channel && channel.id ? channel.id : null
    }

     getChannelName() {
        if (!this._context['bot.Capability'].activity) {
            throw new Error('Missing activity on context')
        }

        const channelData = this._context['bot.Capability']
            .activity.channelData 
        const channel = channelData ? channelData.channel : null
        return channel && channel.name ? channel.name : undefined
    }

     getTeamId() {
        if (!this._context['bot.Capability'].activity) {
            throw new Error('Missing activity on context')
        }

        const channelData = this._context['bot.Capability'].activity
            .channelData 
        const team =
            channelData && channelData.team ? channelData.team : null
        const teamId = team && typeof team.id === 'string' ? team.id : null
        return teamId
    }

     notifyUser(outboundActivity) {
        if (!outboundActivity) {
            throw new Error('Missing activity parameter')
        }

        if (
            !outboundActivity.channelData ||
            typeof outboundActivity.channelData !== 'object'
        ) {
            outboundActivity.channelData = {}
        }

        const channelData = outboundActivity.channelData 
        channelData.notification = { alert: true } 
    }

    //
    // Teams Info
    //

     async getTeamDetails(teamId) {
        const t = teamId || this.getTeamId()
        if (!t) {
            throw new Error(
                'This method is only valid within the scope of a MS Teams Team.'
            )
        }

        return this.getTeamsConnectorClient().teamsFetchTeamDetails(t)
    }

     async getTeamChannels(teamId) {
        teamId = teamId || this.getTeamId()
        if (teamId) {
            throw new Error(
                'This method is only valid within the scope of a MS Teams Team.'
            )
        }

        const channelList = await this.getTeamsConnectorClient().teamsFetchChannelList(
            teamId
        )
        return channelList.conversations
    }

     async getMembers() {
        const teamId = this.getTeamId()
        if (teamId) {
            return this.getTeamMembers(teamId)
        }
        const { conversation } = this._context['bot.Capability'].activity
        const conversationId =
            conversation && conversation.id ? conversation.id : undefined
        return this.getMembersInternal(
            this.getConnectorClient(),
            conversationId
        )
    }

     async getTeamMembers(
        teamId
    ) {
        teamId = teamId || this.getTeamId()
        if (!teamId) {
            throw new Error(
                'This method is only valid within the scope of a MS Teams Team.'
            )
        }
        return this.getMembersInternal(this.getConnectorClient(), teamId)
    }

     async createConversation(
        teamsChannelId,
        message
    ) {
        if (!teamsChannelId) {
            throw new Error('Missing valid teamsChannelId argument')
        }
        if (!message) {
            throw new Error('Missing valid message argument')
        }
        const conversationParameters = {
            isGroup: true,
            channelData: {
                channel: {
                    id: teamsChannelId,
                } ,
            } ,
            activity: message,
        } 
        const { adapter } = this._context['bot.Capability']
        const conversationsApiClient = adapter.createConversationsApiClient(
            this._context['bot.Capability'].activity.serviceUrl
        )

        // This call does NOT send the outbound Activity is not being sent through the middleware stack.

        const conversationResourceResponse = await conversationsApiClient.conversationsCreateConversation(
            conversationParameters
        )
        const conversationReference = adapter.getConversationReference(
            this._context['bot.Capability'].activity
        ) 
        conversationReference.conversation.id = conversationResourceResponse.id
        return [conversationReference, conversationResourceResponse.activityId]
    }

     sendToGeneralChannel(
        message
    ) {
        const teamId = this.getTeamId()

        if (!teamId) {
            throw new Error(
                'The current Activity was not sent from a Teams Team.'
            )
        }

        return this.createConversation(teamId, message)
    }

     async getMembersInternal(
        connectorClient,
        conversationId
    ) {
        if (!conversationId) {
            throw new Error(
                'The getMembers operation needs a valid conversationId.'
            )
        }

        const teamMembers = await connectorClient.conversationsGetConversationMembers(
            conversationId
        )
        teamMembers.forEach((member) => {
            member.aadObjectId = (member ).objectId
        })

        return teamMembers 
    }

     getConnectorClient() {
        if (
            !this._context['bot.Capability'].adapter ||
            !(
                'createConversationsApiClient' in
                this._context['bot.Capability'].adapter
            )
        ) {
            throw new Error('This method requires a connector client.')
        }

        return this._context[
            'bot.Capability'
        ].adapter.createConversationsApiClient(
            this._context['bot.Capability'].activity.serviceUrl
        )
    }

     getTeamsConnectorClient() {
        const { credentials } = this._context['bot.Capability'].adapter

        const fetchProxy = async (url, init) => {
            await credentials.signRequest(url, init)
            return fetch(url, init)
        }

        const client = new iopa_botadapter_schema_teams_dist["TeamsApi"](
            {},
            this._context['bot.Capability'].activity.serviceUrl.replace(
                /\/+$/,
                ''
            ),
            fetchProxy
        )

        return client
    }
}

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter/src/context-helpers-token.ts
var context_helpers_token = __webpack_require__(206);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter/src/context-capability.ts
















const $$context = Symbol('urn:io:iopa:bot:response:context')

class context_capability_BotAdapterCapability
     {
    

    

    

    

    

    

    

    constructor(
        plaincontext,
        adapter,
        activity
    ) {
        this[$$context] = plaincontext 
        this.activity = activity
        this.adapter = adapter
        this.teams = new context_helpers_teams_TeamsHelpers(plaincontext )
        this.tokens = new context_helpers_token["a" /* TokenHelpers */](plaincontext )
        this.turnState = new Map()
        this.responded = false
    }

    /** Sends a single activity or message to the user */
     sendActivity(
        activityOrText,
        speak,
        inputHint
    ) {
        let a
        if (typeof activityOrText === 'string') {
            a = {
                text: activityOrText,
                inputHint:
                    (inputHint ) || dist["InputHints"].AcceptingInput,
            }
            if (speak) {
                a.speak = speak
            }
        } else {
            a = activityOrText
        }

        return this.sendActivities([a]).then((responses) =>
            responses && responses.length > 0 ? responses[0] : undefined
        )
    }

    /** Sends a set of activities to the user. An array of responses from the server will be returned  */
     sendActivities(
        activities
    ) {
        let sentNonTraceActivity = false
        const ref = this.adapter.getConversationReference(
            this.activity
        )
        const output = activities.map(
            (a) => {
                const o = this.adapter.applyConversationReference(
                    { ...a },
                    ref
                )
                if (!o.type) {
                    o.type = dist["ActivityTypes"].Message
                }
                if (o.type !== dist["ActivityTypes"].Trace) {
                    sentNonTraceActivity = true
                }

                return o
            }
        )

        return this.adapter.emit(
            'ContextSendActivities',
            this[$$context],
            { activities: output },
            () => {
                return this.adapter
                    .sendActivities(this[$$context], output)
                    .then((responses) => {
                        // Set responded flag
                        if (sentNonTraceActivity) {
                            this.responded = true
                        }

                        return responses
                    })
            }
        )
    }

    /** Deletes an existing activity */
     deleteActivity(
        idOrReference
    ) {
        let reference
        if (typeof idOrReference === 'string') {
            reference = this.adapter.getConversationReference(this.activity)
            reference.activityId = idOrReference
        } else {
            reference = idOrReference
        }

        return this.adapter.emit(
            'ContextDeleteActivity',
            this[$$context],
            { reference },
            () => this.adapter.deleteActivity(reference)
        )
    }

    /** Replaces an existing activity */
     updateActivity(activity) {
        const ref = this.adapter.getConversationReference(
            this.activity
        )
        const a = this.adapter.applyConversationReference(
            activity,
            ref
        )

        return this.adapter.emit(
            'ContextUpdateActivity',
            this[$$context],
            { activity },
            () => this.adapter.updateActivity(a)
        )
    }

    /** An asynchronous method that lists the members of the current conversation.  */
     async getConversationMembers() {
        if (!this.activity.serviceUrl) {
            throw new Error(
                `ActivityHelpers.getConversationMembers(): missing serviceUrl`
            )
        }
        if (!this.activity.conversation || !this.activity.conversation.id) {
            throw new Error(
                `ActivityHelpers.getConversationMembers(): missing conversation or conversation.id`
            )
        }
        const { serviceUrl } = this.activity
        const conversationId = this.activity.conversation.id
        const client = this.adapter.createConversationsApiClient(serviceUrl)

        return client.conversationsGetConversationMembers(conversationId)
    }

    getConversationReference() {
        return this.adapter.getConversationReference(this.activity)
    }

     copyTo( context) {
        // TODO COPY REFERENCES ETC.

        return context
    }
}

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-cards/src/index.ts + 2 modules
var iopa_botadapter_cards_src = __webpack_require__(33);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter/src/context-response-connector.ts

















const MIN_TYPING_DURATION = 2200
const MIN_POST_MESSAGE_DELAY = 1500
const MAX_POST_MESSAGE_DELAY = 4000
const DEFAULT_DELAY_FOR_CARD = 3000
const DELAY_WHEN_DISABLED = 40

const $$bodyState = Symbol('urn:io:iopa:bot:response:bodystate')
const context_response_connector_$$context = Symbol('urn:io:iopa:bot:response:context')

/** Convert plain IopaContext into a method-enhanced IopaBotAdapterContext */
function toIopaBotAdapterResponse(
    plainresponse,
    context
) {
    const response = plainresponse 
    response[context_response_connector_$$context] = context
    response['bot.Capability'] = context['bot.Capability']

    response.send = context_response_connector_ResponseHelpers.prototype.send
    response.sendAll = context_response_connector_ResponseHelpers.prototype.sendAll
    response.say = context_response_connector_ResponseHelpers.prototype.say
    response.card = context_response_connector_ResponseHelpers.prototype.card
    response.shouldEndSession = context_response_connector_ResponseHelpers.prototype.shouldEndSession
    response.showTypingIndicator = context_response_connector_ResponseHelpers.prototype.showTypingIndicator
    response.hideTypingIndicator = context_response_connector_ResponseHelpers.prototype.hideTypingIndicator
    response.status = context_response_connector_ResponseHelpers.prototype.status
    response.fail = context_response_connector_ResponseHelpers.prototype.fail
    response.status = context_response_connector_ResponseHelpers.prototype.status
    response.isAwaitingMultiChoiceResponse =
        context_response_connector_ResponseHelpers.prototype.isAwaitingMultiChoiceResponse

    response['bot.ShouldEndSession'] = false
    response['bot.ResponseHandled'] = false
    response['bot.IsDelayDisabled'] = false
    response['iopa.StatusCode'] = 200

    return response
}

class context_response_connector_ResponseHelpers  {
    say( text) {
        if (this[$$bodyState]) {
            if (this[$$bodyState].text) {
                this[$$bodyState].text = `${this[$$bodyState].text}\n${text}`
            } else {
                this[$$bodyState].text = text
            }
        } else {
            this[$$bodyState] = { text }
        }

        this['bot.ResponseHandled'] = true

        return this
    }

    card( card) {
        if (
            'text' in card ||
            'attachments' in card ||
            'image' in card ||
            'title' in card
        ) {
            this.say(card.text)

            if (card.attachments) {
                this[$$bodyState].attachments = card.attachments
            }

            if (card.image) {
                this[$$bodyState].image = card.image
            }

            if (card.title) {
                this[$$bodyState].attachments =
                    this[$$bodyState].attachments || []
                this[$$bodyState].attachments[0] =
                    this[$$bodyState].attachments[0] || {}
                this[$$bodyState].attachments[0].text = card.title
            }
        } else {
            this[$$bodyState] = this[$$bodyState] || {}

            this[$$bodyState].attachments = this[$$bodyState].attachments || []

            if (card.type === 'card' && 'props' in card) {
                this[$$bodyState].attachments.push(
                    iopa_botadapter_cards_src["a" /* CardFactory */].reactiveCard(card)
                )
            } else {
                this[$$bodyState].attachments.push(card)
            }
        }

        return this
    }

    /** Send response back to bot */
    async send( body) {
        if (body) {
            if (typeof body === 'string') {
                this.say(body)
            } else {
                this.card(body)
            }
        }

        let message
        let card

        if (this['iopa.StatusCode'] !== 200) {
            // TO DO:: FORMAT ERROR
            message = `Unfortunately an error has occured:\n  ${this['iopa.StatusCode']} ${this[$$bodyState].text}`
        } else {
            message = this[$$bodyState].text

            if (this[$$bodyState].attachments) {
                card = this[$$bodyState].attachments[0]
            }
        }

        this[$$bodyState] = undefined

        const hasMessage = message && message.length > 0

        if (!hasMessage && !card) {
            return
        }

        if (hasMessage && !card) {
            // console.log(message)
            await this['bot.Capability'].sendActivity(
                iopa_botadapter_cards_src["b" /* MessageFactory */].text(message)
            )
        } else {
            // console.log('card')
            await this['bot.Capability'].sendActivity(
                iopa_botadapter_cards_src["b" /* MessageFactory */].attachment(card, message)
            )
        }
    }

    /** Helper method to indicate this response should end the dialog */
    shouldEndSession(
        
        flag
    ) {
        this['bot.ShouldEndSession'] = flag
        return this
    }

    /** Helper method to set the status of the response */
    status(
        
        statuscode
    ) {
        this['iopa.StatusCode'] = statuscode
        return this
    }

    /** Send a text string or card attachments, looping with delay if multiple provided */
    sendAll(
        
        messages,
        typingDelay
    ) {
        return asyncForEach(messages, async (message) => {
            const typingDuration = typingDelay || MIN_TYPING_DURATION
            let postMessageDelay

            if (typeof message === 'string') {
                postMessageDelay = postMessageDelayForText(message)
                this.say(message)
            } else {
                postMessageDelay = postMessageDelayForCard(message)
                this.card(message)
            }
            await this.showTypingIndicator()
            await delay(
                this['bot.IsDelayDisabled']
                    ? DELAY_WHEN_DISABLED
                    : typingDuration
            )
            await this.send()
            await this.hideTypingIndicator()
            await delay(
                this['bot.IsDelayDisabled']
                    ? DELAY_WHEN_DISABLED
                    : postMessageDelay
            )
        })
    }

    fail(
        
        error,
        message,
        inChannel
    ) {
        this['iopa.StatusCode'] = 200

        this[$$bodyState] = {
            text: `${message}: ${error}`,
        }

        return this
    }

    async showTypingIndicator() {
        const context = this[context_response_connector_$$context]

        // Sending the Activity directly via the Adapter avoids other middleware and avoids setting the
        // responded flag. However this also requires tha tthe conversation reference details are explicitly added.

        let typingActivity = {
            type: dist["ActivityTypes"].Typing,
            relatesTo: context['bot.Capability'].activity.relatesTo,
        }

        const conversationReference = context[
            'bot.Capability'
        ].adapter.getConversationReference(context['bot.Capability'].activity)

        typingActivity = context[
            'bot.Capability'
        ].adapter.applyConversationReference(
            typingActivity,
            conversationReference
        )

        await context['bot.Capability'].adapter.sendActivities(context, [
            typingActivity,
        ])

        // TO DO:   Keep sending every 2-5 seconds until no longer needed;  for now
        // just a single indicator is sent once
    }

    async hideTypingIndicator() {
        return Promise.resolve()

        // TO DO:  Stop sending every 2 seconds
        // for now just a single indicator is sent, so hiding is a noop
    }

    isAwaitingMultiChoiceResponse() {
        return (
            (this[context_response_connector_$$context] )['bot.Session'][
                'bot.isMultiChoicePrompt'
            ] === true
        )
    }
}

//
// private methods
//

function delay(interval) {
    return new Promise((resolve, _reject) => {
        setTimeout(resolve, interval)
    })
}

function postMessageDelayForText(text) {
    const avgWordsPerMinute = 90
    const avgCharsPerWord = 5
    const wordCount = text.length / avgCharsPerWord
    const delay = (wordCount / avgWordsPerMinute) * 60 * 100
    const buffer = 900
    const final = clamp(
        MIN_POST_MESSAGE_DELAY,
        delay + buffer,
        MAX_POST_MESSAGE_DELAY
    )
    return final
}

function postMessageDelayForCard(card) {
    if (card.typingDelay !== undefined) {
        return card.postMessageDelay
    }
    if (card.text) {
        return postMessageDelayForText(card.text)
    }
    return DEFAULT_DELAY_FOR_CARD
}

function clamp(min, value, max) {
    return Math.min(max, Math.max(min, value))
}

async function asyncForEach(array, callback) {
    for (let index = 0; index < array.length; index++) {
        // eslint-disable-next-line no-await-in-loop
        await callback(array[index], index, array)
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter/src/context.ts








/** Convert plain IopaContext into a method-enhanced IopaBotAdapterContext */
function toIopaBotAdapterContext(
    plaincontext,
    adapter,
    activity
) {
    const context = plaincontext 
    context['bot.Capability'] = new context_capability_BotAdapterCapability(
        plaincontext,
        adapter,
        activity
    )

    context['iopa.Labels'].set(
        'user',
        activity.from.aadObjectId || activity.from.id
    )

    const reading = context 

    const { teams } = context['bot.Capability']

    reading['bot.ActivityId'] = activity.id
    reading[
        'bot.ActivityType'
    ] = (((activity.type ) ).charAt(0).toUpperCase() +
        ((activity.type ) ).slice(1)) 
    reading['bot.Channel'] = {
        id: teams.getChannelId(),
        name: teams.getChannelName(),
    }
    reading['bot.Conversation'] = adapter.getConversationReference(activity)
    reading['bot.From'] = {
        id: activity.from.aadObjectId,
        localid: activity.from.id,
        name: activity.from.name,
    }
    reading['bot.Intent'] = src["b" /* URN_BOTINTENT_LITERAL */]
    reading['bot.Provider'] = activity.channelId
    reading['bot.Recipient'] = {
        id: activity.recipient.aadObjectId,
        localid: activity.recipient.id,
        name: activity.recipient.name,
    }
    reading['bot.ServiceUrl'] = activity.serviceUrl
    context['bot.Source'] = URN_BOTADAPTER
    reading['bot.Session'] = undefined
    reading['bot.Team'] = { id: teams.getTeamId() }
    if (activity.text) {
        reading['bot.Text'] = activity.text
    }
    reading['bot.Timestamp'] = Date.now()

    context.response = toIopaBotAdapterResponse(plaincontext.response, context)
    return context
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter/src/adapter-core.ts
/* eslint-disable no-async-promise-executor */
/* eslint-disable no-case-declarations */
/* eslint-disable no-await-in-loop */















const retry = __webpack_require__(114)

// This key is exported internally so that the TeamsActivityHandler will not overwrite any already set InvokeResponses.
const INVOKE_RESPONSE_KEY = 'urn:io.iopa.invokeResponse'
const URN_BOTADAPTER = 'urn:io.iopa:botadapater'
const URN_BOTINTENT_LITERAL = 'urn:io.iopa.bot:intent:literal'

/** The Iopa BotFrameworkAdapter */
class adapter_core_AdapterCore  {
    

    

    

    constructor(app) {
        this._app = app
        ;(app ).botadapter = (this ) 

        // Relocate the tenantId field used by MS Teams to a new location (from channelData to conversation)
        // This will only occur on activities from teams that include tenant info in channelData but NOT in conversation,
        // thus should be future friendly.  However, once the the transition is complete. we can remove this.
        app.use(
            async (
                context,
                next
            ) => {
                if (!context['bot.Capability']) {
                    return next()
                }

                const { activity } = context['bot.Capability']

                if (
                    activity.channelId === 'msteams' &&
                    activity &&
                    activity.conversation &&
                    !activity.conversation.tenantId &&
                    activity.channelData &&
                    activity.channelData.tenant
                ) {
                    activity.conversation.tenantId =
                        activity.channelData.tenant.id
                }

                return next()
            },
            'iopa-botadapter.AdapterCore'
        )

        const appId = "94a9d0b9-0fa9-4f14-b2e3-f31464fb763a"
        const appPassword = "RJv0Zxs7/g7B=h]TP-qYWREGV9Zf@BN-"

        this.credentials = new httpAuthCredentials_HttpAuthAppCredentials(
            appId,
            appPassword || '',
            undefined
        )

        this.credentialsProvider = new SimpleCredentialProvider(
            this.credentials.appId,
            this.credentials.appPassword
        )
    }

    /** An asynchronous method that creates a turn context and runs the middleware pipeline
     * for an incoming activity from HTTP wire */
     async invokeActivity(
        context,
        next
    ) {
        if (context['iopa.Protocol'] === URN_BOTADAPTER) {
            // skip validation and parsing for synthetic contexts created by this framework
            await next()
            return
        }

        let body
        let status
        let processError
        try {
            // Parse body of request
            status = 400
            const activity = await _parseRequest(context)

            if (!activity) {
                await next()
                return
            }

            // Authenticate the incoming request
            status = 401
            const authHeader = context['iopa.Headers'].get(
                'authorization'
            )
            await this.authenticateRequest(activity, authHeader)

            // Expand Context with Iopa Turn Context from
            status = 500
            const contextExpanded = toIopaBotAdapterContext(
                context,
                (this ) ,
                activity
            )

            contextExpanded['bot.Source'] = URN_BOTADAPTER

            console.log(
                `[BotAdapter] Authorization Complete ${context.get(
                    'server.TimeElapsed'
                )}ms`
            )

            if (
                contextExpanded['bot.Capability'].activity.type ===
                dist["ActivityTypes"].Message
            ) {
                // await contextExpanded.response.showTypingIndicator()
            }

            // Main processing of received activity
            try {
                await next()
            } catch (err) {
                if (this.onTurnError) {
                    await this.onTurnError(contextExpanded, err)
                } else {
                    throw err
                }
            }

            // Retrieve cached invoke response
            if (activity.type === dist["ActivityTypes"].Invoke) {
                const invokeResponse = contextExpanded[
                    'bot.Capability'
                ].turnState.get(INVOKE_RESPONSE_KEY)
                if (invokeResponse && invokeResponse.value) {
                    const { value } = invokeResponse
                    status = value.status
                    body = value.body
                } else {
                    status = 501
                }
            } else {
                status = 200
            }
        } catch (err) {
            // Catch the error to try and throw the stacktrace out of processActivity()
            processError = err
            body = err.statusText || err.message || err.toString()
        }

        // Return status
        context.response['iopa.StatusCode'] = status
        if (body) {
            context.response.end(body)
        } else {
            context.response.end()
        }

        // Check for an error
        if (status >= 400) {
            if (processError && (processError ).stack) {
                context.error(processError)
            } else {
                try {
                    throw new Error(`AdapterCore.invoke(): ${status} ERROR`)
                } catch (ex) {
                    context.error(processError)
                }
            }
        }
    }

    /** An asynchronous method that sends a set of outgoing activities to a channel server. */
     async sendActivities(
        context,
        activities
    ) {
        const responses = []
        for (let i = 0; i < activities.length; i++) {
            const activity = activities[i]
            switch (activity.type ) {
                case 'delay':
                    await adapter_core_delay(
                        typeof activity.value === 'number'
                            ? activity.value
                            : 1000
                    )
                    responses.push({} )
                    break
                case 'invokeResponse':
                    // Cache response to context object. This will be retrieved when turn completes.
                    context['bot.Capability'].turnState.set(
                        INVOKE_RESPONSE_KEY,
                        activity
                    )
                    responses.push({} )
                    break
                default:
                    if (!activity.serviceUrl) {
                        break
                        throw new Error(
                            `AdapterCore.sendActivities(): missing serviceUrl.`
                        )
                    }
                    if (!activity.conversation || !activity.conversation.id) {
                        throw new Error(
                            `AdapterCore.sendActivities(): missing conversation id.`
                        )
                    }
                    const client = this.createConversationsApiClient(
                        activity.serviceUrl
                    )
                    if (
                        activity.type === dist["ActivityTypes"].Trace &&
                        activity.channelId !== 'emulator'
                    ) {
                        // Just eat activity
                        responses.push({} )
                    } else if (activity.replyToId) {
                        responses.push(
                            (await client.conversationsReplyToActivity(
                                activity.conversation.id,
                                activity.replyToId,
                                activity 
                            )) 
                        )
                    } else {
                        responses.push(
                            (await client.conversationsSendToConversation(
                                activity.conversation.id,
                                activity 
                            )) 
                        )
                    }
                    break
            }
        }
        return responses
    }

    /** An asynchronous method that replaces a previous activity with an updated version. */
     async updateActivity(activity) {
        if (!activity.serviceUrl) {
            throw new Error(`AdapterCore.updateActivity(): missing serviceUrl`)
        }
        if (!activity.conversation || !activity.conversation.id) {
            throw new Error(
                `AdapterCore.updateActivity(): missing conversation or conversation.id`
            )
        }
        if (!activity.id) {
            throw new Error(`AdapterCore.updateActivity(): missing activity.id`)
        }
        const client = this.createConversationsApiClient(activity.serviceUrl)
        await client.conversationsUpdateActivity(
            activity.conversation.id,
            activity.id,
            activity 
        )
    }

    /** An asynchronous method that deletes an existing activity.  */
     async deleteActivity(
        reference
    ) {
        if (!reference.serviceUrl) {
            throw new Error(`AdapterCore.deleteActivity(): missing serviceUrl`)
        }
        if (!reference.conversation || !reference.conversation.id) {
            throw new Error(
                `AdapterCore.deleteActivity(): missing conversation or conversation.id`
            )
        }
        if (!reference.activityId) {
            throw new Error(`AdapterCore.deleteActivity(): missing activityId`)
        }
        const client = this.createConversationsApiClient(reference.serviceUrl)
        await client.conversationsDeleteActivity(
            reference.conversation.id,
            reference.activityId
        )
    }

    /** Creates a connector client.  Used by Teams Extensions in this package, not external */
     createConversationsApiClient(serviceUrl) {
        const fetchProxy = async (url, init) => {
            if (init && init.body && init.body instanceof URLSearchParams) {
                init.headers.set(
                    'Content-Type',
                    'application/x-www-form-urlencoded; charset=UTF-8'
                )
            }

            try {
                await this.credentials.signRequest(url, init)

                const result = await retry(
                    async (bail) => {
                        const result = await fetch(url, init)

                        if (result.status === 403) {
                            bail(new Error('Unauthorized'))
                        }

                        // override json in case of empty successful (202) responses
                        if (result.status === 202) {
                            result.json = async () => ({})
                        }

                        return result
                    },
                    {
                        retries: 3,
                        minTimeout: 2000,
                    }
                )

                return result
            } catch (ex) {
                // rethrow for stack trace upon timeout
                try {
                    throw ex
                } catch (ex) {
                    console.log(`Fetch Error getting ${url}`)
                    console.error(ex)
                    return {
                        status: 500,
                    }
                }
            }
        }

        const client = new dist["ConversationsApi"](
            {},
            serviceUrl.replace(/\/+$/, ''),
            fetchProxy
        )

        return client
    }

    /** Allows for the overriding of authentication in unit tests. */
     async authenticateRequest(
        activity,
        authHeader
    ) {
        const claims = await jwtTokenValidation_namespaceObject.authenticateRequest(
            activity ,
            authHeader,
            this.credentialsProvider
        )
        if (!claims.isAuthenticated) {
            throw new Error('Unauthorized Access. Request is not authorized')
        }
    }

    /**  Creates a turn context */
     createContext(activity) {
        const plaincontext = this._app.createContext(activity.serviceUrl, {
            withResponse: true,
            protocol: URN_BOTADAPTER,
        })

        const context = toIopaBotAdapterContext(
            plaincontext,
            (this ) ,
            activity
        )

        return context
    }

    




    /** Gets/sets a error handler that will be called anytime an uncaught exception is raised during a turn */
     get onTurnError()


 {
        return this.turnError
    }

     set onTurnError(
        value
    ) {
        this.turnError = value
    }
}

/** Handles incoming webhooks from the botframework */
function _parseRequest(context) {
    return new Promise(
        async (resolve, reject) => {
            const activity = await context['iopa.Body']
            try {
                if (typeof activity !== 'object') {
                    throw new Error(
                        `AdapterCore._parseRequest(): invalid request body.`
                    )
                }
                if (typeof activity.type !== 'string') {
                    throw new Error(
                        `AdapterCore._parseRequest(): missing activity type.`
                    )
                }
                if (typeof activity.timestamp === 'string') {
                    activity.timestamp = new Date(activity.timestamp)
                }
                if (typeof activity.localTimestamp === 'string') {
                    activity.localTimestamp = new Date(activity.localTimestamp)
                }
                if (typeof activity.expiration === 'string') {
                    activity.expiration = new Date(activity.expiration)
                }
                resolve(activity)
            } catch (err) {
                console.error(err)
                resolve(null)
            }
        }
    )
}

function adapter_core_delay(/** timeout in ms */ timeout) {
    return new Promise((resolve) => {
        setTimeout(resolve, timeout)
    })
}

function timeout(promise, ms) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new Error('timeout'))
        }, ms)
        promise.then(resolve, reject)
    })
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter/src/adapter-events.ts














































class adapter_events_AdapterWithEvents extends adapter_core_AdapterCore  {
      __init() {this.handlers = {}}

     constructor(app) {
        super(app);adapter_events_AdapterWithEvents.prototype.__init.call(this);adapter_events_AdapterWithEvents.prototype.__init2.call(this);
        app.use(this.invokeEvents, 'iopa-botadapter.AdapterWithEvents')
    }

    //
    // MASTER INVOKE HANDLER
    //

     __init2() {this.invokeEvents = async (
        context,
        next
    ) => {
        if (context['bot.Source'] !== URN_BOTADAPTER) {
            return next()
        }

        const { activity } = context['bot.Capability']

        switch (activity.type) {
            case dist["ActivityTypes"].Invoke:
                const invokeResponse = await this.invokeTeamsInvokeActivity(
                    context
                )
                // If onInvokeActivity has already sent an InvokeResponse, do not send another one.
                if (
                    invokeResponse &&
                    !context['bot.Capability'].turnState.get(
                        INVOKE_RESPONSE_KEY
                    )
                ) {
                    await context['bot.Capability'].sendActivity({
                        value: invokeResponse,
                        type: ('invokeResponse' ) ,
                    })
                }
                break

            default:
                await this.emit('Turn', context, async () => {
                    switch (context['bot.Capability'].activity.type) {
                        case dist["ActivityTypes"].Message:
                            await this.invokeMessageActivity(context)
                            break
                        case dist["ActivityTypes"].ConversationUpdate:
                            await this.invokeConversationUpdateActivity(context)
                            break
                        case dist["ActivityTypes"].MessageReaction:
                            await this.invokeMessageReactionActivity(context)
                            break
                        case dist["ActivityTypes"].Event:
                            await this.invokeEventActivity(context)
                            break
                        default:
                            await this.invokeUnrecognizedActivity(context)
                            break
                    }
                })
                break
        }

        return next()
    }}

    //
    // INVOKE SUBTYPE HANDLERS
    //

     async invokeMessageActivity(
        context
    ) {
        const { activity, adapter } = context['bot.Capability']

        const mentions = adapter.getMentions(activity)

        if (mentions.length) {
            mentions.forEach((mention, i) => {
                activity.text = activity.text
                    .replace(
                        mention.text,
                        mention.mentioned.id === activity.recipient.id
                            ? ''
                            : `@${mention.mentioned.id}`
                    )
                    .trim()
            })
        }

        context['bot.Text'] = activity.text // overwrite with updated mentions

        if (
            activity.channelId === 'msteams' &&
            activity &&
            activity.value &&
            !activity.textFormat &&
            !activity.attachments
        ) {
            await this.emit(
                'ActionInvoke',
                context,
                activity.value,
                this.defaultNextEvent(context)
            )
        } else {
            await this.emit('Message', context, this.defaultNextEvent(context))
        }
    }

     async invokeConversationUpdateActivity(
        context
    ) {
        const { activity } = context['bot.Capability']
        await this.emit('ConversationUpdate', context, async () => {
            const channelData = activity.channelData 

            if (!channelData || !channelData.eventType) {
                if (activity.membersAdded && activity.membersAdded.length > 0) {
                    await this.emit(
                        'MembersAdded',
                        context,
                        this.defaultNextEvent(context)
                    )
                } else if (
                    activity.membersRemoved &&
                    activity.membersRemoved.length > 0
                ) {
                    await this.emit(
                        'MembersRemoved',
                        context,
                        this.defaultNextEvent(context)
                    )
                } else {
                    await this.defaultNextEvent(context)()
                }
            } else {
                switch (channelData.eventType) {
                    case 'teamMemberAdded':
                        await this.invokeTeamsMembersAdded(context)
                        return
                    case 'teamMemberRemoved':
                        await this.invokeTeamsMembersRemoved(context)
                        return
                    case 'channelCreated':
                        await this.invokeTeamsChannelCreated(context)
                        return
                    case 'channelDeleted':
                        await this.invokeTeamsChannelDeleted(context)
                        return
                    case 'channelRenamed':
                        await this.invokeTeamsChannelRenamed(context)
                        return
                    case 'teamRenamed':
                        await this.invokeTeamsTeamRenamed(context)
                        return
                    default:
                        if (
                            activity.membersAdded &&
                            activity.membersAdded.length > 0
                        ) {
                            await this.emit(
                                'MembersAdded',
                                context,
                                this.defaultNextEvent(context)
                            )
                        } else if (
                            activity.membersRemoved &&
                            activity.membersRemoved.length > 0
                        ) {
                            await this.emit(
                                'MembersRemoved',
                                context,
                                this.defaultNextEvent(context)
                            )
                        } else {
                            await this.defaultNextEvent(context)()
                        }
                }
            }
        })
    }

     async invokeTeamsMembersAdded(
        context
    ) {
        if (
            'TeamsMembersAdded' in this.handlers &&
            this.handlers.TeamsMembersAdded.length > 0
        ) {
            await this.emit(
                'TeamsMembersAdded',
                context,
                this.defaultNextEvent(context)
            )
        } else {
            await this.emit(
                'MembersAdded',
                context,
                this.defaultNextEvent(context)
            )
        }
    }

     async invokeTeamsMembersRemoved(
        context
    ) {
        if (
            'TeamsMembersRemoved' in this.handlers &&
            this.handlers.TeamsMembersRemoved.length > 0
        ) {
            await this.emit(
                'TeamsMembersRemoved',
                context,
                this.defaultNextEvent(context)
            )
        } else {
            await this.emit(
                'MembersRemoved',
                context,
                this.defaultNextEvent(context)
            )
        }
    }

     async invokeTeamsChannelCreated(context) {
        await this.emit(
            'TeamsChannelCreated',
            context,
            this.defaultNextEvent(context)
        )
    }

     async invokeTeamsChannelDeleted(context) {
        await this.emit(
            'TeamsChannelDeleted',
            context,
            this.defaultNextEvent(context)
        )
    }

     async invokeTeamsChannelRenamed(context) {
        await this.emit(
            'TeamsChannelRenamed',
            context,
            this.defaultNextEvent(context)
        )
    }

     async invokeTeamsTeamRenamed(context) {
        await this.emit(
            'TeamsTeamRenamed',
            context,
            this.defaultNextEvent(context)
        )
    }

     async invokeMessageReactionActivity(
        context
    ) {
        const { activity } = context['bot.Capability']
        await this.emit('MessageReaction', context, async () => {
            if (activity.reactionsAdded || activity.reactionsRemoved) {
                if (
                    activity.reactionsAdded &&
                    activity.reactionsAdded.length > 0
                ) {
                    await this.invokeReactionsAddedActivity(
                        activity.reactionsAdded,
                        context
                    )
                } else if (
                    activity.reactionsRemoved &&
                    activity.reactionsRemoved.length > 0
                ) {
                    await this.invokeReactionsRemovedActivity(
                        activity.reactionsRemoved,
                        context
                    )
                }
            } else {
                await this.defaultNextEvent(context)()
            }
        })
    }

     async invokeEventActivity(
        context
    ) {
        const { activity } = context['bot.Capability']
        await this.emit('Event', context, async () => {
            if (activity.name === 'tokens/response') {
                await this.emit(
                    'TokenResponseEvent',
                    context,
                    this.defaultNextEvent(context)
                )
            } else {
                await this.defaultNextEvent(context)()
            }
        })
    }

     async invokeUnrecognizedActivity(
        context
    ) {
        await this.emit(
            'UnrecognizedActivityType',
            context,
            this.defaultNextEvent(context)
        )
    }

     async invokeReactionsAddedActivity(
        reactionsAdded,
        context
    ) {
        await this.emit(
            'ReactionsAdded',
            context,
            this.defaultNextEvent(context)
        )
    }

     async invokeReactionsRemovedActivity(
        reactionsRemoved,
        context
    ) {
        await this.emit(
            'ReactionsRemoved',
            context,
            this.defaultNextEvent(context)
        )
    }

    //
    // INTERNAL EVENT INFRASTRUCTURE
    //

     defaultNextEvent(
        context
    ) {
        const runDialogs = async () => {
            if (!context['bot.Capability'].responded) {
                await this.emit('Dialog', context, async () => {
                    // noop
                })
            }
        }
        return runDialogs
    }

     on(type, handler) {
        if (!this.handlers[type]) {
            this.handlers[type] = [handler]
        } else {
            this.handlers[type].push(handler)
        }
        return this
    }

    














    async emit(
        type,
        context,
        args,
        onNext
    ) {
        if (
            (type ) !== 'Dialog' &&
            (type ) !== 'ContextSendActivities'
        ) {
            context['bot.ActivityType'] = type
        }

        if (typeof args === 'function') {
            onNext = args 
            args = null
        }

        let returnValue = null

        async function runHandler(index) {
            if (index < handlers.length) {
                const val = args
                    ? await (handlers[index] )(
                          context,
                          args,
                          () => runHandler(index + 1)
                      )
                    : await (handlers[index] )(
                          context,
                          () => runHandler(index + 1)
                      )

                // if a value is returned, and we have not yet set the return value,
                // capture it.  This is used to allow InvokeResponses to be returned.
                if (typeof val !== 'undefined' && returnValue === null) {
                    returnValue = val
                }
            } else if (onNext) {
                const val = await onNext()
                if (typeof val !== 'undefined') {
                    returnValue = val
                }
            }
        }

        const handlers = this.handlers[type] || []
        await runHandler(0)

        return returnValue
    }

    //
    // EVENT REGISTRATION PUBLIC METHODS
    //

     onTurn(handler) {
        return this.on('Turn', handler)
    }

     onMessage(handler) {
        return this.on('Message', handler)
    }

    /** Receives invoke activities where context["bot.Capability"].activity.name is empty */
     onActionInvoke(
        handler




    ) {
        return this.on(
            'ActionInvoke',
            async (context, value, next) => {
                await handler(context, value, next)
            }
        )
    }

     onConversationUpdate(handler) {
        return this.on('ConversationUpdate', handler)
    }

     onMembersAdded(handler) {
        return this.on('MembersAdded', handler)
    }

     onMembersRemoved(handler) {
        return this.on('MembersRemoved', handler)
    }

     onMessageReaction(handler) {
        return this.on('MessageReaction', handler)
    }

     onReactionsAdded(handler) {
        return this.on('ReactionsAdded', handler)
    }

     onReactionsRemoved(handler) {
        return this.on('ReactionsRemoved', handler)
    }

     onEvent(handler) {
        return this.on('Event', handler)
    }

     onTokenResponseEvent(handler) {
        return this.on('TokenResponseEvent', handler)
    }

     onUnrecognizedActivityType(handler) {
        return this.on('UnrecognizedActivityType', handler)
    }

     onDialog(handler) {
        return this.on('Dialog', handler)
    }

     onTeamsMembersAddedEvent(
        handler





    ) {
        return this.on(
            'TeamsMembersAdded',
            async (context, next) => {
                const teamsChannelData = context['bot.Capability'].activity
                    .channelData 
                await handler(
                    context,
                    context['bot.Capability'].activity.membersAdded,
                    teamsChannelData.team,
                    next
                )
            }
        )
    }

     onTeamsMembersRemovedEvent(
        handler





    ) {
        return this.on(
            'TeamsMembersRemoved',
            async (context, next) => {
                const teamsChannelData = context['bot.Capability'].activity
                    .channelData 
                await handler(
                    context,
                    context['bot.Capability'].activity.membersRemoved,
                    teamsChannelData.team,
                    next
                )
            }
        )
    }

     onTeamsChannelCreatedEvent(
        handler





    ) {
        return this.on(
            'TeamsChannelCreated',
            async (context, next) => {
                const teamsChannelData = context['bot.Capability'].activity
                    .channelData 
                await handler(
                    context,
                    teamsChannelData.channel,
                    teamsChannelData.team,
                    next
                )
            }
        )
    }

     onTeamsChannelDeletedEvent(
        handler





    ) {
        return this.on(
            'TeamsChannelDeleted',
            async (context, next) => {
                const teamsChannelData = context['bot.Capability'].activity
                    .channelData 
                await handler(
                    context,
                    teamsChannelData.channel,
                    teamsChannelData.team,
                    next
                )
            }
        )
    }

     onTeamsChannelRenamedEvent(
        handler





    ) {
        return this.on(
            'TeamsChannelRenamed',
            async (context, next) => {
                const teamsChannelData = context['bot.Capability'].activity
                    .channelData 
                await handler(
                    context,
                    teamsChannelData.channel,
                    teamsChannelData.team,
                    next
                )
            }
        )
    }

     onTeamsTeamRenamedEvent(
        handler




    ) {
        return this.on(
            'TeamsTeamRenamed',
            async (context, next) => {
                const teamsChannelData = context['bot.Capability'].activity
                    .channelData 
                await handler(context, teamsChannelData.team, next)
            }
        )
    }

     async invokeTeamsInvokeActivity(
        context
    ) {
        try {
            if (
                !context['bot.Capability'].activity.name &&
                context['bot.Capability'].activity.channelId === 'msteams'
            ) {
                return await this.emit('TeamsCardActionInvoke', context)
            }
            switch (context['bot.Capability'].activity.name) {
                case 'signin/verifyState':
                    await this.emit('TeamsSigninVerifyState', context)
                    return this.createInvokeResponse()

                case 'fileConsent/invoke':
                    return this.createInvokeResponse(
                        await this.emit('TeamsFileConsent', context)
                    )

                case 'actionableMessage/executeAction':
                    await this.emit('TeamsO365ConnectorCardAction', context)
                    return this.createInvokeResponse()

                case 'composeExtension/queryLink':
                    return this.createInvokeResponse(
                        this.emit('TeamsAppBasedLinkQuery', context)
                    )

                case 'composeExtension/query':
                    return this.createInvokeResponse(
                        this.emit('TeamsMessagingExtensionQuery', context)
                    )

                case 'composeExtension/selectItem':
                    return this.createInvokeResponse(
                        this.emit('TeamsMessagingExtensionSelectItem', context)
                    )

                case 'composeExtension/submitAction':
                    const action =
                        context['bot.Capability'].activity.value

                    if (action.botMessagePreviewAction) {
                        switch (action.botMessagePreviewAction) {
                            case 'edit':
                                return this.createInvokeResponse(
                                    this.emit(
                                        'TeamsMessagingExtensionBotMessagePreviewEdit',
                                        context
                                    ) 
                                )
                            case 'send':
                                return this.createInvokeResponse(
                                    this.emit(
                                        'TeamsMessagingExtensionBotMessagePreviewSend',
                                        context
                                    ) 
                                )
                            default:
                                throw new Error('BadRequest')
                        }
                    } else {
                        return this.createInvokeResponse(
                            this.emit(
                                'TeamsMessagingExtensionSubmitAction',
                                context
                            ) 
                        )
                    }

                case 'composeExtension/fetchTask':
                    return this.createInvokeResponse(
                        this.emit('TeamsMessagingExtensionFetchTask', context)
                    )

                case 'composeExtension/querySettingUrl':
                    return this.createInvokeResponse(
                        this.emit(
                            'TeamsMessagingExtensionConfigurationQuerySettingUrl',
                            context
                        )
                    )

                case 'composeExtension/setting':
                    await this.emit(
                        'TeamsMessagingExtensionConfigurationSetting',
                        context
                    )
                    return this.createInvokeResponse()

                case 'composeExtension/onCardButtonClicked':
                    await this.emit(
                        'TeamsMessagingExtensionCardButtonClicked',
                        context
                    )
                    return this.createInvokeResponse()

                case 'task/fetch':
                    return this.createInvokeResponse(
                        this.emit('TeamsTaskModuleFetch', context)
                    )
                case 'task/submit':
                    return this.createInvokeResponse(
                        this.emit('TeamsTaskModuleSubmit', context)
                    )
                default:
                    throw new Error('NotImplemented')
            }
        } catch (err) {
            if (err.message === 'NotImplemented') {
                return { status: 501 }
            }
            if (err.message === 'BadRequest') {
                return { status: 400 }
            }
            throw err
        }
    }

    /** Receives invoke activities where context["bot.Capability"].activity.name is empty */
     onTeamsCardActionInvoke(
        handler



    ) {
        return this.on(
            'TeamsCardActionInvoke',
            async (context, next) => {
                await handler(context, next)
            }
        )
    }

    /** Receives invoke activities with Activity name of 'signin/verifyState' */
     onTeamsSigninVerifyState(
        handler




    ) {
        return this.on(
            'TeamsSigninVerifyState',
            async (context, next) => {
                await handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /** Receives invoke activities with Activity name of 'fileConsent/invoke' */
     onTeamsFileConsent(
        handler




    ) {
        return this.on(
            'TeamsFileConsent',
            async (context, next) => {
                const fileConsentCardResponse = context['bot.Capability']
                    .activity.value 
                await handler(context, fileConsentCardResponse, async () => {
                    switch (fileConsentCardResponse.action) {
                        case 'accept':
                            return this.emit(
                                'TeamsFileConsentAccept',
                                context,
                                next
                            )
                        case 'decline':
                            return this.emit(
                                'TeamsFileConsentDecline',
                                context,
                                next
                            )
                        default:
                            throw new Error('BadRequest')
                    }
                })
            }
        )
    }

    /**  Receives invoke activities with Activity name of 'fileConsent/invoke' with confirmation from user */
     onTeamsFileConsentAccept(
        handler




    ) {
        return this.on(
            'TeamsFileConsentAccept',
            async (context, next) => {
                const fileConsentCardResponse = context['bot.Capability']
                    .activity.value 
                return handler(context, fileConsentCardResponse, next)
            }
        )
    }

    /** Receives invoke activities with Activity name of 'fileConsent/invoke' with decline from user  */
     onTeamsFileConsentDecline(
        handler




    ) {
        return this.on(
            'TeamsFileConsentAccept',
            async (context, next) => {
                const fileConsentCardResponse = context['bot.Capability']
                    .activity.value 
                return handler(context, fileConsentCardResponse, next)
            }
        )
    }

    /** Receives invoke activities with Activity name of 'actionableMessage/executeAction' */
     onTeamsO365ConnectorCardAction(
        handler




    ) {
        return this.on(
            'TeamsO365ConnectorCardAction',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /** Receives invoke activities with Activity name of 'composeExtension/onCardButtonClicked' */
     onTeamsMessagingExtensionCardButtonClicked(
        handler




    ) {
        return this.on(
            'TeamsMessagingExtensionCardButtonClicked',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /** Receives invoke activities with Activity name of 'task/fetch' */
     onTeamsTaskModuleFetch(
        handler




    ) {
        return this.on(
            'TeamsTaskModuleFetch',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /** Receives invoke activities with Activity name of 'task/submit' */
     onTeamsTaskModuleSubmit(
        handler




    ) {
        return this.on(
            'TeamsTaskModuleSubmit',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /** Receives invoke activities with Activity name of 'composeExtension/queryLink'  */
     onTeamsAppBasedLinkQuery(
        handler




    ) {
        return this.on(
            'TeamsAppBasedLinkQuery',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /** Receives invoke activities with the name 'composeExtension/query' */
     onTeamsMessagingExtensionQuery(
        handler




    ) {
        return this.on(
            'TeamsMessagingExtensionQuery',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /** Receives invoke activities with the name 'composeExtension/selectItem'  */
     onTeamsMessagingExtensionSelectItem(
        handler




    ) {
        return this.on(
            'TeamsMessagingExtensionSelectItem',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /** Receives invoke activities with the name 'composeExtension/submitAction'  */
     onTeamsMessagingExtensionSubmitAction(
        handler




    ) {
        return this.on(
            'TeamsMessagingExtensionSubmitAction',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /** Receives invoke activities with the name 'composeExtension/submitAction' with the 'botMessagePreview' property present on activity.value  */
     onTeamsMessagingExtensionBotMessagePreviewEdit(
        handler




    ) {
        return this.on(
            'TeamsMessagingExtensionBotMessagePreviewEdit',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /** Receives invoke activities with the name 'composeExtension/submitAction' with the 'botMessagePreview' property present on activity.value.    */
     onTeamsMessagingExtensionBotMessagePreviewSend(
        handler




    ) {
        return this.on(
            'TeamsMessagingExtensionBotMessagePreviewSend',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /** Receives invoke activities with the name 'composeExtension/fetchTask' */
     onTeamsMessagingExtensionFetchTask(
        handler




    ) {
        return this.on(
            'TeamsMessagingExtensionFetchTask',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /** Receives invoke activities with the name 'composeExtension/querySettingUrl'   */
     onTeamsMessagingExtensionConfigurationQuerySettingUrl(
        handler




    ) {
        return this.on(
            'TeamsMessagingExtensionConfigurationQuerySettingUrl',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /** Receives invoke activities with the name 'composeExtension/setting'   */
     onTeamsMessagingExtensionConfigurationSetting(
        handler




    ) {
        return this.on(
            'TeamsMessagingExtensionConfigurationSetting',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

    /**
     * Event pipeline invoked when a sendActivities is called on IopaBotAdapterContext;
     * it allows for manipulation of the result, pre and post the next() call
     */
    onContextSendActivities(
        handler




    ) {
        return this.on(
            'ContextSendActivities',
            async (context, { activities }, next) => {
                return handler(context, activities, next)
            }
        )
    }

    /**
     * Event pipeline invoked when a updateActivities is called on IopaBotAdapterContext
     * it allows for manipulation of the result, pre and post the next() call
     */
    onContextUpdateActivity(
        handler




    ) {
        return this.on(
            'ContextUpdateActivity',
            async (context, { activity }, next) => {
                return handler(context, activity, next)
            }
        )
    }

    /**
     * Event pipeline invoked when a updateActivities is called on IopaBotAdapterContext
     * it allows for manipulation of the result, pre and post the next() call
     */
    onContextDeleteActivity(
        handler




    ) {
        return this.on(
            'ContextUpdateActivity',
            async (context, next) => {
                return handler(
                    context,
                    context['bot.Capability'].activity.value,
                    next
                )
            }
        )
    }

     createInvokeResponse(body) {
        return { status: 200, body }
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter/src/adapter-methods.ts












class adapter_methods_AdapterWithEventsAndMethods
    extends adapter_events_AdapterWithEvents
     {
    // eslint-disable-next-line no-useless-constructor
    constructor(app) {
        super(app)
        /** noop, needed for IOPA app.use */
    }

    /**
     * Rewrites the activity text without any at mention.
     * Use with caution because this function is altering the text on the Activity.
     */
     removeRecipientMention(activity) {
        return this.removeMentionText(activity, activity.recipient.id)
    }

    /**
     * Remove any mention text for given id from the Activity.Text property.  For example, given the message
     * "@echoBot Hi Bot", this will remove "@echoBot", leaving "Hi Bot".
     */
     removeMentionText(activity, id) {
        const mentions = this.getMentions(activity)
        const mentionsFiltered = mentions.filter(
            (mention) => mention.mentioned.id === id
        )
        if (mentionsFiltered.length) {
            activity.text = activity.text
                .replace(mentionsFiltered[0].text, '')
                .trim()
        }
        return activity.text
    }

    /** Returns the mentions on an activity */
     getMentions(activity) {
        const result = []
        if (activity.entities !== undefined) {
            for (let i = 0; i < activity.entities.length; i++) {
                if (activity.entities[i].type.toLowerCase() === 'mention') {
                    result.push(activity.entities[i] )
                }
            }
        }
        return result
    }

    /** Returns the conversation reference for an activity  */
     getConversationReference(
        activity
    ) {
        return {
            activityId: activity.id,
            user: shallowCopy(activity.from),
            bot: shallowCopy(activity.recipient),
            conversation: shallowCopy(activity.conversation),
            channelId: activity.channelId,
            serviceUrl: activity.serviceUrl,
            timestamp: Date.now(),
        }
    }

    /**  Updates an activity with the delivery information from a conversation reference.     */
     applyConversationReference(
        activity,
        reference,
        isIncoming = false
    ) {
        activity.channelId = reference.channelId
        activity.serviceUrl = reference.serviceUrl
        activity.conversation = reference.conversation
        if (isIncoming) {
            activity.from = reference.user
            activity.recipient = reference.bot
            if (reference.activityId) {
                activity.id = reference.activityId
            }
        } else {
            activity.from = reference.bot
            activity.recipient = reference.user
            if (reference.activityId) {
                activity.replyToId = reference.activityId
            }
        }

        return activity
    }

    /** Create a ConversationReference based on an outgoing Activity's ResourceResponse  */
     getReplyConversationReference(
        activity,
        reply
    ) {
        const reference = this.getConversationReference(
            activity
        )

        // Update the reference with the new outgoing Activity's id.
        reference.activityId = reply.id

        return reference
    }

    /** An asynchronous method that resumes a conversation with a user, possibly after some time has gone by. */
     async continueConversation(
        reference,
        logic
    ) {
        const request = this.applyConversationReference(
            { type: dist["ActivityTypes"].Event, name: 'continueConversation' },
            reference,
            true
        )

        const context = this.createContext(request)

        // always trust outbound serviceUrls
        httpAuthCredentials_HttpAuthAppCredentials.trustServiceUrl(reference.serviceUrl)

        try {
            await this._app.invoke(context)
            await logic(context)
        } catch (err) {
            if (this.onTurnError) {
                await this.onTurnError(context, err)
            } else {
                throw err
            }
        }
    }

    /** An asynchronous method that creates and starts a conversation with a user on a channel.  */
     async createConversation(
        reference,
        logic
    ) {
        if (!reference.serviceUrl) {
            throw new Error(
                `ActivityHelpers.createConversation(): missing serviceUrl.`
            )
        }

        // Create conversation
        const parameters = {
            bot: reference.bot,
            members: [reference.user],
            isGroup: false,
            activity: null,
            channelData: null,
        }

        // always trust outbound serviceUrls
        httpAuthCredentials_HttpAuthAppCredentials.trustServiceUrl(reference.serviceUrl)

        const client = this.createConversationsApiClient(reference.serviceUrl)

        // Mix in the tenant ID if specified. This is required for MS Teams.
        if (reference.conversation && reference.conversation.tenantId) {
            // Putting tenantId in channelData is a temporary solution while we wait for the Teams API to be updated
            parameters.channelData = {
                tenant: { id: reference.conversation.tenantId },
            }

            // Permanent solution is to put tenantId in parameters.tenantId
            parameters.tenantId = reference.conversation.tenantId
        }

        const response = await client.conversationsCreateConversation(
            parameters
        )

        // Initialize request and copy over new conversation ID and updated serviceUrl.
        const request = this.applyConversationReference(
            { type: dist["ActivityTypes"].Event, name: 'createConversation' },
            reference,
            true
        )

        const conversation = {
            id: response.id,
            isGroup: false,
            conversationType: null,
            tenantId: reference.conversation.tenantId,
            name: null,
        }
        request.conversation = conversation
        request.channelData = parameters.channelData

        if (response.serviceUrl) {
            request.serviceUrl = response.serviceUrl
        }

        const context = this.createContext(request)

        try {
            await this._app.invoke(context)
            await logic(context)
        } catch (err) {
            if (this.onTurnError) {
                await this.onTurnError(context, err)
            } else {
                throw err
            }
        }
    }

     async createProactiveChannelConversation(
        reference,
        activity,
        logic
    ) {
        if (!reference.serviceUrl) {
            throw new Error(
                `ActivityHelpers.createConversation(): missing serviceUrl.`
            )
        }

        // Create conversation
        const conversationParameters = {
            activity,
            bot: reference.bot,
            isGroup: reference.isGroup,
            channelData: reference.channelData,
            members: reference.members,
            tenantId: reference.tenantId,
        }

        // always trust outbound serviceUrls
        httpAuthCredentials_HttpAuthAppCredentials.trustServiceUrl(reference.serviceUrl)

        const conversationsApiClient = this.createConversationsApiClient(
            reference.serviceUrl
        )

        const response = await conversationsApiClient.conversationsCreateConversation(
            conversationParameters
        )

        const conversationReference = {
            activityId: response.activityId,
            bot: conversationParameters.bot,
            channelId: reference.channelId,
            conversation: { id: response.id },
            serviceUrl: reference.serviceUrl,
            user: conversationParameters.bot,
        } 

        // Initialize request and copy over new conversation ID and updated serviceUrl.
        const request = this.applyConversationReference(
            {
                type: dist["ActivityTypes"].Event,
                name: 'createProactiveChannelConversation',
            },
            conversationReference,
            false
        )

        request.conversation = {
            id: response.id,
            isGroup: reference.isGroup,
            conversationType: null,
            tenantId: reference.tenantId,
            name: null,
        }

        request.channelData = conversationParameters.channelData

        if (response.serviceUrl) {
            request.serviceUrl = response.serviceUrl
        }

        const context = this.createContext(request)

        try {
            await logic(context)
        } catch (err) {
            if (this.onTurnError) {
                await this.onTurnError(context, err)
            } else {
                throw err
            }
        }
    }

    /** An asynchronous method that removes a member from the current conversation.  */
     async deleteConversationMember(
        context,
        memberId
    ) {
        const { activity } = context['bot.Capability']
        if (!activity.serviceUrl) {
            throw new Error(
                `ActivityHelpers.deleteConversationMember(): missing serviceUrl`
            )
        }
        if (!activity.conversation || !activity.conversation.id) {
            throw new Error(
                `ActivityHelpers.deleteConversationMember(): missing conversation or conversation.id`
            )
        }
        const { serviceUrl } = activity
        const conversationId = activity.conversation.id
        const client = this.createConversationsApiClient(serviceUrl)
        await client.conversationsDeleteConversationMember(
            conversationId,
            memberId
        )
    }

    /** An asynchronous method that lists the members of a given activity.  */
     async getActivityMembers(
        context,
        activityId
    ) {
        const { activity } = context['bot.Capability']
        if (!activityId) {
            activityId = activity.id
        }
        if (!activity.serviceUrl) {
            throw new Error(
                `ActivityHelpers.getActivityMembers(): missing serviceUrl`
            )
        }
        if (!activity.conversation || !activity.conversation.id) {
            throw new Error(
                `ActivityHelpers.getActivityMembers(): missing conversation or conversation.id`
            )
        }
        if (!activityId) {
            throw new Error(
                `ActivityHelpers.getActivityMembers(): missing both activityId and context["bot.Capability"].activity.id`
            )
        }
        const { serviceUrl } = activity
        const conversationId = activity.conversation.id
        const client = this.createConversationsApiClient(serviceUrl)

        return client.conversationsGetActivityMembers(
            conversationId,
            activityId
        )
    }

    /** An asynchronous method that, for the specified channel, gets a page of the conversations in which this bot has participated.  */
     async getConversations(
        contextOrServiceUrl,
        continuationToken
    ) {
        const url =
            typeof contextOrServiceUrl === 'object'
                ? contextOrServiceUrl['bot.Capability'].activity.serviceUrl
                : contextOrServiceUrl
        const client = this.createConversationsApiClient(url)

        return client.conversationsGetConversations(
            continuationToken || undefined
        )
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter/src/adapter.ts
/* concated harmony reexport Adapter */__webpack_require__.d(__webpack_exports__, "a", function() { return adapter_methods_AdapterWithEventsAndMethods; });
/* concated harmony reexport URN_BOTADAPTER */__webpack_require__.d(__webpack_exports__, "b", function() { return URN_BOTADAPTER; });




/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier-schema/dist/index.js
var dist = __webpack_require__(11);

// EXTERNAL MODULE: /Users/guy/Library/Caches/.wrangler/wranglerjs-1.13.0/node_modules/url/url.js
var url = __webpack_require__(12);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier/src/util.ts
function shallowCopy(value) {
    if (Array.isArray(value)) {
        return value.slice(0) 
    }
    if (typeof value === 'object') {
        return { ...(value ) }
    }

    return value
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier-schema-auth/src/claimsIdentity.ts





/**
 * Represents a claims-based identity.
 */
class ClaimsIdentity {
    
    

    constructor(claims, isAuthenticated) {
        this.claims = claims
        this.isAuthenticated = isAuthenticated
    }

    /**
     * Returns a claim value (if its present)
     * @param  {string} claimType The claim type to look for
     * @returns {string|null} The claim value or null if not found
     */
     getClaimValue(claimType) {
        const claim = this.claims.find(
            (c) => c.type === claimType
        )

        return claim ? claim.value : null
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier-schema-auth/src/authenticationConstants.ts
/**
 * Allowed token signing algorithms. Tokens come from channels to the bot. The code
 * that uses this also supports tokens coming from the emulator.
 */
const AllowedSigningAlgorithms = ['RS256', 'RS384', 'RS512']

/**
 * "azp" Claim.
 * Authorized party - the party to which the ID Token was issued.
 * This claim follows the general format set forth in the OpenID Spec.
 *     http://openid.net/specs/openid-connect-core-1_0.html#IDToken
 */
const AuthorizedParty = 'azp'

/**
 * Audience Claim. From RFC 7519.
 *     https://tools.ietf.org/html/rfc7519#section-4.1.3
 * The "aud" (audience) claim identifies the recipients that the JWT is
 * intended for.  Each principal intended to process the JWT MUST
 * identify itself with a value in the audience claim.If the principal
 * processing the claim does not identify itself with a value in the
 * "aud" claim when this claim is present, then the JWT MUST be
 * rejected.In the general case, the "aud" value is an array of case-
 * sensitive strings, each containing a StringOrURI value.In the
 * special case when the JWT has one audience, the "aud" value MAY be a
 * single case-sensitive string containing a StringOrURI value.The
 * interpretation of audience values is generally application specific.
 * Use of this claim is OPTIONAL.
 */
const AudienceClaim = 'aud'

/**
 * Issuer Claim. From RFC 7519.
 *     https://tools.ietf.org/html/rfc7519#section-4.1.1
 * The "iss" (issuer) claim identifies the principal that issued the
 * JWT.  The processing of this claim is generally application specific.
 * The "iss" value is a case-sensitive string containing a StringOrURI
 * value.  Use of this claim is OPTIONAL.
 */
const IssuerClaim = 'iss'

/**
 * From RFC 7515
 *     https://tools.ietf.org/html/rfc7515#section-4.1.4
 * The "kid" (key ID) Header Parameter is a hint indicating which key
 * was used to secure the JWS. This parameter allows originators to
 * explicitly signal a change of key to recipients. The structure of
 * the "kid" value is unspecified. Its value MUST be a case-sensitive
 * string. Use of this Header Parameter is OPTIONAL.
 * When used with a JWK, the "kid" value is used to match a JWK "kid"
 * parameter value.
 */
const KeyIdHeader = 'kid'

/**
 * Token version claim name. As used in Microsoft AAD tokens.
 */
const VersionClaim = 'ver'

/**
 * App ID claim name. As used in Microsoft AAD 1.0 tokens.
 */
const AppIdClaim = 'appid'

/**
 * Service URL claim name. As used in Microsoft Bot Framework v3.1 auth.
 */
const ServiceUrlClaim = 'serviceurl'

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier-schema-auth/src/clientValidation.ts





/**
 * Validate the incoming Headers sent from the Carrier Service.
 * @param  {string} authHeader The raw HTTP header in the format: "Bearer [longString]"
 * @param  {ICredentialProvider} credentials The user defined set of valid credentials, such as the AppId.
 * @returns {Promise<ClaimsIdentity>} A valid ClaimsIdentity.
 */
async function authenticateCarrierContext(
    context,
    credentials
) {
    const provider = context['iopa.Url'].searchParams.get('provider')

    if (provider === 'signalwire') {
        const body = await context['iopa.Body']
        const accountSid = body.AccountSid
        const token = context['iopa.Url'].searchParams.get('callback_token')
        const secret = await credentials.getAppSecret(accountSid)

        if (secret === token) {
            return new ClaimsIdentity(
                [{ type: AppIdClaim, value: accountSid }],
                true
            )
        }

        throw new Error(`Unauthorized.`)
    } else if (provider === 'twilio') {
        const body = await context['iopa.Body']
        const accountSid = body.AccountSid
        const token = context['iopa.Url'].searchParams.get('callback_token')
        const secret = await credentials.getAppSecret(accountSid)

        const headersignature = context['iopa.Headers'].get(
            'X-Twilio-Signature'
        )

        console.log(`Twilio signature ${headersignature}`)

        if (secret === token) {
            return new ClaimsIdentity(
                [{ type: AppIdClaim, value: accountSid }],
                true
            )
        }

        throw new Error(`Unauthorized.`)
    } else {
        throw new Error(`Provider ${provider} not supported`)
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier-schema-auth/src/credentialProvider.ts


/**
 * CredentialProvider interface. This interface allows Capabilities to provide their own
 * implementation of what is, and what is not, a valid appId and password. This is
 * useful in the case of multi-tenant bots, where the bot may need to call
 * out to a service to determine if a particular appid/password pair
 * is valid.
 *
 * For Single Tenant bots (the vast majority) the simple static providers
 * are sufficient.
 */




































class credentialProvider_SimpleCredentialProvider  {
     static  __initStatic() {this.trustedHostNames = new Map


([
        ["synchealth.signalwire.com", new Date(8640000000000000)], // Date.MAX_VALUE,
        ['api.twilio.com', new Date(8640000000000000)],
    ])}

    

    

    constructor(appId, appSecret) {
        this.appId = appId
        this.appSecret = appSecret
    }

    /**
     * Validate AppId.
     *
     * This method is async to enable custom implementations
     * that may need to call out to serviced to validate the appId / password pair.
     * @param  {string} appId bot appid
     * @returns {Promise<boolean>} true if it is a valid AppId
     */
     isValidAppId(appId) {
        return Promise.resolve(this.appId === appId)
    }

    /**
     * Get the app password for a given bot appId, if it is not a valid appId, return Null
     *
     * This method is async to enable custom implementations
     * that may need to call out to serviced to validate the appId / password pair.
     * @param  {string} appId bot appid
     * @returns {Promise<string|null>} password or null for invalid appid
     */
     getAppSecret(appId) {
        return Promise.resolve(this.appId === appId ? this.appSecret : null)
    }

    /**
     * Checks if  authentication is disabled.
     * Return true if authentication is disabled.
     *
     * This method is async to enable custom implementations
     * that may need to call out to serviced to validate the appId / password pair.
     * @returns {Promise<boolean>} true if bot authentication is disabled.
     */
     isAuthenticationDisabled() {
        if (
            true
        ) {
            return Promise.resolve(true)
        }
        return Promise.resolve(false)
    }

     async signRequest(
        url,
        request
    ) {
        if (this.shouldSetToken(url)) {
            const token = btoa(`${this.appId}:${this.appSecret}`)

            if (request.headers.set) {
                request.headers.set('authorization', `Basic ${token}`)
            } else {
                request.headers.authorization = `Basic ${token}`
            }
        }
    }

     shouldSetToken(url) {
        return credentialProvider_SimpleCredentialProvider.isTrustedServiceUrl(url)
    }

    /**
     * Checks if the service url is for a trusted host or not.
     * @param  {string} serviceUrl The service url
     * @returns {boolean} True if the host of the service url is trusted; False otherwise.
     */
     static isTrustedServiceUrl(serviceUrl) {
        try {
            const uri = url["parse"](serviceUrl)
            if (uri.host) {
                return credentialProvider_SimpleCredentialProvider.isTrustedUrl(uri.host)
            }
        } catch (e) {
            // tslint:disable-next-line:no-console
            console.error('Error in isTrustedServiceUrl', e)
        }

        return false
    }

     static isTrustedUrl(uri) {
        const expiration = credentialProvider_SimpleCredentialProvider.trustedHostNames.get(
            uri
        )
        if (expiration) {
            // check if the trusted service url is still valid
            return expiration.getTime() > Date.now() - 300000 // 5 Minutes
        }

        return false
    }
} credentialProvider_SimpleCredentialProvider.__initStatic();

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier-schema-auth/src/index.ts




// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier/src/context-capability.ts











const $$context = Symbol('urn:io:iopa:bot:response:context')

class context_capability_CarrierCapability  {
    

    

    

    

    

    constructor(
        plaincontext,
        carrier,
        activity
    ) {
        this[$$context] = plaincontext 
        this.activity = activity
        this.carrier = carrier
        this.turnState = new Map()
        this.responded = false
    }

    /** Sends a single activity or message to the user */
     sendActivity(
        activityOrText,
        speak
    ) {
        let a
        if (typeof activityOrText === 'string') {
            a = {
                text: activityOrText,
            }
            if (speak) {
                a.speak = speak
            }
        } else {
            a = activityOrText
        }

        return this.sendActivities([a]).then((responses) =>
            responses && responses.length > 0 ? responses[0] : undefined
        )
    }

    /** Sends a set of activities to the user. An array of responses from the server will be returned  */
     sendActivities(
        activities
    ) {
        let sentNonTraceActivity = false
        const ref = this.carrier.getConversationReference(
            this.activity
        )
        const output = activities.map(
            (a) => {
                const o = this.carrier.applyConversationReference(
                    { ...a },
                    ref
                )
                if (!o.type) {
                    o.type = dist["ActivityTypes"].Message
                }
                if (o.type !== dist["ActivityTypes"].Trace) {
                    sentNonTraceActivity = true
                }

                return o
            }
        )

        return this.carrier.emit(
            'ContextSendActivities',
            this[$$context],
            { activities: output },
            () => {
                return this.carrier
                    .sendActivities(this[$$context], output)
                    .then((responses) => {
                        // Set responded flag
                        if (sentNonTraceActivity) {
                            this.responded = true
                        }

                        return responses
                    })
            }
        )
    }

     copyTo( context) {
        // TODO COPY REFERENCES ETC.

        return context
    }
}

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter-cards/src/index.ts + 2 modules
var src = __webpack_require__(33);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier/src/context-response-connector.ts












const MIN_TYPING_DURATION = 2200
const MIN_POST_MESSAGE_DELAY = 1500
const MAX_POST_MESSAGE_DELAY = 4000
const DEFAULT_DELAY_FOR_CARD = 3000
const DELAY_WHEN_DISABLED = 40

const $$bodyState = Symbol('urn:io:iopa:bot:response:bodystate')
const context_response_connector_$$context = Symbol('urn:io:iopa:bot:response:context')

/** Convert plain IopaContext into a method-enhanced IopaCarrierContext */
function toIopaCarrierResponse(
    plainresponse,
    context
) {
    const response = plainresponse 
    response[context_response_connector_$$context] = context
    response['bot.Capability'] = context['bot.Capability']

    response.send = context_response_connector_ResponseHelpers.prototype.send
    response.sendAll = context_response_connector_ResponseHelpers.prototype.sendAll
    response.say = context_response_connector_ResponseHelpers.prototype.say
    response.card = context_response_connector_ResponseHelpers.prototype.card
    response.shouldEndSession = context_response_connector_ResponseHelpers.prototype.shouldEndSession
    response.showTypingIndicator = context_response_connector_ResponseHelpers.prototype.showTypingIndicator
    response.hideTypingIndicator = context_response_connector_ResponseHelpers.prototype.hideTypingIndicator
    response.status = context_response_connector_ResponseHelpers.prototype.status
    response.fail = context_response_connector_ResponseHelpers.prototype.fail
    response.status = context_response_connector_ResponseHelpers.prototype.status
    response.isAwaitingMultiChoiceResponse =
        context_response_connector_ResponseHelpers.prototype.isAwaitingMultiChoiceResponse

    response['bot.ShouldEndSession'] = false
    response['bot.ResponseHandled'] = false
    response['bot.IsDelayDisabled'] = false
    response['iopa.StatusCode'] = 200

    return response
}

class context_response_connector_ResponseHelpers  {
    say( text) {
        if (this[$$bodyState]) {
            if (this[$$bodyState].text) {
                this[$$bodyState].text = `${this[$$bodyState].text}\n${text}`
            } else {
                this[$$bodyState].text = text
            }
        } else {
            this[$$bodyState] = { text }
        }

        this['bot.ResponseHandled'] = true

        return this
    }

    card( card) {
        if (
            'text' in card ||
            'attachments' in card ||
            'image' in card ||
            'title' in card
        ) {
            this.say(card.text)

            if (card.attachments) {
                this[$$bodyState].attachments = card.attachments
            }

            if (card.image) {
                this[$$bodyState].image = card.image
            }

            if (card.title) {
                this[$$bodyState].attachments =
                    this[$$bodyState].attachments || []
                this[$$bodyState].attachments[0] =
                    this[$$bodyState].attachments[0] || {}
                this[$$bodyState].attachments[0].text = card.title
            }
        } else {
            this[$$bodyState] = this[$$bodyState] || {}

            this[$$bodyState].attachments = this[$$bodyState].attachments || []

            this[$$bodyState].attachments.push(card)
        }

        return this
    }

    /** Send response back to bot */
    async send( body) {
        if (body) {
            if (typeof body === 'string') {
                this.say(body)
            } else {
                this.card(body)
            }
        }

        let message
        let card

        if (this['iopa.StatusCode'] !== 200) {
            // TO DO:: FORMAT ERROR
            message = `Unfortunately an error has occured:\n  ${this['iopa.StatusCode']} ${this[$$bodyState].text}`
        } else {
            message = this[$$bodyState].text

            if (this[$$bodyState].attachments) {
                card = this[$$bodyState].attachments[0]
            }
        }

        const hasMessage = message && message.length > 0

        if (!hasMessage && !card) {
            return
        }

        const responseResult =
            hasMessage && !card
                ? src["b" /* MessageFactory */].text(message)
                : src["b" /* MessageFactory */].attachment(card, message)

        await this['bot.Capability'].sendActivity(responseResult)

        this[$$bodyState] = undefined

        console.log(
            `CF< Response Complete ${this[context_response_connector_$$context]['server.TimeElapsed']}ms`
        )
    }

    /** Helper method to indicate this response should end the dialog */
    shouldEndSession(
        
        flag
    ) {
        this['bot.ShouldEndSession'] = flag
        return this
    }

    /** Helper method to set the status of the response */
    status( statuscode) {
        this['iopa.StatusCode'] = statuscode
        return this
    }

    /** Send a text string or card attachments, looping with delay if multiple provided */
    sendAll(
        
        messages,
        typingDelay
    ) {
        return asyncForEach(messages, async (message) => {
            const typingDuration = typingDelay || MIN_TYPING_DURATION
            let postMessageDelay

            if (typeof message === 'string') {
                postMessageDelay = postMessageDelayForText(message)
                this.say(message)
            } else {
                postMessageDelay = postMessageDelayForCard(message)
                this.card(message)
            }
            await this.showTypingIndicator()
            await delay(
                this['bot.IsDelayDisabled']
                    ? DELAY_WHEN_DISABLED
                    : typingDuration
            )
            await this.send()
            await this.hideTypingIndicator()
            await delay(
                this['bot.IsDelayDisabled']
                    ? DELAY_WHEN_DISABLED
                    : postMessageDelay
            )
        })
    }

    fail(
        
        error,
        message,
        inChannel
    ) {
        this['iopa.StatusCode'] = 200

        this[$$bodyState] = {
            text: `${message}: ${error}`,
        }

        return this
    }

    async showTypingIndicator() {
        return Promise.resolve()
    }

    async hideTypingIndicator() {
        return Promise.resolve()
    }

    isAwaitingMultiChoiceResponse() {
        return (
            (this[context_response_connector_$$context] )['bot.Session'][
                'bot.isMultiChoicePrompt'
            ] === true
        )
    }
}

//
// private methods
//

function delay(interval) {
    return new Promise((resolve, _reject) => {
        setTimeout(resolve, interval)
    })
}

function postMessageDelayForText(text) {
    const avgWordsPerMinute = 90
    const avgCharsPerWord = 5
    const wordCount = text.length / avgCharsPerWord
    const delay = (wordCount / avgWordsPerMinute) * 60 * 100
    const buffer = 900
    const final = clamp(
        MIN_POST_MESSAGE_DELAY,
        delay + buffer,
        MAX_POST_MESSAGE_DELAY
    )
    return final
}

function postMessageDelayForCard(card) {
    if (card.typingDelay !== undefined) {
        return card.postMessageDelay
    }
    if (card.text) {
        return postMessageDelayForText(card.text)
    }
    return DEFAULT_DELAY_FOR_CARD
}

function clamp(min, value, max) {
    return Math.min(max, Math.max(min, value))
}

async function asyncForEach(array, callback) {
    for (let index = 0; index < array.length; index++) {
        await callback(array[index], index, array)
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier/src/context.ts










/** Convert plain IopaContext into a method-enhanced IopaCarrierContext */
function toIopaCarrierContext(
    plaincontext,
    carrier,
    activity
) {
    const context = plaincontext 
    context['bot.Capability'] = new context_capability_CarrierCapability(
        plaincontext,
        carrier,
        activity
    )
    context['bot.Provider'] =
        context['bot.Provider'] ||
        ((activity.channelId ) )
    context.response = toIopaCarrierResponse(plaincontext.response, context)
    return context
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier/src/carrier-core.ts
/* eslint-disable no-await-in-loop */
/* eslint-disable no-async-promise-executor */
/* eslint-disable no-case-declarations */

















// This key is exported internally so that the TeamsActivityHandler will not overwrite any already set InvokeResponses.
const INVOKE_RESPONSE_KEY = 'urn:io.iopa.invokeResponse'
const URN_CARRIER = 'urn:io.iopa:carrier'
const URN_BOTINTENT_LITERAL = 'urn:io.iopa.bot:intent:literal'

/** The Iopa CarrierMiddleware */
class carrier_core_CarrierCore  {
    

    

    constructor(app) {
        this.app = app
        ;(app ).carrier = (this ) 

        this.providerConfig = {
            signalwire: {
                provider: 'signalwire',
                baseUrl: `https://${"synchealth.signalwire.com"}`,
                serviceUrl: `https://${"synchealth.signalwire.com"}/api/laml/2010-04-01`,
                accountSid: "7019f539-cf2a-4939-af88-95cc97fb1edb",
                migrateToAccountSid:
                    "57e2eb8f-d67c-4de5-a3b4-0ef1552ce9a2",
                outboundCredentialsProvider: new credentialProvider_SimpleCredentialProvider(
                    "7019f539-cf2a-4939-af88-95cc97fb1edb",
                    "PTca0d6c58f57e11fed5b3a0be4f6b9f3ad7068a8bfa3844f1"
                ),
                inboundCredentialsProvider: new credentialProvider_SimpleCredentialProvider(
                    "7019f539-cf2a-4939-af88-95cc97fb1edb",
                    "21ef6245-e3f0-4520-a6ad-0cb96ea58273"
                ),
                carrierCallbackApplicationId:
                    "7a4afa01-a47e-4f96-9d11-94b0f1170c4d",
                addressSid: "b7796f9d-f990-4555-8313-95bb40c668ca",
                migrateToAddressSid:
                    "4aa090a1-c11b-4c76-8695-b1f27740b064",
            },
            twilio: {
                provider: 'twilio',
                baseUrl: `https://api.twilio.com`,
                serviceUrl: `https://api.twilio.com/2010-04-01`,
                accountSid: "ACf2709026485881a69681ac9c46245c61",
                migrateToAccountSid: "AC821f29129f3fc25d8ed67c55d266f62b",
                outboundCredentialsProvider: new credentialProvider_SimpleCredentialProvider(
                    "ACf2709026485881a69681ac9c46245c61",
                    "e27bbe86e1665adc58e693d54d1caca0"
                ),
                inboundCredentialsProvider: new credentialProvider_SimpleCredentialProvider(
                    "ACf2709026485881a69681ac9c46245c61",
                    "21ef6245-e3f0-4520-a6ad-0cb96ea58273"
                ),
                carrierCallbackApplicationId:
                    "APf1bf5f86f9a566837b060e13e27707c1",
                addressSid: "AD688163365ef21dc6d54bdb102dc49081",
                migrateToAddressSid: "AD2be5f039162b72496d168259d04b309e",
            },
        }
    }

    /** An asynchronous method that creates a turn context and runs the middleware pipeline
     * for an incoming activity from HTTP wire */
     async invokeActivity(
        context,
        next
    ) {
        if (context['iopa.Protocol'] === URN_CARRIER) {
            // skip validation and parsing for synthetic contexts created by this framework
            return next()
        }

        let status
        let processError

        try {
            // Parse body of request
            status = 400

            const activity = await this._parseRequest(context)

            // Authenticate the incoming request
            status = 401
            await this.authenticateRequest(context )

            // Expand Context with Iopa Turn Context from
            status = 500
            const contextExpanded = toIopaCarrierContext(
                context,
                (this ) ,
                activity
            )

            contextExpanded['bot.Source'] = URN_CARRIER

            console.log(
                `[Carrier] Authorization Complete] ${context.get(
                    'server.TimeElapsed'
                )}ms`
            )

            // Main processing of received activity
            try {
                await next()
            } catch (err) {
                if (this.onTurnError) {
                    await this.onTurnError(contextExpanded, err)
                } else {
                    throw err
                }
            }

            if (status !== 200) {
                status = 200

                await context.response.end(
                    `<?xml version="1.0" encoding="UTF-8"?><Response></Response>`,
                    { status }
                )
            }
        } catch (err) {
            // Catch the error to try and throw the stacktrace out of processActivity()
            processError = err
            console.error(err)
        }

        if (status !== 200) {
            await context.response.end(
                `<?xml version="1.0" encoding="UTF-8"?><Response></Response>`,
                { status }
            )
        }

        // Check for an error
        if (status >= 400) {
            if (processError && (processError ).stack) {
                throw new Error(
                    `CarrierCore.invoke(): ${status} ERROR\n ${processError.stack}`
                )
            } else {
                throw new Error(`CarrierCore.invoke(): ${status} ERROR`)
            }
        }
        return null
    }

    /** An asynchronous method that sends a set of outgoing activities to a channel server. */
     async sendActivities(
        context,
        activities
    ) {
        const responses = []
        for (let i = 0; i < activities.length; i++) {
            const activity = activities[i]
            switch (activity.type ) {
                case 'delay':
                    await carrier_core_delay(
                        typeof activity.value === 'number'
                            ? activity.value
                            : 1000
                    )
                    responses.push({} )
                    break
                default:
                    if (!activity.serviceUrl) {
                        throw new Error(
                            `CarrierCore.sendActivities(): missing serviceUrl.`
                        )
                    }
                    if (!activity.recipient || !activity.recipient.id) {
                        throw new Error(
                            `CarrierCore.sendActivities(): missing recipient id.`
                        )
                    }

                    const client = this.createCarrierApiClient(
                        this.providerConfig[context['bot.Provider']]
                    )

                    if (
                        activity.type === dist["ActivityTypes"].Trace &&
                        activity.channelId !== 'emulator'
                    ) {
                        // Just eat activity
                        responses.push({} )
                    } else {
                        try {
                            responses.push(
                                ((await client.accountsAccountSidMessagesmediaTypeExtensionPost(
                                    activity.conversation.tenantId,
                                    '.json',
                                    activity.recipient.id,
                                    activity.from.id,
                                    undefined,
                                    activity.text,
                                    undefined, // TODO   Process MMS Messages too
                                    {
                                        query: {
                                            ApplicationSid: this.providerConfig[
                                                context['bot.Provider']
                                            ].carrierCallbackApplicationId,
                                        },
                                    }
                                )) ) 
                            )
                        } catch (ex) {
                            const error = await ex.json()
                            console.error(JSON.stringify(error))
                            throw new Error(
                                ex.statusText ||
                                    `Error: ${
                                        ex.message ||
                                        'An error occurred sending the message [carrier-core]'
                                    }`
                            )
                        }
                    }
                    break
            }
        }
        return responses
    }

    /** Creates a connector client.  Used by Teams Extensions in this package, not external */
     createCarrierApiClient(config) {
        const fetchProxy = this.fetchWithCredentials.bind(this, config)
        const client = new dist["CarrierApi"](
            {},
            config.serviceUrl.replace(/\/+$/, ''),
            fetchProxy
        )
        return client
    }

     async fetchWithCredentials(
        config,
        url,
        init
    ) {
        if (init && init.body && init.body instanceof URLSearchParams) {
            if (init.headers.set) {
                init.headers.set(
                    'content-type',
                    'application/x-www-form-urlencoded'
                )
            } else {
                init.headers['content-type'] =
                    'application/x-www-form-urlencoded'
            }
        }
        try {
            await config.outboundCredentialsProvider.signRequest(url, init)

            const result = await timeout(fetch(url, init), 10000)

            // override json in case of empty successful (202) responses
            if (result.status === 202) {
                result.json = async () => ({})
            }
            return result
        } catch (ex) {
            // rethrow for stack trace upon timeout
            try {
                throw ex
            } catch (ex) {
                console.error(ex)
                return ex
            }
        }
    }

    /** Allows for the overriding of authentication in unit tests. */
     async authenticateRequest(
        context
    ) {
        await authenticateCarrierContext(
            context,
            this.providerConfig[context['bot.Provider']]
                .inboundCredentialsProvider
        )
    }

    /**  Creates a turn context */
     createContext(activity) {
        const plaincontext = this.app.createContext(activity.serviceUrl, {
            withResponse: true,
            protocol: URN_CARRIER,
        })

        const context = toIopaCarrierContext(
            plaincontext,
            (this ) ,
            activity
        )

        context['bot.Source'] = URN_CARRIER

        return context
    }

    




    /** Gets/sets a error handler that will be called anytime an uncaught exception is raised during a turn */
     get onTurnError()


 {
        return this.turnError
    }

     set onTurnError(
        value
    ) {
        this.turnError = value
    }

     /** Handles incoming webhooks from the Twilio/SignalWire Carrier */

    /** Handles incoming webhooks from the Twilio/SignalWire Carrier */
     _parseRequest(context) {
        return new Promise(
            async (resolve, reject) => {
                const provider = context['iopa.Url'].searchParams.get(
                    'provider'
                )

                if (['twilio', 'signalwire'].indexOf(provider) === -1) {
                    throw new Error(
                        `CarrierCore._parseRequest(): unknown provider ${provider}.`
                    )
                }

                const body = await context['iopa.Body']

                try {
                    if (typeof body !== 'object') {
                        throw new Error(
                            `CarrierCore._parseRequest(): invalid request body.`
                        )
                    }

                    if (typeof body.AccountSid !== 'string') {
                        body.AccountSid = this.providerConfig[
                            provider
                        ].accountSid

                        console.log(
                            `CarrierCore._parseRequest(): missing account_sid, so defaulted`
                        )
                    }

                    let type

                    switch (context['iopa.Url'].searchParams.get('type')) {
                        case 'message':
                            type = dist["ActivityTypes"].Message
                            break
                        case 'voice':
                            type = dist["ActivityTypes"].Call
                            break
                        case 'message_status':
                            type = dist["ActivityTypes"].MessageStatus
                            break
                        case 'voice_status':
                            type = dist["ActivityTypes"].CallStatus
                            break
                        default:
                            throw new Error(
                                `CarrierCore._parseRequest(): missing or invalid type on search params`
                            )
                    }

                    const activity = {
                        type,
                        channelId: provider,
                        conversation: { tenantId: body.AccountSid },
                        channelData: body,
                        from: { id: body.From },
                        recipient: { id: body.CalledVia || body.To },
                        text: body.Body,
                        id: body.MessageSid || body.SmsSid,
                        serviceUrl: this.providerConfig[provider].serviceUrl,
                    }
                    ;(context )[
                        'bot.Provider'
                    ] = provider 

                    resolve(activity)
                } catch (err) {
                    console.error(err)
                    reject(err)
                }
            }
        )
    }
}

function carrier_core_delay(/** timeout in ms */ timeout) {
    return new Promise((resolve) => {
        setTimeout(resolve, timeout)
    })
}

function timeout(promise, ms) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new Error('timeout'))
        }, ms)
        promise.then(resolve, reject)
    })
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier/src/carrier-events.ts























class carrier_events_CarrierWithEvents extends carrier_core_CarrierCore  {
      __init() {this.handlers = {}}

     constructor(app) {
        super(app);carrier_events_CarrierWithEvents.prototype.__init.call(this);carrier_events_CarrierWithEvents.prototype.__init2.call(this);
        app.use(this.invokeEvents, 'CarrierWithEvents.Invoke')
    }

    //
    // MASTER INVOKE HANDLER
    //

     __init2() {this.invokeEvents = async (
        context,
        next
    ) => {
        if (context['bot.Source'] !== URN_CARRIER) {
            return next()
        }

        const reading = context 

        const { activity, carrier } = context['bot.Capability']

        context['iopa.Labels'].set('user', activity.from.id)

        reading['bot.ActivityId'] = activity.id
        reading[
            'bot.ActivityType'
        ] = (((activity.type ) ).charAt(0).toUpperCase() +
            ((activity.type ) ).slice(1)) 
        reading['bot.Channel'] = { id: activity.conversation.tenantId }
        reading['bot.Conversation'] = carrier.getConversationReference(activity)
        reading['bot.From'] = {
            id: activity.from.aadObjectId, // likely undefined
            localid: activity.from.id,
            name:
                activity.from.name || activity.channelData.CallerCity
                    ? `${activity.channelData.CallerCity} ${activity.channelData.CallerState}`
                    : '', // name likely undefined
        }
        reading['bot.Intent'] =
            activity.type === dist["ActivityTypes"].Message
                ? URN_BOTINTENT_LITERAL
                : `${URN_CARRIER}:${activity.type}`
        reading['bot.Recipient'] = {
            id: activity.recipient.aadObjectId, // likely undefined
            localid: activity.recipient.id,
            name: activity.recipient.name, // likely undefined
        }
        reading['bot.Session'] = undefined
        reading['bot.Team'] = { id: 'carrier' }
        reading['bot.Timestamp'] = Date.now()

        await this.emit('Turn', context, async () => {
            switch (context['bot.Capability'].activity.type) {
                case dist["ActivityTypes"].Message:
                    await this.invokeMessageActivity(context)
                    break
                case dist["ActivityTypes"].Call:
                    await this.invokeCallActivity(context)
                    break
                case dist["ActivityTypes"].MessageStatus:
                    await this.invokeMessageStatusActivity(context)
                    break
                case dist["ActivityTypes"].CallStatus:
                    await this.invokeCallStatusActivity(context)
                    break
                default:
                    await this.invokeUnrecognizedActivity(context)
                    break
            }
        })

        return next()
    }}

    //
    // INVOKE SUBTYPE HANDLERS
    //

     async invokeMessageActivity(
        context
    ) {
        const { activity, carrier } = context['bot.Capability']
        const reading = context 
        reading['bot.Text'] = activity.text
        context.response['iopa.Headers'].set('content-type', 'text/xml')
        await this.emit('Message', reading, this.defaultNextEvent(reading))
    }

     async invokeCallActivity(
        context
    ) {
        const { activity, carrier } = context['bot.Capability']
        const reading = context 
        reading['bot.Text'] = activity.text
        context.response['iopa.Headers'].set('content-type', 'text/xml')

        await this.emit('Call', reading, this.defaultNextEvent(reading))
    }

     async invokeMessageStatusActivity(
        context
    ) {
        const reading = context 
        context.response['iopa.Headers'].set('content-type', 'text/plain')
        await this.emit(
            'MessageStatus',
            reading,
            this.defaultNextEvent(reading)
        )
    }

     async invokeCallStatusActivity(
        context
    ) {
        const { activity, carrier } = context['bot.Capability']
        const reading = context 
        reading['bot.Text'] = activity.text
        context.response['iopa.Headers'].set('content-type', 'text/xml')
        await this.emit('CallStatus', reading, this.defaultNextEvent(reading))
    }

     async invokeUnrecognizedActivity(
        context
    ) {
        await this.emit(
            'UnrecognizedActivityType',
            context,
            this.defaultNextEvent(context)
        )
    }

    //
    // INTERNAL EVENT INFRASTRUCTURE
    //

     defaultNextEvent(
        context
    ) {
        const runDialogs = async () => {
            if (!context['bot.Capability'].responded) {
                await this.emit('Dialog', context, async () => {
                    // noop
                })
            }
        }
        return runDialogs
    }

     on(type, handler) {
        if (!this.handlers[type]) {
            this.handlers[type] = [handler]
        } else {
            this.handlers[type].push(handler)
        }
        return this
    }

    














    async emit(
        type,
        context,
        args,
        onNext
    ) {
        if ((type ) !== 'Dialog') {
            context['bot.ActivityType'] = type
        }

        if (typeof args === 'function') {
            onNext = args 
            args = null
        }

        let returnValue = null

        async function runHandler(index) {
            if (index < handlers.length) {
                const val = args
                    ? await (handlers[index] )(
                          context,
                          args,
                          () => runHandler(index + 1)
                      )
                    : await (handlers[index] )(
                          context,
                          () => runHandler(index + 1)
                      )

                // if a value is returned, and we have not yet set the return value,
                // capture it.  This is used to allow InvokeResponses to be returned.
                if (typeof val !== 'undefined' && returnValue === null) {
                    returnValue = val
                }
            } else if (onNext) {
                const val = await onNext()
                if (typeof val !== 'undefined') {
                    returnValue = val
                }
            }
        }

        const handlers = this.handlers[type] || []
        await runHandler(0)

        return returnValue
    }

    //
    // EVENT REGISTRATION PUBLIC METHODS
    //

     onTurn(handler) {
        return this.on('Turn', handler)
    }

     onMessage(handler) {
        return this.on('Message', handler)
    }

     onCall(handler) {
        return this.on('Call', handler)
    }

     onMessageStatus(
        handler




    ) {
        return this.on(
            'MessageStatus',
            async (context, next) => {
                await handler(
                    context,
                    context['bot.Capability'].activity.channelData
                        .MessageStatus,
                    next
                )
            }
        )
    }

     onCallStatus(handler) {
        return this.on('CallStatus', handler)
    }

     onUnrecognizedActivityType(handler) {
        return this.on('UnrecognizedActivityType', handler)
    }

     onDialog(handler) {
        return this.on('Dialog', handler)
    }

    /**
     * Event pipeline invoked when a sendActivities is called on IopaCarrierContext;
     * it allows for manipulation of the result, pre and post the next() call
     */
    onContextSendActivities(
        handler




    ) {
        return this.on(
            'ContextSendActivities',
            async (context, { activities }, next) => {
                await handler(context, activities, next)
            }
        )
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier/src/carrier-methods.ts
/* eslint-disable @typescript-eslint/camelcase */
















const URI_CARRIER_PATH = '/client/v1.0.0/carrier/api'

class carrier_methods_CarrierWithEventsAndMethods
    extends carrier_events_CarrierWithEvents
     {
    constructor(app) {
        super(app)

        app.carrier.onCall(
            async (
                context,
                next
            ) => {
                if (
                    context['bot.Capability'].activity.channelData.Direction ===
                    'outbound-api'
                ) {
                    const subtype = context['iopa.Url'].searchParams.get(
                        'subtype'
                    )

                    switch (subtype) {
                        case 'callback_dial':
                            return this.onCallBackDialCall(context, next)
                        default:
                            return next()
                    }
                }
                return next()
            }
        )
    }

    cleanNumber(number) {
        let result = number.replace(/[^\d+]+/g, '')
        result = result.replace(/^00/, '+')
        if (result.match(/^1/)) {
            result = `+${result}`
        }
        if (!result.match(/^\+/)) {
            result = result.length > 7 ? `+1${result}` : result
        }
        result = result.replace(/^\+/, '')
        return result
    }

    beautifyNumber(number) {
        const result = number.replace(/^\+/, '')
        if (!result.startsWith('1') || result.length !== 11) {
            return number
        }

        return `+${result.substr(0, 1)} (${result.substr(
            1,
            3
        )}) ${result.substr(4, 3)}-${result.substr(7, 4)}`
    }

    getBaseUrl(context) {
        return `${context['iopa.Url'].protocol}//${context['iopa.Url'].hostname}${URI_CARRIER_PATH}`
    }

    getBaseUrlPath() {
        return URI_CARRIER_PATH
    }

    async getRecordingUrl(
        provider,
        relative_url
    ) {
        const config = this.providerConfig[provider]

        const response = (await this.fetchWithCredentials(
            config,
            config.baseUrl + relative_url,
            {
                redirect: 'manual',
                method: 'HEAD',
                headers: {},
            }
        )) 

        const location = response.headers.get('Location') 

        return location
    }

    async getAvailablePhoneNumbers(
        provider,
        areacode,
        locality
    ) {
        const config = this.providerConfig[provider]
        const client = this.createCarrierApiClient(config)
        const { accountSid } = config

        const query = {
            AreaCode: areacode,
            SmsEnabled: 'true',
            VoiceEnabled: 'true',
            PageSize: '20',
            Page: '0',
        } 

        if (locality && provider !== 'signalwire') {
            query.InLocality = locality
        }

        const result = await client.accountsAccountSidAvailablePhoneNumbersIsoCountryCodeLocalmediaTypeExtensionGet(
            accountSid,
            'US',
            '.json',
            {
                query,
            }
        )

        return result 
    }

    async purchaseIncomingPhoneNumber(
        provider,
        phone_number
    ) {
        try {
            const config = this.providerConfig[provider]
            const client = this.createCarrierApiClient(config)
            const { accountSid } = config

            const params = new url["URLSearchParams"]() 
            params.append('PhoneNumber', phone_number)
            if (provider !== 'signalwire') {
                params.append('AddressSid', config.addressSid)
            }
            params.append(
                'SmsApplicationSid',
                config.carrierCallbackApplicationId
            )
            params.append(
                'VoiceApplicationSid',
                config.carrierCallbackApplicationId
            )

            const result = await client.accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionPost(
                accountSid,
                '.json',
                {
                    headers: {
                        'content-type': 'application/x-www-form-urlencoded',
                    },
                    body: params,
                }
            )

            const response = (await result.json()) 

            return response
        } catch (ex) {
            console.error(ex)
            return null
        }
    }

    async getIncomingPhoneNumber(
        provider,
        phone_number
    ) {
        try {
            const config = this.providerConfig[provider]
            const client = this.createCarrierApiClient(config)
            const { accountSid } = config

            const response = await client.accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionGet(
                accountSid,
                '.json',
                {
                    query: {
                        PhoneNumber: phone_number,
                    },
                }
            )

            if (response.incoming_phone_numbers.length === 1) {
                return response.incoming_phone_numbers[0]
            }
            return null
        } catch (ex) {
            console.log(ex)
            return null
        }
    }

    async updateIncomingPhoneNumber(
        provider,
        sid,
        patch
    ) {
        const config = this.providerConfig[provider]
        const client = this.createCarrierApiClient(config)
        const { accountSid } = config

        const params = new url["URLSearchParams"]() 
        params.append('FriendlyName', patch.friendly_name)
        if (provider !== 'signalwire') {
            params.append('AddressSid', config.addressSid)
        }
        params.append('SmsApplicationSid', config.carrierCallbackApplicationId)
        params.append(
            'VoiceApplicationSid',
            config.carrierCallbackApplicationId
        )

        const response = await client.accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPost(
            accountSid,
            '.json',
            sid,
            {
                headers: {
                    'content-type': 'application/x-www-form-urlencoded',
                },
                body: params,
            }
        )

        return response
    }

    async migrateIncomingPhoneNumber(provider, sid) {
        if (provider !== 'twilio') {
            throw new Error('migration only supported for twilio')
        }

        const config = this.providerConfig[provider]
        const client = this.createCarrierApiClient(config)
        const { accountSid, migrateToAccountSid } = config

        const params = new url["URLSearchParams"]() 
        params.append('AccountSid', migrateToAccountSid)
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore
        if (provider !== 'signalwire') {
            params.append('AddressSid', config.migrateToAddressSid)
        }

        const response = await client.accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPost(
            accountSid,
            '.json',
            sid,
            {
                headers: {
                    'content-type': 'application/x-www-form-urlencoded',
                },
                body: params,
            }
        )

        return response
    }

     async clickToCall({
        provider,
        baseUrl,
        physicalNumber,
        virtualNumber,
        recipientNumber,
    }





) {
        console.log(
            `[iopa-carrier] Click to call ${JSON.stringify({
                provider,
                physicalNumber,
                virtualNumber,
                recipientNumber,
                baseUrl,
            })}`
        )

        const config = this.providerConfig[provider]
        const client = this.createCarrierApiClient(config)
        const { accountSid } = config

        const subtype = 'callback_dial'
        const { appId } = this.providerConfig[
            provider
        ].inboundCredentialsProvider
        const callback_token = await this.providerConfig[
            provider
        ].inboundCredentialsProvider.getAppSecret(appId)

        const url_callback = `${baseUrl}?provider=${provider}&type=${'voice'}&callback_token=${callback_token}&subtype=${subtype}&value=${recipientNumber.replace(
            /^\+/,
            ''
        )}`
        const url_status_callback = `${baseUrl}?provider=${provider}&type=${'voice_status'}&callback_token=${callback_token}&recipient=${recipientNumber.replace(
            /^\+/,
            ''
        )}`

        const params = new url["URLSearchParams"]() 
        params.append('To', physicalNumber)
        params.append('From', virtualNumber)
        params.append('Url', url_callback)
        params.append('StatusCallback', url_status_callback)

        const response = await client.accountsAccountSidCallsmediaTypeExtensionPost(
            accountSid,
            '.json',
            {
                body: params,
            }
        )
    }

     async onCallBackDialCall(
        context,
        next
    ) {
        const toNumber = `+${context['iopa.Url'].searchParams.get('value')}`
        console.log(`adding call to ${toNumber}}`)
        context.response.end(
            `<?xml version="1.0" encoding="UTF-8"?>
    <Response>
        <Say voice="alice" language="en-GB">Connecting you now</Say>
        <Dial timeout="30">
        <Number>${toNumber}</Number>
        </Dial>
        <Hangup />
    </Response>`,
            { status: 200 }
        )
        return next()
    }

     createSmsConversation(
        provider,
        fromNumber,
        toNumber,
        logic
    ) {
        const config = this.providerConfig[provider]
        const { accountSid } = config

        const conversationReference = {
            user: { id: toNumber },
            bot: { id: fromNumber },
            conversation: { tenantId: accountSid },
            channelId: provider,
            serviceUrl: config.serviceUrl,
        }

        return this.createConversation(conversationReference, logic)
    }

    /** Returns the conversation reference for an activity  */
     getConversationReference(
        activity
    ) {
        return {
            activityId: activity.id,
            user: shallowCopy(activity.from),
            bot: shallowCopy(activity.recipient),
            conversation: shallowCopy(activity.conversation),
            channelId: activity.channelId,
            serviceUrl: activity.serviceUrl,
        }
    }

    /**  Updates an activity with the delivery information from a conversation reference.     */
     applyConversationReference(
        activity,
        reference,
        isIncoming = false
    ) {
        activity.channelId = reference.channelId
        activity.serviceUrl = reference.serviceUrl
        activity.conversation = reference.conversation
        if (isIncoming) {
            activity.from = reference.user
            activity.recipient = reference.bot
            if (reference.activityId) {
                activity.id = reference.activityId
            }
        } else {
            activity.from = reference.bot
            activity.recipient = reference.user
            if (reference.activityId) {
                activity.replyToId = reference.activityId
            }
        }

        return activity
    }

    /** Create a ConversationReference based on an outgoing Activity's ResourceResponse  */
     getReplyConversationReference(
        activity,
        reply
    ) {
        const reference = this.getConversationReference(
            activity
        )

        // Update the reference with the new outgoing Activity's id.
        reference.activityId = reply.id

        return reference
    }

    /** An asynchronous method that resumes a conversation with a user, possibly after some time has gone by. */
     async continueConversation(
        reference,
        logic
    ) {
        const request = this.applyConversationReference(
            { type: dist["ActivityTypes"].Event, name: 'continueConversation' },
            reference,
            true
        )

        const context = this.createContext(request)

        try {
            await this.app.invoke(context)
            await logic(context)
        } catch (err) {
            if (this.onTurnError) {
                await this.onTurnError(context, err)
            } else {
                throw err
            }
        }
    }

    /** An asynchronous method that creates and starts a conversation with a user on a channel.  */
     async createConversation(
        reference,
        logic
    ) {
        if (!reference.serviceUrl) {
            throw new Error(
                `ActivityHelpers.createConversation(): missing serviceUrl.`
            )
        }

        // Initialize request and copy over new conversation ID and updated serviceUrl.
        const request = this.applyConversationReference(
            { type: dist["ActivityTypes"].Event, name: 'createConversation' },
            reference,
            true
        )

        const context = this.createContext(request)

        try {
            await logic(context)
        } catch (err) {
            if (this.onTurnError) {
                await this.onTurnError(context, err)
            } else {
                throw err
            }
        }
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier/src/carrier.ts
/* concated harmony reexport Carrier */__webpack_require__.d(__webpack_exports__, "a", function() { return carrier_methods_CarrierWithEventsAndMethods; });
/* concated harmony reexport URN_CARRIER */__webpack_require__.d(__webpack_exports__, "b", function() { return URN_CARRIER; });




/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

// Packages
var retrier = __webpack_require__(225);

function retry(fn, opts) {
  function run(resolve, reject) {
    var options = opts || {};

    // Default `randomize` to true
    if (!('randomize' in options)) {
      options.randomize = true;
    }

    var op = retrier.operation(options);

    // We allow the user to abort retrying
    // this makes sense in the cases where
    // knowledge is obtained that retrying
    // would be futile (e.g.: auth errors)

    function bail(err) {
      reject(err || new Error('Aborted'));
    }

    function onError(err, num) {
      if (err.bail) {
        bail(err);
        return;
      }

      if (!op.retry(err)) {
        reject(op.mainError());
      } else if (options.onRetry) {
        options.onRetry(err, num);
      }
    }

    function runAttempt(num) {
      var val;

      try {
        val = fn(bail, num);
      } catch (err) {
        onError(err, num);
        return;
      }

      Promise.resolve(val)
        .then(resolve)
        .catch(function catchIt(err) {
          onError(err, num);
        });
    }

    op.attempt(runAttempt);
  }

  return new Promise(run);
}

module.exports = retry;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable
/**
 * Microsoft Bot Token API - V3.1
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: token
 * Contact: botframework@microsoft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(355), exports);
__exportStar(__webpack_require__(356), exports);
//# sourceMappingURL=index.js.map

/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return toAbsoluteUrl; });
function toAbsoluteUrl(relative, base) {
  const stack = base.replace(/\/$/, '').split('/')
  const parts = relative.split('/')

  if (parts[0] === 'local') {
    return relative
  }

  if (parts[0] === '' && parts[1] === 'local') {
    return relative.replace(/^\//, '')
  }

  for (let i = 0; i < parts.length; i++) {
    if (parts[i] === '.') {
      // eslint-disable-next-line no-continue
      continue
    }
    if (parts[i] === '..') {
      stack.pop()
    } else {
      stack.push(parts[i])
    }
  }
  return stack.join('/')
}


/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(118);
/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_app__WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */
/* harmony import */ var _cancel_token__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(119);
/* harmony import */ var _cancel_token__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_cancel_token__WEBPACK_IMPORTED_MODULE_1__);
/* unused harmony reexport * */
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(120);
/* unused harmony reexport * */
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(121);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_context__WEBPACK_IMPORTED_MODULE_3__);
/* unused harmony reexport * */
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(122);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_events__WEBPACK_IMPORTED_MODULE_4__);
/* unused harmony reexport * */
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(123);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_map__WEBPACK_IMPORTED_MODULE_5__);
/* unused harmony reexport * */
/* harmony import */ var _middleware__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(124);
/* harmony import */ var _middleware__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_middleware__WEBPACK_IMPORTED_MODULE_6__);
/* unused harmony reexport * */
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(125);
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_model__WEBPACK_IMPORTED_MODULE_7__);
/* unused harmony reexport * */
/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(126);
/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_plugin__WEBPACK_IMPORTED_MODULE_8__);
/* unused harmony reexport * */
/* harmony import */ var _url__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(127);
/* harmony import */ var _url__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_url__WEBPACK_IMPORTED_MODULE_9__);
/* unused harmony reexport * */
/*
 * Internet Open Protocol Abstraction (IOPA)
 * Copyright (c) 2016 - 2020 Internet Open Protocol Alliance
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













/***/ }),
/* 118 */
/***/ (function(module, exports) {
























































































































































































/***/ }),
/* 119 */
/***/ (function(module, exports) {

/*
 * Internet Open Protocol Abstraction (IOPA)
 * Copyright (c) 2016 - 2020 Internet Open Protocol Alliance
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

















/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";






































/***/ }),
/* 121 */
/***/ (function(module, exports) {































//
// CONTEXT
//


















































































































































































































































































































































































































































































/***/ }),
/* 122 */
/***/ (function(module, exports) {

/*
 * Internet Open Protocol Abstraction (IOPA)
 * Copyright (c) 2016 - 2020 Internet Open Protocol Alliance
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















/***/ }),
/* 123 */
/***/ (function(module, exports) {

/*
 * Internet Open Protocol Abstraction (IOPA)
 * Copyright (c) 2016 - 2020 Internet Open Protocol Alliance
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








































/***/ }),
/* 124 */
/***/ (function(module, exports) {
















































/***/ }),
/* 125 */
/***/ (function(module, exports) {









































































































































































/***/ }),
/* 126 */
/***/ (function(module, exports) {





/** Plugin Type I Interface used by plugin loader */

















































/***/ }),
/* 127 */
/***/ (function(module, exports) {

/*
 * Internet Open Protocol Abstraction (IOPA)
 * Copyright (c) 2016 - 2020 Internet Open Protocol Alliance
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






















































/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(129);
/* harmony import */ var _algorithm__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_algorithm__WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */
/* harmony import */ var _jwe_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(130);
/* harmony import */ var _jwe_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jwe_types__WEBPACK_IMPORTED_MODULE_1__);
/* unused harmony reexport * */
/* harmony import */ var _jwk_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(131);
/* harmony import */ var _jwk_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jwk_types__WEBPACK_IMPORTED_MODULE_2__);
/* unused harmony reexport * */
/* harmony import */ var _jws_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(132);
/* harmony import */ var _jws_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jws_types__WEBPACK_IMPORTED_MODULE_3__);
/* unused harmony reexport * */
/* harmony import */ var _jwt_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(133);
/* harmony import */ var _jwt_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jwt_types__WEBPACK_IMPORTED_MODULE_4__);
/* unused harmony reexport * */



// export * from './jwk-store-types'




/***/ }),
/* 129 */
/***/ (function(module, exports) {

























































/***/ }),
/* 130 */
/***/ (function(module, exports) {

//
// JsonWebEncryption (JWE) Serialization Syntax
// https://tools.ietf.org/html/rfc7516#section-7.2.1
//












































































/***/ }),
/* 131 */
/***/ (function(module, exports) {





















































































































































































































































































































































































































































































/***/ }),
/* 132 */
/***/ (function(module, exports) {






































































































































































/***/ }),
/* 133 */
/***/ (function(module, exports) {





//
// JsonWebToken (JWT) Token Types
//


























































































































































































/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _jwk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32);
/* harmony import */ var _jws__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
 var _class;












const JsonWebToken = (_class = class {
  static __initStatic() {this.parser = _jws__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].createParser({})}

   static setOptions(options) {
    this.parser = _jws__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].createParser(options)
  }

  /**
   * Sign the given payload asynchronously into a JSON Web Token String
   * @param payload - Payload to sign, could be an literal, buffer or string
   * @param secretOrPrivateKey - Either the secret for HMAC algorithms, or the PEM encoded private key for RSA and ECDSA.
   * @param [options] - Options for the signature
   * @returns A promise providing JSON Web Token string
   */
   static async signAsync(
    payload,
    secretOrPrivateKey,
    options
  ) {
    const iopaEdgeKey = await _jwk__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].asIopaEdgeKey(secretOrPrivateKey)
    const signer = _jws__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].createSigner(iopaEdgeKey)
    return signer.sign(payload, options)
  }

  /**
   * Create a signer that signs payloads using a given key
   * @param payload - Payload to sign, could be an literal, buffer or string
   * @param secretOrPrivateKey - Either the secret for HMAC algorithms, or the PEM encoded private key for RSA and ECDSA.
   * @param [options] - Options for the signature
   * @returns A promise providing JSON Web Token string
   */
   static async createSigner(
    secretOrPrivateKey
  ) {
    const iopaEdgeKey = await _jwk__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].asIopaEdgeKey(secretOrPrivateKey)
    const signer = _jws__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].createSigner(iopaEdgeKey)
    return signer
  }

  /**
   * Adds a key to the parser keystore used or signature verification;  optional as without it
   * we follow the public key of the issuer
   * @param secretOrPrivatePublicKeyPiar - Either the secret for HMAC algorithms, or the PEM encoded private key for RSA and ECDSA.
   * @returns - Promise returning the decoded token
   */
   static async addParserKey(
    secretOrPrivateKey
  ) {
    const iopaEdgeKey = await _jwk__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].asIopaEdgeKey(secretOrPrivateKey)
    this.parser.addKey(iopaEdgeKey)
  }

  /**
   * Asynchronously verify given token using a secret or a public key to get a decoded token
   * @param token - the JWT string to verify
   * @param secretOrPublicKey - Either the secret for HMAC algorithms, or the PEM encoded public key for RSA and ECDSA.
   * @returns - Promise returning the decoded token
   */
   static verifyAsync(
    token,
    options
  ) {
    return this.parser.verify(token, options)
  }

  /*
   * Returns the decoded payload without verifying if the signature is valid.
   * @param token - JWT string to decode
   * @param [options] - Options for decoding
   * @returns The decoded Token
   */
   static decode(
    token,
    options
  ) {
    return this.parser.decode(token, options)
  }
}, _class.__initStatic(), _class)

/* harmony default export */ __webpack_exports__["a"] = (JsonWebToken);


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var jws = __webpack_require__(87);

module.exports = function (jwt, options) {
  options = options || {};
  var decoded = jws.decode(jwt, options);
  if (!decoded) { return null; }
  var payload = decoded.payload;

  //try parse the payload
  if(typeof payload === 'string') {
    try {
      var obj = JSON.parse(payload);
      if(obj !== null && typeof obj === 'object') {
        payload = obj;
      }
    } catch (e) { }
  }

  //return header if `complete` option is enabled.  header includes claims
  //such as `kid` and `alg` used to select the key within a JWKS needed to
  //verify the signature
  if (options.complete === true) {
    return {
      header: decoded.header,
      payload: payload,
      signature: decoded.signature
    };
  }
  return payload;
};


/***/ }),
/* 136 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/*global module, process*/
var Buffer = __webpack_require__(57).Buffer;
var Stream = __webpack_require__(67);
var util = __webpack_require__(69);

function DataStream(data) {
  this.buffer = null;
  this.writable = true;
  this.readable = true;

  // No input
  if (!data) {
    this.buffer = Buffer.alloc(0);
    return this;
  }

  // Stream
  if (typeof data.pipe === 'function') {
    this.buffer = Buffer.alloc(0);
    data.pipe(this);
    return this;
  }

  // Buffer or String
  // or Object (assumedly a passworded key)
  if (data.length || typeof data === 'object') {
    this.buffer = data;
    this.writable = false;
    process.nextTick(function () {
      this.emit('end', data);
      this.readable = false;
      this.emit('close');
    }.bind(this));
    return this;
  }

  throw new TypeError('Unexpected data type ('+ typeof data + ')');
}
util.inherits(DataStream, Stream);

DataStream.prototype.write = function write(data) {
  this.buffer = Buffer.concat([this.buffer, Buffer.from(data)]);
  this.emit('data', data);
};

DataStream.prototype.end = function end(data) {
  if (data)
    this.write(data);
  this.emit('end', data);
  this.emit('close');
  this.writable = false;
  this.readable = false;
};

module.exports = DataStream;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(68);
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(136);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(37).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(139);
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(6).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(__webpack_require__(58));
util.inherits = __webpack_require__(3);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(234);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(235);
var destroyImpl = __webpack_require__(140);
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(38);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(39).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(38);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(39).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16), __webpack_require__(10)))

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(37).EventEmitter;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(68);
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(38);

/*<replacement>*/
var util = Object.create(__webpack_require__(58));
util.inherits = __webpack_require__(3);
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var bufferEqual = __webpack_require__(246);
var Buffer = __webpack_require__(57).Buffer;
var crypto = __webpack_require__(247);
var formatEcdsa = __webpack_require__(335);
var util = __webpack_require__(69);

var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".'
var MSG_INVALID_SECRET = 'secret must be a string or buffer';
var MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';
var MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';

var supportsKeyObjects = typeof crypto.createPublicKey === 'function';
if (supportsKeyObjects) {
  MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';
  MSG_INVALID_SECRET += 'or a KeyObject';
}

function checkIsPublicKey(key) {
  if (Buffer.isBuffer(key)) {
    return;
  }

  if (typeof key === 'string') {
    return;
  }

  if (!supportsKeyObjects) {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }

  if (typeof key !== 'object') {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }

  if (typeof key.type !== 'string') {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }

  if (typeof key.asymmetricKeyType !== 'string') {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }

  if (typeof key.export !== 'function') {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }
};

function checkIsPrivateKey(key) {
  if (Buffer.isBuffer(key)) {
    return;
  }

  if (typeof key === 'string') {
    return;
  }

  if (typeof key === 'object') {
    return;
  }

  throw typeError(MSG_INVALID_SIGNER_KEY);
};

function checkIsSecretKey(key) {
  if (Buffer.isBuffer(key)) {
    return;
  }

  if (typeof key === 'string') {
    return key;
  }

  if (!supportsKeyObjects) {
    throw typeError(MSG_INVALID_SECRET);
  }

  if (typeof key !== 'object') {
    throw typeError(MSG_INVALID_SECRET);
  }

  if (key.type !== 'secret') {
    throw typeError(MSG_INVALID_SECRET);
  }

  if (typeof key.export !== 'function') {
    throw typeError(MSG_INVALID_SECRET);
  }
}

function fromBase64(base64) {
  return base64
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');
}

function toBase64(base64url) {
  base64url = base64url.toString();

  var padding = 4 - base64url.length % 4;
  if (padding !== 4) {
    for (var i = 0; i < padding; ++i) {
      base64url += '=';
    }
  }

  return base64url
    .replace(/\-/g, '+')
    .replace(/_/g, '/');
}

function typeError(template) {
  var args = [].slice.call(arguments, 1);
  var errMsg = util.format.bind(util, template).apply(null, args);
  return new TypeError(errMsg);
}

function bufferOrString(obj) {
  return Buffer.isBuffer(obj) || typeof obj === 'string';
}

function normalizeInput(thing) {
  if (!bufferOrString(thing))
    thing = JSON.stringify(thing);
  return thing;
}

function createHmacSigner(bits) {
  return function sign(thing, secret) {
    checkIsSecretKey(secret);
    thing = normalizeInput(thing);
    var hmac = crypto.createHmac('sha' + bits, secret);
    var sig = (hmac.update(thing), hmac.digest('base64'))
    return fromBase64(sig);
  }
}

function createHmacVerifier(bits) {
  return function verify(thing, signature, secret) {
    var computedSig = createHmacSigner(bits)(thing, secret);
    return bufferEqual(Buffer.from(signature), Buffer.from(computedSig));
  }
}

function createKeySigner(bits) {
 return function sign(thing, privateKey) {
    checkIsPrivateKey(privateKey);
    thing = normalizeInput(thing);
    // Even though we are specifying "RSA" here, this works with ECDSA
    // keys as well.
    var signer = crypto.createSign('RSA-SHA' + bits);
    var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));
    return fromBase64(sig);
  }
}

function createKeyVerifier(bits) {
  return function verify(thing, signature, publicKey) {
    checkIsPublicKey(publicKey);
    thing = normalizeInput(thing);
    signature = toBase64(signature);
    var verifier = crypto.createVerify('RSA-SHA' + bits);
    verifier.update(thing);
    return verifier.verify(publicKey, signature, 'base64');
  }
}

function createPSSKeySigner(bits) {
  return function sign(thing, privateKey) {
    checkIsPrivateKey(privateKey);
    thing = normalizeInput(thing);
    var signer = crypto.createSign('RSA-SHA' + bits);
    var sig = (signer.update(thing), signer.sign({
      key: privateKey,
      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
    }, 'base64'));
    return fromBase64(sig);
  }
}

function createPSSKeyVerifier(bits) {
  return function verify(thing, signature, publicKey) {
    checkIsPublicKey(publicKey);
    thing = normalizeInput(thing);
    signature = toBase64(signature);
    var verifier = crypto.createVerify('RSA-SHA' + bits);
    verifier.update(thing);
    return verifier.verify({
      key: publicKey,
      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
    }, signature, 'base64');
  }
}

function createECDSASigner(bits) {
  var inner = createKeySigner(bits);
  return function sign() {
    var signature = inner.apply(null, arguments);
    signature = formatEcdsa.derToJose(signature, 'ES' + bits);
    return signature;
  };
}

function createECDSAVerifer(bits) {
  var inner = createKeyVerifier(bits);
  return function verify(thing, signature, publicKey) {
    signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');
    var result = inner(thing, signature, publicKey);
    return result;
  };
}

function createNoneSigner() {
  return function sign() {
    return '';
  }
}

function createNoneVerifier() {
  return function verify(thing, signature) {
    return signature === '';
  }
}

module.exports = function jwa(algorithm) {
  var signerFactories = {
    hs: createHmacSigner,
    rs: createKeySigner,
    ps: createPSSKeySigner,
    es: createECDSASigner,
    none: createNoneSigner,
  }
  var verifierFactories = {
    hs: createHmacVerifier,
    rs: createKeyVerifier,
    ps: createPSSKeyVerifier,
    es: createECDSAVerifer,
    none: createNoneVerifier,
  }
  var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
  if (!match)
    throw typeError(MSG_INVALID_ALGORITHM, algorithm);
  var algo = (match[1] || match[3]).toLowerCase();
  var bits = match[2];

  return {
    sign: signerFactories[algo](bits),
    verify: verifierFactories[algo](bits),
  }
};


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(248).Buffer
var Transform = __webpack_require__(249).Transform
var inherits = __webpack_require__(3)

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __webpack_require__(37).EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(145);
/*</replacement>*/


var Buffer = __webpack_require__(9).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = __webpack_require__(250);

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__(251);

var destroyImpl = __webpack_require__(146);

var _require = __webpack_require__(147),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __webpack_require__(43).codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

__webpack_require__(3)(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(44);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(39).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(44);
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(39).StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(253);
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __webpack_require__(254);
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16), __webpack_require__(10)))

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(37).EventEmitter;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) { // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ERR_INVALID_OPT_VALUE = __webpack_require__(43).codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(90)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(145);
/*</replacement>*/


var Buffer = __webpack_require__(9).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __webpack_require__(146);

var _require = __webpack_require__(147),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __webpack_require__(43).codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

__webpack_require__(3)(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(44);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(44); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16), __webpack_require__(10)))

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var _require$codes = __webpack_require__(43).codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = __webpack_require__(44);

__webpack_require__(3)(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(3)
var Hash = __webpack_require__(45)
var Buffer = __webpack_require__(6).Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(3)
var Hash = __webpack_require__(45)
var Buffer = __webpack_require__(6).Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(3)
var Legacy = __webpack_require__(261)
var Base = __webpack_require__(35)
var Buffer = __webpack_require__(6).Buffer
var md5 = __webpack_require__(153)
var RIPEMD160 = __webpack_require__(93)

var sha = __webpack_require__(94)

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var MD5 = __webpack_require__(91)

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}


/***/ }),
/* 154 */
/***/ (function(module) {

module.exports = {"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}};

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

exports.pbkdf2 = __webpack_require__(263)
exports.pbkdf2Sync = __webpack_require__(158)


/***/ }),
/* 156 */
/***/ (function(module, exports) {

var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var defaultEncoding
/* istanbul ignore next */
if (process.browser) {
  defaultEncoding = 'utf-8'
} else if (process.version) {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
} else {
  defaultEncoding = 'utf-8'
}
module.exports = defaultEncoding

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var md5 = __webpack_require__(153)
var RIPEMD160 = __webpack_require__(93)
var sha = __webpack_require__(94)
var Buffer = __webpack_require__(6).Buffer

var checkParameters = __webpack_require__(156)
var defaultEncoding = __webpack_require__(157)
var toBuffer = __webpack_require__(159)

var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(6).Buffer

module.exports = function (thing, encoding, name) {
  if (Buffer.isBuffer(thing)) {
    return thing
  } else if (typeof thing === 'string') {
    return Buffer.from(thing, encoding)
  } else if (ArrayBuffer.isView(thing)) {
    return Buffer.from(thing.buffer)
  } else {
    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView')
  }
}


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(23);
var inherits = __webpack_require__(3);

var utils = __webpack_require__(160);
var Cipher = __webpack_require__(95);

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(60)
var Buffer = __webpack_require__(6).Buffer
var incr32 = __webpack_require__(163)

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}


/***/ }),
/* 163 */
/***/ (function(module, exports) {

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32


/***/ }),
/* 164 */
/***/ (function(module) {

module.exports = {"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}};

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(70)
var Buffer = __webpack_require__(6).Buffer
var Transform = __webpack_require__(35)
var inherits = __webpack_require__(3)
var GHASH = __webpack_require__(276)
var xor = __webpack_require__(60)
var incr32 = __webpack_require__(163)

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(70)
var Buffer = __webpack_require__(6).Buffer
var Transform = __webpack_require__(35)
var inherits = __webpack_require__(3)

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var randomBytes = __webpack_require__(42);
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = __webpack_require__(168);
var TWENTYFOUR = new BN(24);
var MillerRabin = __webpack_require__(169);
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(280).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)(module)))

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var bn = __webpack_require__(281);
var brorand = __webpack_require__(98);

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __webpack_require__(37).EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(171);
/*</replacement>*/


var Buffer = __webpack_require__(9).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = __webpack_require__(288);

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__(289);

var destroyImpl = __webpack_require__(172);

var _require = __webpack_require__(173),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __webpack_require__(46).codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

__webpack_require__(3)(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(47);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(39).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(47);
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(39).StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(291);
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __webpack_require__(292);
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16), __webpack_require__(10)))

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(37).EventEmitter;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) { // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ERR_INVALID_OPT_VALUE = __webpack_require__(46).codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(90)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(171);
/*</replacement>*/


var Buffer = __webpack_require__(9).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __webpack_require__(172);

var _require = __webpack_require__(173),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __webpack_require__(46).codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

__webpack_require__(3)(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(47);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(47); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16), __webpack_require__(10)))

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var _require$codes = __webpack_require__(46).codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = __webpack_require__(47);

__webpack_require__(3)(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = exports;

curve.base = __webpack_require__(72);
curve.short = __webpack_require__(299);
curve.mont = __webpack_require__(300);
curve.edwards = __webpack_require__(301);


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(27);
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(27);
var common = __webpack_require__(61);
var shaCommon = __webpack_require__(178);
var assert = __webpack_require__(23);

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(27);
var common = __webpack_require__(61);
var assert = __webpack_require__(23);

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const asn1 = exports;

asn1.bignum = __webpack_require__(182);

asn1.define = __webpack_require__(318).define;
asn1.base = __webpack_require__(321);
asn1.constants = __webpack_require__(322);
asn1.decoders = __webpack_require__(185);
asn1.encoders = __webpack_require__(183);


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(317).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)(module)))

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const encoders = exports;

encoders.der = __webpack_require__(184);
encoders.pem = __webpack_require__(319);


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const inherits = __webpack_require__(3);
const Buffer = __webpack_require__(106).Buffer;
const Node = __webpack_require__(107);

// Import DER constants
const der = __webpack_require__(109);

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  Node.call(this, 'der', parent);
}
inherits(DERNode, Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
  primitive,
  cls,
  content) {
  const encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    const header = Buffer.alloc(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  let lenOctets = 1;
  for (let i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  const header = Buffer.alloc(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    const buf = Buffer.alloc(str.length * 2);
    for (let i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s.]+/g);
    for (let i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (let i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  let size = 0;
  for (let i = 0; i < id.length; i++) {
    let ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  const objid = Buffer.alloc(size);
  let offset = objid.length - 1;
  for (let i = id.length - 1; i >= 0; i--) {
    let ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  let str;
  const date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getUTCFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getUTCFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    const numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = Buffer.from(numArray);
  }

  if (Buffer.isBuffer(num)) {
    let size = num.length;
    if (num.length === 0)
      size++;

    const out = Buffer.alloc(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0;
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  let size = 1;
  for (let i = num; i >= 0x100; i >>= 8)
    size++;

  const out = new Array(size);
  for (let i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(Buffer.from(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  const state = this._baseState;
  let i;
  if (state['default'] === null)
    return false;

  const data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  let res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const decoders = exports;

decoders.der = __webpack_require__(186);
decoders.pem = __webpack_require__(320);


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const inherits = __webpack_require__(3);

const bignum = __webpack_require__(182);
const DecoderBuffer = __webpack_require__(62).DecoderBuffer;
const Node = __webpack_require__(107);

// Import DER constants
const der = __webpack_require__(109);

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!DecoderBuffer.isDecoderBuffer(data)) {
    data = new DecoderBuffer(data, options);
  }

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  Node.call(this, 'der', parent);
}
inherits(DERNode, Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  const state = buffer.save();
  const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  const decodedTag = derDecodeTag(buffer,
    'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  let len = derDecodeLen(buffer,
    decodedTag.primitive,
    'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  const state = buffer.save();
  const res = this._skipUntilEnd(
    buffer,
    'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  for (;;) {
    const tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    const len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    let res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len);
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
  options) {
  const result = [];
  while (!buffer.isEmpty()) {
    const possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    const res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    const unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    const raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    let str = '';
    for (let i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    const numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    const printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  let result;
  const identifiers = [];
  let ident = 0;
  let subident = 0;
  while (!buffer.isEmpty()) {
    subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  const first = (identifiers[0] / 40) | 0;
  const second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    let tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  const str = buffer.raw().toString();

  let year;
  let mon;
  let day;
  let hour;
  let min;
  let sec;
  if (tag === 'gentime') {
    year = str.slice(0, 4) | 0;
    mon = str.slice(4, 6) | 0;
    day = str.slice(6, 8) | 0;
    hour = str.slice(8, 10) | 0;
    min = str.slice(10, 12) | 0;
    sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    year = str.slice(0, 2) | 0;
    mon = str.slice(2, 4) | 0;
    day = str.slice(4, 6) | 0;
    hour = str.slice(6, 8) | 0;
    min = str.slice(8, 10) | 0;
    sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull() {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  const res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  const raw = buffer.raw();
  let res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  let tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  const cls = der.tagClass[tag >> 6];
  const primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    let oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  const tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  let len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  const num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (let i = 0; i < num; i++) {
    len <<= 8;
    const j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}


/***/ }),
/* 187 */
/***/ (function(module) {

module.exports = {"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"};

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var createHash = __webpack_require__(59)
var Buffer = __webpack_require__(6).Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}


/***/ }),
/* 189 */
/***/ (function(module, exports) {

module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var BN = __webpack_require__(110)
var Buffer = __webpack_require__(6).Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

/*global module*/
var Buffer = __webpack_require__(9).Buffer;

module.exports = function toString(obj) {
  if (typeof obj === 'string')
    return obj;
  if (typeof obj === 'number' || Buffer.isBuffer(obj))
    return obj.toString();
  return JSON.stringify(obj);
};


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var JsonWebTokenError = __webpack_require__(74);

var NotBeforeError = function (message, date) {
  JsonWebTokenError.call(this, message);
  this.name = 'NotBeforeError';
  this.date = date;
};

NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);

NotBeforeError.prototype.constructor = NotBeforeError;

module.exports = NotBeforeError;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var JsonWebTokenError = __webpack_require__(74);

var TokenExpiredError = function (message, expiredAt) {
  JsonWebTokenError.call(this, message);
  this.name = 'TokenExpiredError';
  this.expiredAt = expiredAt;
};

TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);

TokenExpiredError.prototype.constructor = TokenExpiredError;

module.exports = TokenExpiredError;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var ms = __webpack_require__(339);

module.exports = function (time, iat) {
  var timestamp = iat || Math.floor(Date.now() / 1000);

  if (typeof time === 'string') {
    var milliseconds = ms(time);
    if (typeof milliseconds === 'undefined') {
      return;
    }
    return Math.floor(timestamp + milliseconds / 1000);
  } else if (typeof time === 'number') {
    return timestamp + time;
  } else {
    return;
  }

};

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var semver = __webpack_require__(340);

module.exports = semver.satisfies(process.version, '^6.12.0 || >=8.0.0');

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 196 */
/***/ (function(module, exports) {

// dummy unused file for future constants use


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Twilio
 * Enabling phones, VoIP, and messaging to be embedded into web, desktop, and mobile software.
 *
 * OpenAPI spec version: 2010-04-01
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultApi = exports.DefaultApiFactory = exports.DefaultApiFp = exports.DefaultApiFetchParamCreator = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = void 0;
const url = __webpack_require__(12);
const portableFetch = __webpack_require__(41);
const BASE_PATH = 'https://api.twilio.com/2010-04-01'.replace(/\/+$/, '');
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|',
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, fetch = portableFetch) {
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
exports.RequiredError = RequiredError;
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
const DefaultApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Delete this application.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ApplicationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsApplicationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, ApplicationSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidApplicationsApplicationSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidApplicationsApplicationSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'ApplicationSid' is not null or undefined
            if (ApplicationSid === null || ApplicationSid === undefined) {
                throw new RequiredError('ApplicationSid', 'Required parameter ApplicationSid was null or undefined when calling accountsAccountSidApplicationsApplicationSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Applications/{ApplicationSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'ApplicationSid'}}`, encodeURIComponent(String(ApplicationSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application instance resource.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ApplicationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsApplicationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ApplicationSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidApplicationsApplicationSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidApplicationsApplicationSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'ApplicationSid' is not null or undefined
            if (ApplicationSid === null || ApplicationSid === undefined) {
                throw new RequiredError('ApplicationSid', 'Required parameter ApplicationSid was null or undefined when calling accountsAccountSidApplicationsApplicationSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Applications/{ApplicationSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'ApplicationSid'}}`, encodeURIComponent(String(ApplicationSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tries to update the application's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ApplicationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsApplicationSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ApplicationSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidApplicationsApplicationSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidApplicationsApplicationSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'ApplicationSid' is not null or undefined
            if (ApplicationSid === null || ApplicationSid === undefined) {
                throw new RequiredError('ApplicationSid', 'Required parameter ApplicationSid was null or undefined when calling accountsAccountSidApplicationsApplicationSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Applications/{ApplicationSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'ApplicationSid'}}`, encodeURIComponent(String(ApplicationSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Application resource representations, each representing an application within your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidApplicationsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidApplicationsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Applications{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new application within your account.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidApplicationsmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidApplicationsmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Applications{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the properties of the authorized application.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ConnectAppSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAuthorizedConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidAuthorizedConnectAppsConnectAppSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidAuthorizedConnectAppsConnectAppSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'ConnectAppSid' is not null or undefined
            if (ConnectAppSid === null || ConnectAppSid === undefined) {
                throw new RequiredError('ConnectAppSid', 'Required parameter ConnectAppSid was null or undefined when calling accountsAccountSidAuthorizedConnectAppsConnectAppSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/AuthorizedConnectApps/{ConnectAppSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'ConnectAppSid'}}`, encodeURIComponent(String(ConnectAppSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Connect App resource representations, each representing a Connect App you've authorized to access your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAuthorizedConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidAuthorizedConnectAppsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidAuthorizedConnectAppsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/AuthorizedConnectApps{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of local AvailablePhoneNumber resource representations that match the specified filters, each representing a phone number tha is currently available for provisioning within your account.
         * @param {string} AccountSid
         * @param {string} IsoCountryCode ISO 3166-1 alpha-2.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAvailablePhoneNumbersIsoCountryCodeLocalmediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidAvailablePhoneNumbersIsoCountryCodeLocalmediaTypeExtensionGet.');
            }
            // verify required parameter 'IsoCountryCode' is not null or undefined
            if (IsoCountryCode === null || IsoCountryCode === undefined) {
                throw new RequiredError('IsoCountryCode', 'Required parameter IsoCountryCode was null or undefined when calling accountsAccountSidAvailablePhoneNumbersIsoCountryCodeLocalmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidAvailablePhoneNumbersIsoCountryCodeLocalmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/AvailablePhoneNumbers/{IsoCountryCode}/Local{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'IsoCountryCode'}}`, encodeURIComponent(String(IsoCountryCode)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of mobile AvailablePhoneNumber resource representations that match the specified filters, each representing a phone number that is currently available for provisioning within your account.
         * @param {string} AccountSid
         * @param {string} IsoCountryCode ISO 3166-1 alpha-2.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAvailablePhoneNumbersIsoCountryCodeMobilemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidAvailablePhoneNumbersIsoCountryCodeMobilemediaTypeExtensionGet.');
            }
            // verify required parameter 'IsoCountryCode' is not null or undefined
            if (IsoCountryCode === null || IsoCountryCode === undefined) {
                throw new RequiredError('IsoCountryCode', 'Required parameter IsoCountryCode was null or undefined when calling accountsAccountSidAvailablePhoneNumbersIsoCountryCodeMobilemediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidAvailablePhoneNumbersIsoCountryCodeMobilemediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/AvailablePhoneNumbers/{IsoCountryCode}/Mobile{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'IsoCountryCode'}}`, encodeURIComponent(String(IsoCountryCode)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of toll-free AvailablePhoneNumber elements that match the specified filters, each representing a phone number that is currently available for provisioning within your account. To provision an available phone number, POST the number to the IncomingPhoneNumbers resource.
         * @param {string} AccountSid
         * @param {string} IsoCountryCode ISO 3166-1 alpha-2.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAvailablePhoneNumbersIsoCountryCodeTollFreemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidAvailablePhoneNumbersIsoCountryCodeTollFreemediaTypeExtensionGet.');
            }
            // verify required parameter 'IsoCountryCode' is not null or undefined
            if (IsoCountryCode === null || IsoCountryCode === undefined) {
                throw new RequiredError('IsoCountryCode', 'Required parameter IsoCountryCode was null or undefined when calling accountsAccountSidAvailablePhoneNumbersIsoCountryCodeTollFreemediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidAvailablePhoneNumbersIsoCountryCodeTollFreemediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/AvailablePhoneNumbers/{IsoCountryCode}/TollFree{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'IsoCountryCode'}}`, encodeURIComponent(String(IsoCountryCode)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all AvailablePhoneNumber subresources for your account by ISO Country. For full information about our phone number support, see our Phone Number CSV (http://www.twilio.com/resources/rates/international-phone-number-rates.csv).
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAvailablePhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidAvailablePhoneNumbersmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidAvailablePhoneNumbersmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/AvailablePhoneNumbers{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of notifications generated for an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {string} CallSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsCallSidNotificationsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidCallsCallSidNotificationsmediaTypeExtensionGet.');
            }
            // verify required parameter 'CallSid' is not null or undefined
            if (CallSid === null || CallSid === undefined) {
                throw new RequiredError('CallSid', 'Required parameter CallSid was null or undefined when calling accountsAccountSidCallsCallSidNotificationsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidCallsCallSidNotificationsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Calls/{CallSid}/Notifications{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'CallSid'}}`, encodeURIComponent(String(CallSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Recording resource representations, each representing a recording generated during the course of a phone call.
         * @param {string} AccountSid
         * @param {string} CallSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsCallSidRecordingsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidCallsCallSidRecordingsmediaTypeExtensionGet.');
            }
            // verify required parameter 'CallSid' is not null or undefined
            if (CallSid === null || CallSid === undefined) {
                throw new RequiredError('CallSid', 'Required parameter CallSid was null or undefined when calling accountsAccountSidCallsCallSidRecordingsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidCallsCallSidRecordingsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Calls/{CallSid}/Recordings{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'CallSid'}}`, encodeURIComponent(String(CallSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the single Call resource identified by {CallSid}.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsCallSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CallSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidCallsCallSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidCallsCallSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'CallSid' is not null or undefined
            if (CallSid === null || CallSid === undefined) {
                throw new RequiredError('CallSid', 'Required parameter CallSid was null or undefined when calling accountsAccountSidCallsCallSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Calls/{CallSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CallSid'}}`, encodeURIComponent(String(CallSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a phone call.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsCallSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CallSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidCallsCallSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidCallsCallSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'CallSid' is not null or undefined
            if (CallSid === null || CallSid === undefined) {
                throw new RequiredError('CallSid', 'Required parameter CallSid was null or undefined when calling accountsAccountSidCallsCallSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Calls/{CallSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CallSid'}}`, encodeURIComponent(String(CallSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of phone calls made to and from the account identified by {AccountSid}.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidCallsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidCallsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Calls{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To make a call, make an HTTP POST request. Initiate a new phone call.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidCallsmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidCallsmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Calls{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kick this participant from the conference.
         * @param {string} AccountSid
         * @param {string} ConferenceSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionDelete(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'ConferenceSid' is not null or undefined
            if (ConferenceSid === null || ConferenceSid === undefined) {
                throw new RequiredError('ConferenceSid', 'Required parameter ConferenceSid was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'CallSid' is not null or undefined
            if (CallSid === null || CallSid === undefined) {
                throw new RequiredError('CallSid', 'Required parameter CallSid was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'ConferenceSid'}}`, encodeURIComponent(String(ConferenceSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CallSid'}}`, encodeURIComponent(String(CallSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a representation of this participant.
         * @param {string} AccountSid
         * @param {string} ConferenceSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'ConferenceSid' is not null or undefined
            if (ConferenceSid === null || ConferenceSid === undefined) {
                throw new RequiredError('ConferenceSid', 'Required parameter ConferenceSid was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'CallSid' is not null or undefined
            if (CallSid === null || CallSid === undefined) {
                throw new RequiredError('CallSid', 'Required parameter CallSid was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'ConferenceSid'}}`, encodeURIComponent(String(ConferenceSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CallSid'}}`, encodeURIComponent(String(CallSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the status of a participant.
         * @param {string} AccountSid
         * @param {string} ConferenceSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionPost(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'ConferenceSid' is not null or undefined
            if (ConferenceSid === null || ConferenceSid === undefined) {
                throw new RequiredError('ConferenceSid', 'Required parameter ConferenceSid was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'CallSid' is not null or undefined
            if (CallSid === null || CallSid === undefined) {
                throw new RequiredError('CallSid', 'Required parameter CallSid was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'ConferenceSid'}}`, encodeURIComponent(String(ConferenceSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CallSid'}}`, encodeURIComponent(String(CallSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of participants in the conference identified by {ConferenceSid}.
         * @param {string} AccountSid
         * @param {string} ConferenceSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidParticipantsmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsmediaTypeExtensionGet.');
            }
            // verify required parameter 'ConferenceSid' is not null or undefined
            if (ConferenceSid === null || ConferenceSid === undefined) {
                throw new RequiredError('ConferenceSid', 'Required parameter ConferenceSid was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidConferencesConferenceSidParticipantsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'ConferenceSid'}}`, encodeURIComponent(String(ConferenceSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a representation of the conference identified by {ConferenceSid}.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ConferenceSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConferenceSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidConferencesConferenceSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidConferencesConferenceSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'ConferenceSid' is not null or undefined
            if (ConferenceSid === null || ConferenceSid === undefined) {
                throw new RequiredError('ConferenceSid', 'Required parameter ConferenceSid was null or undefined when calling accountsAccountSidConferencesConferenceSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Conferences/{ConferenceSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'ConferenceSid'}}`, encodeURIComponent(String(ConferenceSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of conferences within an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidConferencesmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidConferencesmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Conferences{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the properties of a Connect App.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ConnectAppSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'ConnectAppSid' is not null or undefined
            if (ConnectAppSid === null || ConnectAppSid === undefined) {
                throw new RequiredError('ConnectAppSid', 'Required parameter ConnectAppSid was null or undefined when calling accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/ConnectApps/{ConnectAppSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'ConnectAppSid'}}`, encodeURIComponent(String(ConnectAppSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tries to update the Connect App's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ConnectAppSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ConnectAppSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'ConnectAppSid' is not null or undefined
            if (ConnectAppSid === null || ConnectAppSid === undefined) {
                throw new RequiredError('ConnectAppSid', 'Required parameter ConnectAppSid was null or undefined when calling accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/ConnectApps/{ConnectAppSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'ConnectAppSid'}}`, encodeURIComponent(String(ConnectAppSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Connect App resource representations, each representing a Connect App in your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidConnectAppsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidConnectAppsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/ConnectApps{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Release this phone number from your account. Twilio will no longer answer calls to this number, and you will stop being billed the monthly phone number fee. The phone number will eventually be recycled and potentially given to another customer, so use with care. If you make a mistake, contac us. We may be able to give you the number back.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IncomingPhoneNumberSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'IncomingPhoneNumberSid' is not null or undefined
            if (IncomingPhoneNumberSid === null ||
                IncomingPhoneNumberSid === undefined) {
                throw new RequiredError('IncomingPhoneNumberSid', 'Required parameter IncomingPhoneNumberSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/IncomingPhoneNumbers/{IncomingPhoneNumberSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'IncomingPhoneNumberSid'}}`, encodeURIComponent(String(IncomingPhoneNumberSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get info about incoming call's phone number.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IncomingPhoneNumberSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'IncomingPhoneNumberSid' is not null or undefined
            if (IncomingPhoneNumberSid === null ||
                IncomingPhoneNumberSid === undefined) {
                throw new RequiredError('IncomingPhoneNumberSid', 'Required parameter IncomingPhoneNumberSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/IncomingPhoneNumbers/{IncomingPhoneNumberSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'IncomingPhoneNumberSid'}}`, encodeURIComponent(String(IncomingPhoneNumberSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tries to update the incoming phone number's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IncomingPhoneNumberSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'IncomingPhoneNumberSid' is not null or undefined
            if (IncomingPhoneNumberSid === null ||
                IncomingPhoneNumberSid === undefined) {
                throw new RequiredError('IncomingPhoneNumberSid', 'Required parameter IncomingPhoneNumberSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/IncomingPhoneNumbers/{IncomingPhoneNumberSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'IncomingPhoneNumberSid'}}`, encodeURIComponent(String(IncomingPhoneNumberSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tries to update the incoming phone number's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IncomingPhoneNumberSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPut.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPut.');
            }
            // verify required parameter 'IncomingPhoneNumberSid' is not null or undefined
            if (IncomingPhoneNumberSid === null ||
                IncomingPhoneNumberSid === undefined) {
                throw new RequiredError('IncomingPhoneNumberSid', 'Required parameter IncomingPhoneNumberSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPut.');
            }
            const localVarPath = `/Accounts/{AccountSid}/IncomingPhoneNumbers/{IncomingPhoneNumberSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'IncomingPhoneNumberSid'}}`, encodeURIComponent(String(IncomingPhoneNumberSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of local <IncomingPhoneNumber> elements, each representing a local (not toll-free) phone number given to your account, under an <IncomingPhoneNumbers> list element that includes paging information. Works exactly the same as the IncomingPhoneNumber resource, but filters out toll-free numbers.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/IncomingPhoneNumbers/Local{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new phone number to your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/IncomingPhoneNumbers/Local{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of local <IncomingPhoneNumber> elements, each representing a mobile phone number given to your account, under an <IncomingPhoneNumbers> list element that includes paging information. Works exactly the same as the IncomingPhoneNumber resource, but filters out local and toll free numbers.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new phone number to your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of local <IncomingPhoneNumber> elements, each representing a toll-free phone number given to your account, under an <IncomingPhoneNumbers> list element that includes paging information. Works exactly the same as the IncomingPhoneNumber resource, but filters out all numbers that aren't toll-free.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new phone number to your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of IncomingPhoneNumber resource representations, each representing a phone number given to your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/IncomingPhoneNumbers{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purchases a new phone number for your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number. To find an available phone number to POST, use the subresources of the AvailablePhoneNumbers list resource.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/IncomingPhoneNumbers{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Without an extension, the media is returned using the mime-type provided when the media was generated.
         * @param {string} AccountSid
         * @param {string} MessageSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} MediaSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesMessageSidMediaMediaSidmediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, MediaSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidMessagesMessageSidMediaMediaSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'MessageSid' is not null or undefined
            if (MessageSid === null || MessageSid === undefined) {
                throw new RequiredError('MessageSid', 'Required parameter MessageSid was null or undefined when calling accountsAccountSidMessagesMessageSidMediaMediaSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidMessagesMessageSidMediaMediaSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'MediaSid' is not null or undefined
            if (MediaSid === null || MediaSid === undefined) {
                throw new RequiredError('MediaSid', 'Required parameter MediaSid was null or undefined when calling accountsAccountSidMessagesMessageSidMediaMediaSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{MediaSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'MessageSid'}}`, encodeURIComponent(String(MessageSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'MediaSid'}}`, encodeURIComponent(String(MediaSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of media associated with your message.
         * @param {string} AccountSid
         * @param {string} MessageSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesMessageSidMediamediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidMessagesMessageSidMediamediaTypeExtensionGet.');
            }
            // verify required parameter 'MessageSid' is not null or undefined
            if (MessageSid === null || MessageSid === undefined) {
                throw new RequiredError('MessageSid', 'Required parameter MessageSid was null or undefined when calling accountsAccountSidMessagesMessageSidMediamediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidMessagesMessageSidMediamediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Messages/{MessageSid}/Media{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'MessageSid'}}`, encodeURIComponent(String(MessageSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single message specified by the provided {MessageSid}.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} MessageSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesMessageSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, MessageSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidMessagesMessageSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidMessagesMessageSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'MessageSid' is not null or undefined
            if (MessageSid === null || MessageSid === undefined) {
                throw new RequiredError('MessageSid', 'Required parameter MessageSid was null or undefined when calling accountsAccountSidMessagesMessageSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Messages/{MessageSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'MessageSid'}}`, encodeURIComponent(String(MessageSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of messages associated with your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidMessagesmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidMessagesmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Messages{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To send a new outgoing message, make an HTTP POST to your Messages list resource URI
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} To The destination phone number. Format with a &#39;+&#39; and country code e.g., +16175551212 (E.164 format).
         * @param {string} [From] A Twilio phone number (in E.164 format) or alphanumeric sender ID enabled for the type of message you wish to send. Phone numbers or short codes purchased from Twilio work here. You cannot (for example) spoof messages from your own cell phone number.
         * @param {string} [MessagingServiceSid] The 34 character unique id of the Messaging Service you want to associate with this Message. Set this parameter to use the Messaging Service Settings and Copilot Features you have configured. When only this parameter is set, Twilio will use your enabled Copilot Features to select the From phone number for delivery.
         * @param {string} [Body] The text of the message you want to send, limited to 1600 characters.
         * @param {string} [MediaUrl] The URL of the media you wish to send out with the message. gif , png and jpeg content is currently supported and will be formatted correctly on the recipient&#39;s device. Other types are also accepted by the API. The media size limit is 5MB. If you wish to send more than one image in the message body, please provide multiple MediaUrls values in the POST request. You may include up to 10 MediaUrls per message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, To, From, MessagingServiceSid, Body, MediaUrl, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidMessagesmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidMessagesmediaTypeExtensionPost.');
            }
            // verify required parameter 'To' is not null or undefined
            if (To === null || To === undefined) {
                throw new RequiredError('To', 'Required parameter To was null or undefined when calling accountsAccountSidMessagesmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Messages{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new url.URLSearchParams();
            if (To !== undefined) {
                localVarFormParams.set('To', To);
            }
            if (From !== undefined) {
                localVarFormParams.set('From', From);
            }
            if (MessagingServiceSid !== undefined) {
                localVarFormParams.set('MessagingServiceSid', MessagingServiceSid);
            }
            if (Body !== undefined) {
                localVarFormParams.set('Body', Body);
            }
            if (MediaUrl !== undefined) {
                localVarFormParams.set('MediaUrl', MediaUrl);
            }
            localVarHeaderParameter['Content-Type'] =
                'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the notification identified by {NotificationSid} from an account's log.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} NotificationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidNotificationsNotificationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, NotificationSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidNotificationsNotificationSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidNotificationsNotificationSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'NotificationSid' is not null or undefined
            if (NotificationSid === null || NotificationSid === undefined) {
                throw new RequiredError('NotificationSid', 'Required parameter NotificationSid was null or undefined when calling accountsAccountSidNotificationsNotificationSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Notifications/{NotificationSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'NotificationSid'}}`, encodeURIComponent(String(NotificationSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a notification entry.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} NotificationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidNotificationsNotificationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, NotificationSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidNotificationsNotificationSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidNotificationsNotificationSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'NotificationSid' is not null or undefined
            if (NotificationSid === null || NotificationSid === undefined) {
                throw new RequiredError('NotificationSid', 'Required parameter NotificationSid was null or undefined when calling accountsAccountSidNotificationsNotificationSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Notifications/{NotificationSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'NotificationSid'}}`, encodeURIComponent(String(NotificationSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of notifications generated for an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidNotificationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidNotificationsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidNotificationsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Notifications{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the caller ID from the account. Returns an HTTP 204 response if successful, with no body.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} OutgoingCallerIdSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'OutgoingCallerIdSid' is not null or undefined
            if (OutgoingCallerIdSid === null ||
                OutgoingCallerIdSid === undefined) {
                throw new RequiredError('OutgoingCallerIdSid', 'Required parameter OutgoingCallerIdSid was null or undefined when calling accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/OutgoingCallerIds/{OutgoingCallerIdSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'OutgoingCallerIdSid'}}`, encodeURIComponent(String(OutgoingCallerIdSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the set of an account's verified phone numbers.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} OutgoingCallerIdSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'OutgoingCallerIdSid' is not null or undefined
            if (OutgoingCallerIdSid === null ||
                OutgoingCallerIdSid === undefined) {
                throw new RequiredError('OutgoingCallerIdSid', 'Required parameter OutgoingCallerIdSid was null or undefined when calling accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/OutgoingCallerIds/{OutgoingCallerIdSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'OutgoingCallerIdSid'}}`, encodeURIComponent(String(OutgoingCallerIdSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the caller id, and returns the updated resource if successful.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} OutgoingCallerIdSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'OutgoingCallerIdSid' is not null or undefined
            if (OutgoingCallerIdSid === null ||
                OutgoingCallerIdSid === undefined) {
                throw new RequiredError('OutgoingCallerIdSid', 'Required parameter OutgoingCallerIdSid was null or undefined when calling accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/OutgoingCallerIds/{OutgoingCallerIdSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'OutgoingCallerIdSid'}}`, encodeURIComponent(String(OutgoingCallerIdSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the caller id, and returns the updated resource if successful.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} OutgoingCallerIdSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPut.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPut.');
            }
            // verify required parameter 'OutgoingCallerIdSid' is not null or undefined
            if (OutgoingCallerIdSid === null ||
                OutgoingCallerIdSid === undefined) {
                throw new RequiredError('OutgoingCallerIdSid', 'Required parameter OutgoingCallerIdSid was null or undefined when calling accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPut.');
            }
            const localVarPath = `/Accounts/{AccountSid}/OutgoingCallerIds/{OutgoingCallerIdSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'OutgoingCallerIdSid'}}`, encodeURIComponent(String(OutgoingCallerIdSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of OutgoingCallerId resource representations, each representing a Caller ID number valid for an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidOutgoingCallerIdsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidOutgoingCallerIdsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/OutgoingCallerIds{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new CallerID to your account.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidOutgoingCallerIdsmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidOutgoingCallerIdsmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/OutgoingCallerIds{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific member.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, CallSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'QueueSid' is not null or undefined
            if (QueueSid === null || QueueSid === undefined) {
                throw new RequiredError('QueueSid', 'Required parameter QueueSid was null or undefined when calling accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'CallSid' is not null or undefined
            if (CallSid === null || CallSid === undefined) {
                throw new RequiredError('CallSid', 'Required parameter CallSid was null or undefined when calling accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'QueueSid'}}`, encodeURIComponent(String(QueueSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CallSid'}}`, encodeURIComponent(String(CallSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Posting a URL and Method to a Queue instance will dequeue a member from a queue and have the member's call begin executing the TwiML document at that URL When redirecting a member of a queue addressed by CallSid, only the first request will succeed and return a 200 response code. A second request will fail and return an appropriate 400 response code.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, CallSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'QueueSid' is not null or undefined
            if (QueueSid === null || QueueSid === undefined) {
                throw new RequiredError('QueueSid', 'Required parameter QueueSid was null or undefined when calling accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'CallSid' is not null or undefined
            if (CallSid === null || CallSid === undefined) {
                throw new RequiredError('CallSid', 'Required parameter CallSid was null or undefined when calling accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'QueueSid'}}`, encodeURIComponent(String(QueueSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CallSid'}}`, encodeURIComponent(String(CallSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a front member.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionGet.');
            }
            // verify required parameter 'QueueSid' is not null or undefined
            if (QueueSid === null || QueueSid === undefined) {
                throw new RequiredError('QueueSid', 'Required parameter QueueSid was null or undefined when calling accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Queues/{QueueSid}/Members/Front{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'QueueSid'}}`, encodeURIComponent(String(QueueSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Posting a URL and Method to a Queue instance will dequeue a member from a queue and have the member's call begin executing the TwiML document at that URL When dequeuing the 'Front' of the queue, the next call in the queue will be redirected.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionPost.');
            }
            // verify required parameter 'QueueSid' is not null or undefined
            if (QueueSid === null || QueueSid === undefined) {
                throw new RequiredError('QueueSid', 'Required parameter QueueSid was null or undefined when calling accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Queues/{QueueSid}/Members/Front{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'QueueSid'}}`, encodeURIComponent(String(QueueSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of members in the queue identified by {QueueSid}.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidQueuesQueueSidMembersmediaTypeExtensionGet.');
            }
            // verify required parameter 'QueueSid' is not null or undefined
            if (QueueSid === null || QueueSid === undefined) {
                throw new RequiredError('QueueSid', 'Required parameter QueueSid was null or undefined when calling accountsAccountSidQueuesQueueSidMembersmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidQueuesQueueSidMembersmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Queues/{QueueSid}/Members{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'QueueSid'}}`, encodeURIComponent(String(QueueSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The DELETE method allows you to remove a Queue. Only empty queues are deletable.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} QueueSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, QueueSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidQueuesQueueSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidQueuesQueueSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'QueueSid' is not null or undefined
            if (QueueSid === null || QueueSid === undefined) {
                throw new RequiredError('QueueSid', 'Required parameter QueueSid was null or undefined when calling accountsAccountSidQueuesQueueSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Queues/{QueueSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'QueueSid'}}`, encodeURIComponent(String(QueueSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get resource's individual Queue instance.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} QueueSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, QueueSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidQueuesQueueSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidQueuesQueueSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'QueueSid' is not null or undefined
            if (QueueSid === null || QueueSid === undefined) {
                throw new RequiredError('QueueSid', 'Required parameter QueueSid was null or undefined when calling accountsAccountSidQueuesQueueSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Queues/{QueueSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'QueueSid'}}`, encodeURIComponent(String(QueueSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This POST request allows you to change the FriendlyName or MaxSize.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} QueueSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, QueueSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidQueuesQueueSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidQueuesQueueSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'QueueSid' is not null or undefined
            if (QueueSid === null || QueueSid === undefined) {
                throw new RequiredError('QueueSid', 'Required parameter QueueSid was null or undefined when calling accountsAccountSidQueuesQueueSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Queues/{QueueSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'QueueSid'}}`, encodeURIComponent(String(QueueSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of queues within an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidQueuesmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidQueuesmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Queues{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Queue resource.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidQueuesmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidQueuesmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Queues{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a set of Transcription resource representations that includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} RecordingSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidRecordingsRecordingSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidRecordingsRecordingSidTranscriptionsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidRecordingsRecordingSidTranscriptionsmediaTypeExtensionGet.');
            }
            // verify required parameter 'RecordingSid' is not null or undefined
            if (RecordingSid === null || RecordingSid === undefined) {
                throw new RequiredError('RecordingSid', 'Required parameter RecordingSid was null or undefined when calling accountsAccountSidRecordingsRecordingSidTranscriptionsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'RecordingSid'}}`, encodeURIComponent(String(RecordingSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a recording  from your account.
         * @param {string} AccountSid
         * @param {'.xml' | '.wav' | '.mp3'} mediaTypeExtension
         * @param {string} RecordingSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidRecordingsRecordingSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, RecordingSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidRecordingsRecordingSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidRecordingsRecordingSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'RecordingSid' is not null or undefined
            if (RecordingSid === null || RecordingSid === undefined) {
                throw new RequiredError('RecordingSid', 'Required parameter RecordingSid was null or undefined when calling accountsAccountSidRecordingsRecordingSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Recordings/{RecordingSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'RecordingSid'}}`, encodeURIComponent(String(RecordingSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns one of several representations: Without an extension, or with a \".wav\", a binary WAV audio file is returned with mime-type \"audio/x-wav\". Appending \".mp3\" to the URI returns a binary MP3 audio file with mime-type type \"audio/mpeg\". Appending \".xml\" to the URI returns a XML representation.
         * @param {string} AccountSid
         * @param {'.xml' | '.wav' | '.mp3'} mediaTypeExtension
         * @param {string} RecordingSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidRecordingsRecordingSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidRecordingsRecordingSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidRecordingsRecordingSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'RecordingSid' is not null or undefined
            if (RecordingSid === null || RecordingSid === undefined) {
                throw new RequiredError('RecordingSid', 'Required parameter RecordingSid was null or undefined when calling accountsAccountSidRecordingsRecordingSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Recordings/{RecordingSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'RecordingSid'}}`, encodeURIComponent(String(RecordingSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Recording resource representations, each representing a recording generated during the course of a phone call.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidRecordingsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidRecordingsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidRecordingsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Recordings{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a Credential from a CredentialList.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CredentialSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionDelete(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'CLSid' is not null or undefined
            if (CLSid === null || CLSid === undefined) {
                throw new RequiredError('CLSid', 'Required parameter CLSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'CredentialSid' is not null or undefined
            if (CredentialSid === null || CredentialSid === undefined) {
                throw new RequiredError('CredentialSid', 'Required parameter CredentialSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/CredentialLists/{CLSid}/Credentials/{CredentialSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'CLSid'}}`, encodeURIComponent(String(CLSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CredentialSid'}}`, encodeURIComponent(String(CredentialSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific Credential in a list. Though a password is stored for each username in your list, the password is not returned to protect your password. If you cannot remember your password, you will need to POST to this resource to update it.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CredentialSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'CLSid' is not null or undefined
            if (CLSid === null || CLSid === undefined) {
                throw new RequiredError('CLSid', 'Required parameter CLSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'CredentialSid' is not null or undefined
            if (CredentialSid === null || CredentialSid === undefined) {
                throw new RequiredError('CredentialSid', 'Required parameter CredentialSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/CredentialLists/{CLSid}/Credentials/{CredentialSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'CLSid'}}`, encodeURIComponent(String(CLSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CredentialSid'}}`, encodeURIComponent(String(CredentialSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the password of a Credential record.  If the change is successful, Twilio will respond with the Credential record but will not include the password in the response.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CredentialSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'CLSid' is not null or undefined
            if (CLSid === null || CLSid === undefined) {
                throw new RequiredError('CLSid', 'Required parameter CLSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'CredentialSid' is not null or undefined
            if (CredentialSid === null || CredentialSid === undefined) {
                throw new RequiredError('CredentialSid', 'Required parameter CredentialSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/CredentialLists/{CLSid}/Credentials/{CredentialSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'CLSid'}}`, encodeURIComponent(String(CLSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CredentialSid'}}`, encodeURIComponent(String(CredentialSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of Credentials in a CredentialList. The passwords for the Credentials are intentionally not returned so as to protect them.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionGet.');
            }
            // verify required parameter 'CLSid' is not null or undefined
            if (CLSid === null || CLSid === undefined) {
                throw new RequiredError('CLSid', 'Required parameter CLSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/CredentialLists/{CLSid}/Credentials{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'CLSid'}}`, encodeURIComponent(String(CLSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a Credential to the CredentialList.  When creating a Credential, you will POST both a username and password, but only receive the username back in the response. The password is intentionally not returned so as to protect it.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionPost.');
            }
            // verify required parameter 'CLSid' is not null or undefined
            if (CLSid === null || CLSid === undefined) {
                throw new RequiredError('CLSid', 'Required parameter CLSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/CredentialLists/{CLSid}/Credentials{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'CLSid'}}`, encodeURIComponent(String(CLSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a CredentialList from your account. It can only be deleted if no domains are mapped to it. If you attempt to delete one that is mapped to a domain, you will receive an error.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CLSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, CLSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'CLSid' is not null or undefined
            if (CLSid === null || CLSid === undefined) {
                throw new RequiredError('CLSid', 'Required parameter CLSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/CredentialLists/{CLSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CLSid'}}`, encodeURIComponent(String(CLSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a credential list instance resource
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CLSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CLSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'CLSid' is not null or undefined
            if (CLSid === null || CLSid === undefined) {
                throw new RequiredError('CLSid', 'Required parameter CLSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/CredentialLists/{CLSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CLSid'}}`, encodeURIComponent(String(CLSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the FriendlyName of the list
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CLSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CLSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'CLSid' is not null or undefined
            if (CLSid === null || CLSid === undefined) {
                throw new RequiredError('CLSid', 'Required parameter CLSid was null or undefined when calling accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/CredentialLists/{CLSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CLSid'}}`, encodeURIComponent(String(CLSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of Credential Lists for an account
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPCredentialListsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPCredentialListsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/CredentialLists{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Credential List.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPCredentialListsmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPCredentialListsmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/CredentialLists{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a CredentialListMapping from a domain
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CLSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsCLSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, CLSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsCLSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'SipDomainSid' is not null or undefined
            if (SipDomainSid === null || SipDomainSid === undefined) {
                throw new RequiredError('SipDomainSid', 'Required parameter SipDomainSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsCLSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsCLSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'CLSid' is not null or undefined
            if (CLSid === null || CLSid === undefined) {
                throw new RequiredError('CLSid', 'Required parameter CLSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsCLSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/Domains/{SipDomainSid}/CredentialListMappings/{CLSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'SipDomainSid'}}`, encodeURIComponent(String(SipDomainSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'CLSid'}}`, encodeURIComponent(String(CLSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user lists mapped to this domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionGet.');
            }
            // verify required parameter 'SipDomainSid' is not null or undefined
            if (SipDomainSid === null || SipDomainSid === undefined) {
                throw new RequiredError('SipDomainSid', 'Required parameter SipDomainSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/Domains/{SipDomainSid}/CredentialListMappings{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'SipDomainSid'}}`, encodeURIComponent(String(SipDomainSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Map a CredentialList to the domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionPost.');
            }
            // verify required parameter 'SipDomainSid' is not null or undefined
            if (SipDomainSid === null || SipDomainSid === undefined) {
                throw new RequiredError('SipDomainSid', 'Required parameter SipDomainSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/Domains/{SipDomainSid}/CredentialListMappings{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'SipDomainSid'}}`, encodeURIComponent(String(SipDomainSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a mapping from this domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ALSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'SipDomainSid' is not null or undefined
            if (SipDomainSid === null || SipDomainSid === undefined) {
                throw new RequiredError('SipDomainSid', 'Required parameter SipDomainSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'ALSid' is not null or undefined
            if (ALSid === null || ALSid === undefined) {
                throw new RequiredError('ALSid', 'Required parameter ALSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/Domains/{SipDomainSid}/IpAccessControlListMappings/{ALSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'SipDomainSid'}}`, encodeURIComponent(String(SipDomainSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'ALSid'}}`, encodeURIComponent(String(ALSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a specific IpAccessControlListMapping instance by Sid.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ALSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'SipDomainSid' is not null or undefined
            if (SipDomainSid === null || SipDomainSid === undefined) {
                throw new RequiredError('SipDomainSid', 'Required parameter SipDomainSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'ALSid' is not null or undefined
            if (ALSid === null || ALSid === undefined) {
                throw new RequiredError('ALSid', 'Required parameter ALSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/Domains/{SipDomainSid}/IpAccessControlListMappings/{ALSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'SipDomainSid'}}`, encodeURIComponent(String(SipDomainSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'ALSid'}}`, encodeURIComponent(String(ALSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the IpAccessControlListMappings that are associated to this domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionGet.');
            }
            // verify required parameter 'SipDomainSid' is not null or undefined
            if (SipDomainSid === null || SipDomainSid === undefined) {
                throw new RequiredError('SipDomainSid', 'Required parameter SipDomainSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/Domains/{SipDomainSid}/IpAccessControlListMappings{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'SipDomainSid'}}`, encodeURIComponent(String(SipDomainSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Map an IpAccessControlList to this domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionPost.');
            }
            // verify required parameter 'SipDomainSid' is not null or undefined
            if (SipDomainSid === null || SipDomainSid === undefined) {
                throw new RequiredError('SipDomainSid', 'Required parameter SipDomainSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/Domains/{SipDomainSid}/IpAccessControlListMappings{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'SipDomainSid'}}`, encodeURIComponent(String(SipDomainSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a domain. If you have created subdomains of a domain, you will not be able to delete the domain until you first delete all subdomains of it.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} SipDomainSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, SipDomainSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'SipDomainSid' is not null or undefined
            if (SipDomainSid === null || SipDomainSid === undefined) {
                throw new RequiredError('SipDomainSid', 'Required parameter SipDomainSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/Domains/{SipDomainSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'SipDomainSid'}}`, encodeURIComponent(String(SipDomainSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a specific instance by Sid.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} SipDomainSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, SipDomainSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'SipDomainSid' is not null or undefined
            if (SipDomainSid === null || SipDomainSid === undefined) {
                throw new RequiredError('SipDomainSid', 'Required parameter SipDomainSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/Domains/{SipDomainSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'SipDomainSid'}}`, encodeURIComponent(String(SipDomainSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the attributes of a domain.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} SipDomainSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, SipDomainSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'SipDomainSid' is not null or undefined
            if (SipDomainSid === null || SipDomainSid === undefined) {
                throw new RequiredError('SipDomainSid', 'Required parameter SipDomainSid was null or undefined when calling accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/Domains/{SipDomainSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'SipDomainSid'}}`, encodeURIComponent(String(SipDomainSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paged list of the domains for an account.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPDomainsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPDomainsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/Domains{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Domain and returns its instance resource. You must pick a unique domain name that ends in \".sip.twilio.com\". After creating a Domain, you must map it to an authentication method before the domain is ready to receive traffic.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPDomainsmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPDomainsmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/Domains{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an IP address entry from the list.
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAddressSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionDelete(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'IpAccessControlListSid' is not null or undefined
            if (IpAccessControlListSid === null ||
                IpAccessControlListSid === undefined) {
                throw new RequiredError('IpAccessControlListSid', 'Required parameter IpAccessControlListSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'IpAddressSid' is not null or undefined
            if (IpAddressSid === null || IpAddressSid === undefined) {
                throw new RequiredError('IpAddressSid', 'Required parameter IpAddressSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{IpAddressSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'IpAccessControlListSid'}}`, encodeURIComponent(String(IpAccessControlListSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'IpAddressSid'}}`, encodeURIComponent(String(IpAddressSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a single IP Address resource.
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAddressSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'IpAccessControlListSid' is not null or undefined
            if (IpAccessControlListSid === null ||
                IpAccessControlListSid === undefined) {
                throw new RequiredError('IpAccessControlListSid', 'Required parameter IpAccessControlListSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'IpAddressSid' is not null or undefined
            if (IpAddressSid === null || IpAddressSid === undefined) {
                throw new RequiredError('IpAddressSid', 'Required parameter IpAddressSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{IpAddressSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'IpAccessControlListSid'}}`, encodeURIComponent(String(IpAccessControlListSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'IpAddressSid'}}`, encodeURIComponent(String(IpAddressSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the description or IP address of a given IpAddress instance resource
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAddressSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'IpAccessControlListSid' is not null or undefined
            if (IpAccessControlListSid === null ||
                IpAccessControlListSid === undefined) {
                throw new RequiredError('IpAccessControlListSid', 'Required parameter IpAccessControlListSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'IpAddressSid' is not null or undefined
            if (IpAddressSid === null || IpAddressSid === undefined) {
                throw new RequiredError('IpAddressSid', 'Required parameter IpAddressSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{IpAddressSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'IpAccessControlListSid'}}`, encodeURIComponent(String(IpAccessControlListSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'IpAddressSid'}}`, encodeURIComponent(String(IpAddressSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the IP Addresses contained in this list.
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionGet.');
            }
            // verify required parameter 'IpAccessControlListSid' is not null or undefined
            if (IpAccessControlListSid === null ||
                IpAccessControlListSid === undefined) {
                throw new RequiredError('IpAccessControlListSid', 'Required parameter IpAccessControlListSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'IpAccessControlListSid'}}`, encodeURIComponent(String(IpAccessControlListSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an IP Address to the list with a description.
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionPost.');
            }
            // verify required parameter 'IpAccessControlListSid' is not null or undefined
            if (IpAccessControlListSid === null ||
                IpAccessControlListSid === undefined) {
                throw new RequiredError('IpAccessControlListSid', 'Required parameter IpAccessControlListSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'IpAccessControlListSid'}}`, encodeURIComponent(String(IpAccessControlListSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an IpAccessControlList from your account. It can only be deleted if no domains are mapped to it. If you attempt to delete one that is mapped to a domain, you will receive an error.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAccessControlListSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IpAccessControlListSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'IpAccessControlListSid' is not null or undefined
            if (IpAccessControlListSid === null ||
                IpAccessControlListSid === undefined) {
                throw new RequiredError('IpAccessControlListSid', 'Required parameter IpAccessControlListSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'IpAccessControlListSid'}}`, encodeURIComponent(String(IpAccessControlListSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a specific IpAccessControlList resource.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAccessControlListSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IpAccessControlListSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'IpAccessControlListSid' is not null or undefined
            if (IpAccessControlListSid === null ||
                IpAccessControlListSid === undefined) {
                throw new RequiredError('IpAccessControlListSid', 'Required parameter IpAccessControlListSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'IpAccessControlListSid'}}`, encodeURIComponent(String(IpAccessControlListSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rename an IpAccessControlList.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAccessControlListSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IpAccessControlListSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'IpAccessControlListSid' is not null or undefined
            if (IpAccessControlListSid === null ||
                IpAccessControlListSid === undefined) {
                throw new RequiredError('IpAccessControlListSid', 'Required parameter IpAccessControlListSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'IpAccessControlListSid'}}`, encodeURIComponent(String(IpAccessControlListSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a paged list of all IpAccessControlLists under this account.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/IpAccessControlLists{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new IpAccessControlList resource.  When created, the list will contain no IP addresses. You will need to add IP addresses to the list for it to be active. To add IP addresses, you will need to POST to the IpAddresses List subresource.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SIP/IpAccessControlLists{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single message.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ShortCodeSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ShortCodeSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'ShortCodeSid' is not null or undefined
            if (ShortCodeSid === null || ShortCodeSid === undefined) {
                throw new RequiredError('ShortCodeSid', 'Required parameter ShortCodeSid was null or undefined when calling accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SMS/ShortCodes/{ShortCodeSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'ShortCodeSid'}}`, encodeURIComponent(String(ShortCodeSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tries to update the shortcode's properties, and returns the updated resource representation if successful.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ShortCodeSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ShortCodeSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'ShortCodeSid' is not null or undefined
            if (ShortCodeSid === null || ShortCodeSid === undefined) {
                throw new RequiredError('ShortCodeSid', 'Required parameter ShortCodeSid was null or undefined when calling accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SMS/ShortCodes/{ShortCodeSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'ShortCodeSid'}}`, encodeURIComponent(String(ShortCodeSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of ShortCode resource representations, each representing a short code within your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSMSShortCodesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidSMSShortCodesmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidSMSShortCodesmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/SMS/ShortCodes{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a transcription from your account.
         * @param {string} AccountSid
         * @param {'.json' | '.csv' | '.html' | '.txt' | '.xml'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} TranscriptionSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, TranscriptionSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'TranscriptionSid' is not null or undefined
            if (TranscriptionSid === null || TranscriptionSid === undefined) {
                throw new RequiredError('TranscriptionSid', 'Required parameter TranscriptionSid was null or undefined when calling accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Transcriptions/{TranscriptionSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'TranscriptionSid'}}`, encodeURIComponent(String(TranscriptionSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Transcription resource representation identified by the given {TranscriptionSid}. By default Twilio will respond with the XML metadata for the Transcription. If you append \".txt\" to the end of the Transcription resource's URI Twilio will just return you the transcription tex.
         * @param {string} AccountSid
         * @param {'.json' | '.csv' | '.html' | '.txt' | '.xml'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} TranscriptionSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, TranscriptionSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'TranscriptionSid' is not null or undefined
            if (TranscriptionSid === null || TranscriptionSid === undefined) {
                throw new RequiredError('TranscriptionSid', 'Required parameter TranscriptionSid was null or undefined when calling accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Transcriptions/{TranscriptionSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'TranscriptionSid'}}`, encodeURIComponent(String(TranscriptionSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a set of Transcription resource representations that includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidTranscriptionsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidTranscriptionsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Transcriptions{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns UsageRecords for all usage categories for a specified period.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {'Daily' | 'Monthly' | 'Yearly' | 'AllTime' | 'Today' | 'Yesterday' | 'ThisMonth' | 'LastMonth'} Subresource |Subresource|Description| |---|---| |Daily|Return multiple UsageRecords for each usage category, each representing usage over a daily time-interval.| |Monthly|Return multiple UsageRecords for each usage category, each representing usage over a monthly time-interval.| |Yearly|Return multple UsageRecords for each usage category, each representing usage over a yearly time-interval.| |AllTime|  Return a single UsageRecord for each usage category, each representing usage over the date-range specified. This is the same as the root /Usage/Records.| |Today|Return a single UsageRecord per usage category, for today&#39;s usage only.| ||Yesterday|Return a single UsageRecord per usage category, for yesterday&#39;s usage only.| |ThisMonth|Return a single UsageRecord per usage category, for this month&#39;s usage only.| |LastMonth|Return a single UsageRecord per usage category, for last month&#39;s usage only.|
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageRecordsSubresourcemediaTypeExtensionGet(AccountSid, mediaTypeExtension, Subresource, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidUsageRecordsSubresourcemediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidUsageRecordsSubresourcemediaTypeExtensionGet.');
            }
            // verify required parameter 'Subresource' is not null or undefined
            if (Subresource === null || Subresource === undefined) {
                throw new RequiredError('Subresource', 'Required parameter Subresource was null or undefined when calling accountsAccountSidUsageRecordsSubresourcemediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Usage/Records/{Subresource}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'Subresource'}}`, encodeURIComponent(String(Subresource)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns UsageRecords for all usage categories. The list includes paging information. By default, the UsageRecords resource will return one UsageRecord for each Category, representing all usage accrued all-time for the account. You can filter the usage Category or change the date-range over which usage is counted using optional GET query parameters.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageRecordsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidUsageRecordsmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidUsageRecordsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Usage/Records{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete this UsageTrigger.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} UsageTriggerSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, UsageTriggerSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionDelete.');
            }
            // verify required parameter 'UsageTriggerSid' is not null or undefined
            if (UsageTriggerSid === null || UsageTriggerSid === undefined) {
                throw new RequiredError('UsageTriggerSid', 'Required parameter UsageTriggerSid was null or undefined when calling accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionDelete.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Usage/Triggers/{UsageTriggerSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'UsageTriggerSid'}}`, encodeURIComponent(String(UsageTriggerSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a repesentation of the UsageTrigger.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} UsageTriggerSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, UsageTriggerSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'UsageTriggerSid' is not null or undefined
            if (UsageTriggerSid === null || UsageTriggerSid === undefined) {
                throw new RequiredError('UsageTriggerSid', 'Required parameter UsageTriggerSid was null or undefined when calling accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Usage/Triggers/{UsageTriggerSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'UsageTriggerSid'}}`, encodeURIComponent(String(UsageTriggerSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tries to update the UsageTrigger's properties, and returns the updated resource representation if successful.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} UsageTriggerSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, UsageTriggerSid, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'UsageTriggerSid' is not null or undefined
            if (UsageTriggerSid === null || UsageTriggerSid === undefined) {
                throw new RequiredError('UsageTriggerSid', 'Required parameter UsageTriggerSid was null or undefined when calling accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Usage/Triggers/{UsageTriggerSid}{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'UsageTriggerSid'}}`, encodeURIComponent(String(UsageTriggerSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of UsageTrigger resource representations. The list includes paging information. By default, all UsageTriggers are returned. You can filter the list by specifying one or more query parameters. Note that the query parameters are case-sensitive
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidUsageTriggersmediaTypeExtensionGet.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidUsageTriggersmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Usage/Triggers{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new UsageTrigger. Each account can create up to 1,000 UsageTriggers. Currently, UsageTriggers that are no longer active are not deleted automatically. Use DELETE to delete triggers you no longer need.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options = {}) {
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidUsageTriggersmediaTypeExtensionPost.');
            }
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidUsageTriggersmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}/Usage/Triggers{mediaTypeExtension}`
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)))
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a representation of an account.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} AccountSid A 34 character string that uniquely identifies this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidmediaTypeExtensionGet(mediaTypeExtension, AccountSid, options = {}) {
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidmediaTypeExtensionGet.');
            }
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts/{AccountSid}{mediaTypeExtension}`
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to modify the properties of an account.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} AccountSid A 34 character string that uniquely identifies this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidmediaTypeExtensionPost(mediaTypeExtension, AccountSid, options = {}) {
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidmediaTypeExtensionPost.');
            }
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts/{AccountSid}{mediaTypeExtension}`
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to modify the properties of an account.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} AccountSid A 34 character string that uniquely identifies this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidmediaTypeExtensionPut(mediaTypeExtension, AccountSid, options = {}) {
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsAccountSidmediaTypeExtensionPut.');
            }
            // verify required parameter 'AccountSid' is not null or undefined
            if (AccountSid === null || AccountSid === undefined) {
                throw new RequiredError('AccountSid', 'Required parameter AccountSid was null or undefined when calling accountsAccountSidmediaTypeExtensionPut.');
            }
            const localVarPath = `/Accounts/{AccountSid}{mediaTypeExtension}`
                .replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)))
                .replace(`{${'AccountSid'}}`, encodeURIComponent(String(AccountSid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of the Account resources belonging to the account used to make the API request. This list will include that Account as well.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsmediaTypeExtensionGet(mediaTypeExtension, options = {}) {
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsmediaTypeExtensionGet.');
            }
            const localVarPath = `/Accounts{mediaTypeExtension}`.replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Account instance resource as a subaccount of the one used to make the request. See Creating Subaccounts for more information.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsmediaTypeExtensionPost(mediaTypeExtension, options = {}) {
            // verify required parameter 'mediaTypeExtension' is not null or undefined
            if (mediaTypeExtension === null ||
                mediaTypeExtension === undefined) {
                throw new RequiredError('mediaTypeExtension', 'Required parameter mediaTypeExtension was null or undefined when calling accountsmediaTypeExtensionPost.');
            }
            const localVarPath = `/Accounts{mediaTypeExtension}`.replace(`{${'mediaTypeExtension'}}`, encodeURIComponent(String(mediaTypeExtension)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.DefaultApiFetchParamCreator = DefaultApiFetchParamCreator;
/**
 * DefaultApi - functional programming interface
 * @export
 */
const DefaultApiFp = function (configuration) {
    return {
        /**
         * Delete this application.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ApplicationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsApplicationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, ApplicationSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidApplicationsApplicationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, ApplicationSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get application instance resource.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ApplicationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsApplicationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ApplicationSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidApplicationsApplicationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ApplicationSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Tries to update the application's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ApplicationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsApplicationSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ApplicationSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidApplicationsApplicationSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ApplicationSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of Application resource representations, each representing an application within your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidApplicationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new application within your account.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidApplicationsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the properties of the authorized application.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ConnectAppSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAuthorizedConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidAuthorizedConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of Connect App resource representations, each representing a Connect App you've authorized to access your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAuthorizedConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidAuthorizedConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of local AvailablePhoneNumber resource representations that match the specified filters, each representing a phone number tha is currently available for provisioning within your account.
         * @param {string} AccountSid
         * @param {string} IsoCountryCode ISO 3166-1 alpha-2.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAvailablePhoneNumbersIsoCountryCodeLocalmediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidAvailablePhoneNumbersIsoCountryCodeLocalmediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of mobile AvailablePhoneNumber resource representations that match the specified filters, each representing a phone number that is currently available for provisioning within your account.
         * @param {string} AccountSid
         * @param {string} IsoCountryCode ISO 3166-1 alpha-2.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAvailablePhoneNumbersIsoCountryCodeMobilemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidAvailablePhoneNumbersIsoCountryCodeMobilemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of toll-free AvailablePhoneNumber elements that match the specified filters, each representing a phone number that is currently available for provisioning within your account. To provision an available phone number, POST the number to the IncomingPhoneNumbers resource.
         * @param {string} AccountSid
         * @param {string} IsoCountryCode ISO 3166-1 alpha-2.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAvailablePhoneNumbersIsoCountryCodeTollFreemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidAvailablePhoneNumbersIsoCountryCodeTollFreemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of all AvailablePhoneNumber subresources for your account by ISO Country. For full information about our phone number support, see our Phone Number CSV (http://www.twilio.com/resources/rates/international-phone-number-rates.csv).
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAvailablePhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidAvailablePhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of notifications generated for an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {string} CallSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsCallSidNotificationsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidCallsCallSidNotificationsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of Recording resource representations, each representing a recording generated during the course of a phone call.
         * @param {string} AccountSid
         * @param {string} CallSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsCallSidRecordingsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidCallsCallSidRecordingsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the single Call resource identified by {CallSid}.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsCallSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CallSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidCallsCallSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CallSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Modify a phone call.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsCallSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CallSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidCallsCallSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CallSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of phone calls made to and from the account identified by {AccountSid}.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidCallsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * To make a call, make an HTTP POST request. Initiate a new phone call.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidCallsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Kick this participant from the conference.
         * @param {string} AccountSid
         * @param {string} ConferenceSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionDelete(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionDelete(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a representation of this participant.
         * @param {string} AccountSid
         * @param {string} ConferenceSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the status of a participant.
         * @param {string} AccountSid
         * @param {string} ConferenceSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionPost(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionPost(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the list of participants in the conference identified by {ConferenceSid}.
         * @param {string} AccountSid
         * @param {string} ConferenceSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidParticipantsmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidConferencesConferenceSidParticipantsmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a representation of the conference identified by {ConferenceSid}.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ConferenceSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConferenceSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidConferencesConferenceSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConferenceSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of conferences within an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidConferencesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the properties of a Connect App.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ConnectAppSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Tries to update the Connect App's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ConnectAppSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ConnectAppSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ConnectAppSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of Connect App resource representations, each representing a Connect App in your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Release this phone number from your account. Twilio will no longer answer calls to this number, and you will stop being billed the monthly phone number fee. The phone number will eventually be recycled and potentially given to another customer, so use with care. If you make a mistake, contac us. We may be able to give you the number back.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IncomingPhoneNumberSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get info about incoming call's phone number.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IncomingPhoneNumberSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Tries to update the incoming phone number's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IncomingPhoneNumberSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Tries to update the incoming phone number's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IncomingPhoneNumberSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of local <IncomingPhoneNumber> elements, each representing a local (not toll-free) phone number given to your account, under an <IncomingPhoneNumbers> list element that includes paging information. Works exactly the same as the IncomingPhoneNumber resource, but filters out toll-free numbers.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a new phone number to your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of local <IncomingPhoneNumber> elements, each representing a mobile phone number given to your account, under an <IncomingPhoneNumbers> list element that includes paging information. Works exactly the same as the IncomingPhoneNumber resource, but filters out local and toll free numbers.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a new phone number to your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of local <IncomingPhoneNumber> elements, each representing a toll-free phone number given to your account, under an <IncomingPhoneNumbers> list element that includes paging information. Works exactly the same as the IncomingPhoneNumber resource, but filters out all numbers that aren't toll-free.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a new phone number to your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of IncomingPhoneNumber resource representations, each representing a phone number given to your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Purchases a new phone number for your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number. To find an available phone number to POST, use the subresources of the AvailablePhoneNumbers list resource.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Without an extension, the media is returned using the mime-type provided when the media was generated.
         * @param {string} AccountSid
         * @param {string} MessageSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} MediaSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesMessageSidMediaMediaSidmediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, MediaSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidMessagesMessageSidMediaMediaSidmediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, MediaSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of media associated with your message.
         * @param {string} AccountSid
         * @param {string} MessageSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesMessageSidMediamediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidMessagesMessageSidMediamediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a single message specified by the provided {MessageSid}.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} MessageSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesMessageSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, MessageSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidMessagesMessageSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, MessageSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of messages associated with your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidMessagesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * To send a new outgoing message, make an HTTP POST to your Messages list resource URI
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} To The destination phone number. Format with a &#39;+&#39; and country code e.g., +16175551212 (E.164 format).
         * @param {string} [From] A Twilio phone number (in E.164 format) or alphanumeric sender ID enabled for the type of message you wish to send. Phone numbers or short codes purchased from Twilio work here. You cannot (for example) spoof messages from your own cell phone number.
         * @param {string} [MessagingServiceSid] The 34 character unique id of the Messaging Service you want to associate with this Message. Set this parameter to use the Messaging Service Settings and Copilot Features you have configured. When only this parameter is set, Twilio will use your enabled Copilot Features to select the From phone number for delivery.
         * @param {string} [Body] The text of the message you want to send, limited to 1600 characters.
         * @param {string} [MediaUrl] The URL of the media you wish to send out with the message. gif , png and jpeg content is currently supported and will be formatted correctly on the recipient&#39;s device. Other types are also accepted by the API. The media size limit is 5MB. If you wish to send more than one image in the message body, please provide multiple MediaUrls values in the POST request. You may include up to 10 MediaUrls per message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, To, From, MessagingServiceSid, Body, MediaUrl, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidMessagesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, To, From, MessagingServiceSid, Body, MediaUrl, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes the notification identified by {NotificationSid} from an account's log.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} NotificationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidNotificationsNotificationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, NotificationSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidNotificationsNotificationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, NotificationSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a notification entry.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} NotificationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidNotificationsNotificationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, NotificationSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidNotificationsNotificationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, NotificationSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of notifications generated for an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidNotificationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidNotificationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes the caller ID from the account. Returns an HTTP 204 response if successful, with no body.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} OutgoingCallerIdSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the set of an account's verified phone numbers.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} OutgoingCallerIdSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the caller id, and returns the updated resource if successful.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} OutgoingCallerIdSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the caller id, and returns the updated resource if successful.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} OutgoingCallerIdSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of OutgoingCallerId resource representations, each representing a Caller ID number valid for an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidOutgoingCallerIdsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a new CallerID to your account.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidOutgoingCallerIdsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a specific member.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, CallSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, CallSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Posting a URL and Method to a Queue instance will dequeue a member from a queue and have the member's call begin executing the TwiML document at that URL When redirecting a member of a queue addressed by CallSid, only the first request will succeed and return a 200 response code. A second request will fail and return an appropriate 400 response code.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, CallSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, CallSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a front member.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Posting a URL and Method to a Queue instance will dequeue a member from a queue and have the member's call begin executing the TwiML document at that URL When dequeuing the 'Front' of the queue, the next call in the queue will be redirected.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the list of members in the queue identified by {QueueSid}.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidQueuesQueueSidMembersmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The DELETE method allows you to remove a Queue. Only empty queues are deletable.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} QueueSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, QueueSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidQueuesQueueSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, QueueSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get resource's individual Queue instance.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} QueueSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, QueueSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidQueuesQueueSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, QueueSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This POST request allows you to change the FriendlyName or MaxSize.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} QueueSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, QueueSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidQueuesQueueSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, QueueSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of queues within an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidQueuesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Queue resource.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidQueuesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a set of Transcription resource representations that includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} RecordingSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidRecordingsRecordingSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidRecordingsRecordingSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a recording  from your account.
         * @param {string} AccountSid
         * @param {'.xml' | '.wav' | '.mp3'} mediaTypeExtension
         * @param {string} RecordingSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidRecordingsRecordingSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, RecordingSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidRecordingsRecordingSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, RecordingSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns one of several representations: Without an extension, or with a \".wav\", a binary WAV audio file is returned with mime-type \"audio/x-wav\". Appending \".mp3\" to the URI returns a binary MP3 audio file with mime-type type \"audio/mpeg\". Appending \".xml\" to the URI returns a XML representation.
         * @param {string} AccountSid
         * @param {'.xml' | '.wav' | '.mp3'} mediaTypeExtension
         * @param {string} RecordingSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidRecordingsRecordingSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidRecordingsRecordingSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of Recording resource representations, each representing a recording generated during the course of a phone call.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidRecordingsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidRecordingsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a Credential from a CredentialList.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CredentialSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionDelete(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionDelete(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a specific Credential in a list. Though a password is stored for each username in your list, the password is not returned to protect your password. If you cannot remember your password, you will need to POST to this resource to update it.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CredentialSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change the password of a Credential record.  If the change is successful, Twilio will respond with the Credential record but will not include the password in the response.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CredentialSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the list of Credentials in a CredentialList. The passwords for the Credentials are intentionally not returned so as to protect them.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add a Credential to the CredentialList.  When creating a Credential, you will POST both a username and password, but only receive the username back in the response. The password is intentionally not returned so as to protect it.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a CredentialList from your account. It can only be deleted if no domains are mapped to it. If you attempt to delete one that is mapped to a domain, you will receive an error.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CLSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, CLSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, CLSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a credential list instance resource
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CLSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CLSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CLSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change the FriendlyName of the list
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CLSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CLSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CLSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a list of Credential Lists for an account
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPCredentialListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Credential List.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPCredentialListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a CredentialListMapping from a domain
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CLSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsCLSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, CLSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsCLSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, CLSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the user lists mapped to this domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Map a CredentialList to the domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a mapping from this domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ALSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a specific IpAccessControlListMapping instance by Sid.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ALSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the IpAccessControlListMappings that are associated to this domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Map an IpAccessControlList to this domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a domain. If you have created subdomains of a domain, you will not be able to delete the domain until you first delete all subdomains of it.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} SipDomainSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, SipDomainSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, SipDomainSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a specific instance by Sid.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} SipDomainSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, SipDomainSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, SipDomainSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the attributes of a domain.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} SipDomainSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, SipDomainSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, SipDomainSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a paged list of the domains for an account.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPDomainsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new Domain and returns its instance resource. You must pick a unique domain name that ends in \".sip.twilio.com\". After creating a Domain, you must map it to an authentication method before the domain is ready to receive traffic.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPDomainsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an IP address entry from the list.
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAddressSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionDelete(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionDelete(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a single IP Address resource.
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAddressSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change the description or IP address of a given IpAddress instance resource
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAddressSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List the IP Addresses contained in this list.
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add an IP Address to the list with a description.
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an IpAccessControlList from your account. It can only be deleted if no domains are mapped to it. If you attempt to delete one that is mapped to a domain, you will receive an error.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAccessControlListSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IpAccessControlListSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IpAccessControlListSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a specific IpAccessControlList resource.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAccessControlListSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IpAccessControlListSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IpAccessControlListSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Rename an IpAccessControlList.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAccessControlListSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IpAccessControlListSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IpAccessControlListSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a paged list of all IpAccessControlLists under this account.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new IpAccessControlList resource.  When created, the list will contain no IP addresses. You will need to add IP addresses to the list for it to be active. To add IP addresses, you will need to POST to the IpAddresses List subresource.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a single message.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ShortCodeSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ShortCodeSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ShortCodeSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Tries to update the shortcode's properties, and returns the updated resource representation if successful.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ShortCodeSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ShortCodeSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ShortCodeSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of ShortCode resource representations, each representing a short code within your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSMSShortCodesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidSMSShortCodesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a transcription from your account.
         * @param {string} AccountSid
         * @param {'.json' | '.csv' | '.html' | '.txt' | '.xml'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} TranscriptionSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, TranscriptionSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, TranscriptionSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a single Transcription resource representation identified by the given {TranscriptionSid}. By default Twilio will respond with the XML metadata for the Transcription. If you append \".txt\" to the end of the Transcription resource's URI Twilio will just return you the transcription tex.
         * @param {string} AccountSid
         * @param {'.json' | '.csv' | '.html' | '.txt' | '.xml'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} TranscriptionSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, TranscriptionSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, TranscriptionSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a set of Transcription resource representations that includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns UsageRecords for all usage categories for a specified period.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {'Daily' | 'Monthly' | 'Yearly' | 'AllTime' | 'Today' | 'Yesterday' | 'ThisMonth' | 'LastMonth'} Subresource |Subresource|Description| |---|---| |Daily|Return multiple UsageRecords for each usage category, each representing usage over a daily time-interval.| |Monthly|Return multiple UsageRecords for each usage category, each representing usage over a monthly time-interval.| |Yearly|Return multple UsageRecords for each usage category, each representing usage over a yearly time-interval.| |AllTime|  Return a single UsageRecord for each usage category, each representing usage over the date-range specified. This is the same as the root /Usage/Records.| |Today|Return a single UsageRecord per usage category, for today&#39;s usage only.| ||Yesterday|Return a single UsageRecord per usage category, for yesterday&#39;s usage only.| |ThisMonth|Return a single UsageRecord per usage category, for this month&#39;s usage only.| |LastMonth|Return a single UsageRecord per usage category, for last month&#39;s usage only.|
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageRecordsSubresourcemediaTypeExtensionGet(AccountSid, mediaTypeExtension, Subresource, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidUsageRecordsSubresourcemediaTypeExtensionGet(AccountSid, mediaTypeExtension, Subresource, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns UsageRecords for all usage categories. The list includes paging information. By default, the UsageRecords resource will return one UsageRecord for each Category, representing all usage accrued all-time for the account. You can filter the usage Category or change the date-range over which usage is counted using optional GET query parameters.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageRecordsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidUsageRecordsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete this UsageTrigger.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} UsageTriggerSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, UsageTriggerSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, UsageTriggerSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a repesentation of the UsageTrigger.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} UsageTriggerSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, UsageTriggerSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, UsageTriggerSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Tries to update the UsageTrigger's properties, and returns the updated resource representation if successful.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} UsageTriggerSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, UsageTriggerSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, UsageTriggerSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of UsageTrigger resource representations. The list includes paging information. By default, all UsageTriggers are returned. You can filter the list by specifying one or more query parameters. Note that the query parameters are case-sensitive
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidUsageTriggersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new UsageTrigger. Each account can create up to 1,000 UsageTriggers. Currently, UsageTriggers that are no longer active are not deleted automatically. Use DELETE to delete triggers you no longer need.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidUsageTriggersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a representation of an account.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} AccountSid A 34 character string that uniquely identifies this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidmediaTypeExtensionGet(mediaTypeExtension, AccountSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidmediaTypeExtensionGet(mediaTypeExtension, AccountSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Allows you to modify the properties of an account.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} AccountSid A 34 character string that uniquely identifies this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidmediaTypeExtensionPost(mediaTypeExtension, AccountSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidmediaTypeExtensionPost(mediaTypeExtension, AccountSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Allows you to modify the properties of an account.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} AccountSid A 34 character string that uniquely identifies this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidmediaTypeExtensionPut(mediaTypeExtension, AccountSid, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsAccountSidmediaTypeExtensionPut(mediaTypeExtension, AccountSid, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a list of the Account resources belonging to the account used to make the API request. This list will include that Account as well.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsmediaTypeExtensionGet(mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsmediaTypeExtensionGet(mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Account instance resource as a subaccount of the one used to make the request. See Creating Subaccounts for more information.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsmediaTypeExtensionPost(mediaTypeExtension, options) {
            const localVarFetchArgs = exports.DefaultApiFetchParamCreator(configuration).accountsmediaTypeExtensionPost(mediaTypeExtension, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.DefaultApiFp = DefaultApiFp;
/**
 * DefaultApi - factory interface
 * @export
 */
const DefaultApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Delete this application.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ApplicationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsApplicationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, ApplicationSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidApplicationsApplicationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, ApplicationSid, options)(fetch, basePath);
        },
        /**
         * Get application instance resource.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ApplicationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsApplicationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ApplicationSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidApplicationsApplicationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ApplicationSid, options)(fetch, basePath);
        },
        /**
         * Tries to update the application's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ApplicationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsApplicationSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ApplicationSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidApplicationsApplicationSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ApplicationSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of Application resource representations, each representing an application within your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidApplicationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Creates a new application within your account.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidApplicationsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidApplicationsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Get the properties of the authorized application.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ConnectAppSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAuthorizedConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidAuthorizedConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of Connect App resource representations, each representing a Connect App you've authorized to access your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAuthorizedConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidAuthorizedConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns a list of local AvailablePhoneNumber resource representations that match the specified filters, each representing a phone number tha is currently available for provisioning within your account.
         * @param {string} AccountSid
         * @param {string} IsoCountryCode ISO 3166-1 alpha-2.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAvailablePhoneNumbersIsoCountryCodeLocalmediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidAvailablePhoneNumbersIsoCountryCodeLocalmediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns a list of mobile AvailablePhoneNumber resource representations that match the specified filters, each representing a phone number that is currently available for provisioning within your account.
         * @param {string} AccountSid
         * @param {string} IsoCountryCode ISO 3166-1 alpha-2.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAvailablePhoneNumbersIsoCountryCodeMobilemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidAvailablePhoneNumbersIsoCountryCodeMobilemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns a list of toll-free AvailablePhoneNumber elements that match the specified filters, each representing a phone number that is currently available for provisioning within your account. To provision an available phone number, POST the number to the IncomingPhoneNumbers resource.
         * @param {string} AccountSid
         * @param {string} IsoCountryCode ISO 3166-1 alpha-2.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAvailablePhoneNumbersIsoCountryCodeTollFreemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidAvailablePhoneNumbersIsoCountryCodeTollFreemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns a list of all AvailablePhoneNumber subresources for your account by ISO Country. For full information about our phone number support, see our Phone Number CSV (http://www.twilio.com/resources/rates/international-phone-number-rates.csv).
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidAvailablePhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidAvailablePhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns a list of notifications generated for an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {string} CallSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsCallSidNotificationsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidCallsCallSidNotificationsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns a list of Recording resource representations, each representing a recording generated during the course of a phone call.
         * @param {string} AccountSid
         * @param {string} CallSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsCallSidRecordingsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidCallsCallSidRecordingsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns the single Call resource identified by {CallSid}.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsCallSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CallSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidCallsCallSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CallSid, options)(fetch, basePath);
        },
        /**
         * Modify a phone call.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsCallSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CallSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidCallsCallSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CallSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of phone calls made to and from the account identified by {AccountSid}.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidCallsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * To make a call, make an HTTP POST request. Initiate a new phone call.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidCallsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidCallsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Kick this participant from the conference.
         * @param {string} AccountSid
         * @param {string} ConferenceSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionDelete(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionDelete(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options)(fetch, basePath);
        },
        /**
         * Returns a representation of this participant.
         * @param {string} AccountSid
         * @param {string} ConferenceSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options)(fetch, basePath);
        },
        /**
         * Updates the status of a participant.
         * @param {string} AccountSid
         * @param {string} ConferenceSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionPost(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionPost(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options)(fetch, basePath);
        },
        /**
         * Returns the list of participants in the conference identified by {ConferenceSid}.
         * @param {string} AccountSid
         * @param {string} ConferenceSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidParticipantsmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidConferencesConferenceSidParticipantsmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns a representation of the conference identified by {ConferenceSid}.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ConferenceSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesConferenceSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConferenceSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidConferencesConferenceSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConferenceSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of conferences within an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConferencesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidConferencesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Get the properties of a Connect App.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ConnectAppSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options)(fetch, basePath);
        },
        /**
         * Tries to update the Connect App's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ConnectAppSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ConnectAppSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ConnectAppSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of Connect App resource representations, each representing a Connect App in your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Release this phone number from your account. Twilio will no longer answer calls to this number, and you will stop being billed the monthly phone number fee. The phone number will eventually be recycled and potentially given to another customer, so use with care. If you make a mistake, contac us. We may be able to give you the number back.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IncomingPhoneNumberSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options)(fetch, basePath);
        },
        /**
         * Get info about incoming call's phone number.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IncomingPhoneNumberSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options)(fetch, basePath);
        },
        /**
         * Tries to update the incoming phone number's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IncomingPhoneNumberSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options)(fetch, basePath);
        },
        /**
         * Tries to update the incoming phone number's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IncomingPhoneNumberSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of local <IncomingPhoneNumber> elements, each representing a local (not toll-free) phone number given to your account, under an <IncomingPhoneNumbers> list element that includes paging information. Works exactly the same as the IncomingPhoneNumber resource, but filters out toll-free numbers.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Adds a new phone number to your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns a list of local <IncomingPhoneNumber> elements, each representing a mobile phone number given to your account, under an <IncomingPhoneNumbers> list element that includes paging information. Works exactly the same as the IncomingPhoneNumber resource, but filters out local and toll free numbers.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Adds a new phone number to your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns a list of local <IncomingPhoneNumber> elements, each representing a toll-free phone number given to your account, under an <IncomingPhoneNumbers> list element that includes paging information. Works exactly the same as the IncomingPhoneNumber resource, but filters out all numbers that aren't toll-free.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Adds a new phone number to your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns a list of IncomingPhoneNumber resource representations, each representing a phone number given to your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Purchases a new phone number for your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number. To find an available phone number to POST, use the subresources of the AvailablePhoneNumbers list resource.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Without an extension, the media is returned using the mime-type provided when the media was generated.
         * @param {string} AccountSid
         * @param {string} MessageSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} MediaSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesMessageSidMediaMediaSidmediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, MediaSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidMessagesMessageSidMediaMediaSidmediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, MediaSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of media associated with your message.
         * @param {string} AccountSid
         * @param {string} MessageSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesMessageSidMediamediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidMessagesMessageSidMediamediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns a single message specified by the provided {MessageSid}.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} MessageSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesMessageSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, MessageSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidMessagesMessageSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, MessageSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of messages associated with your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidMessagesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * To send a new outgoing message, make an HTTP POST to your Messages list resource URI
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} To The destination phone number. Format with a &#39;+&#39; and country code e.g., +16175551212 (E.164 format).
         * @param {string} [From] A Twilio phone number (in E.164 format) or alphanumeric sender ID enabled for the type of message you wish to send. Phone numbers or short codes purchased from Twilio work here. You cannot (for example) spoof messages from your own cell phone number.
         * @param {string} [MessagingServiceSid] The 34 character unique id of the Messaging Service you want to associate with this Message. Set this parameter to use the Messaging Service Settings and Copilot Features you have configured. When only this parameter is set, Twilio will use your enabled Copilot Features to select the From phone number for delivery.
         * @param {string} [Body] The text of the message you want to send, limited to 1600 characters.
         * @param {string} [MediaUrl] The URL of the media you wish to send out with the message. gif , png and jpeg content is currently supported and will be formatted correctly on the recipient&#39;s device. Other types are also accepted by the API. The media size limit is 5MB. If you wish to send more than one image in the message body, please provide multiple MediaUrls values in the POST request. You may include up to 10 MediaUrls per message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidMessagesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, To, From, MessagingServiceSid, Body, MediaUrl, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidMessagesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, To, From, MessagingServiceSid, Body, MediaUrl, options)(fetch, basePath);
        },
        /**
         * Deletes the notification identified by {NotificationSid} from an account's log.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} NotificationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidNotificationsNotificationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, NotificationSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidNotificationsNotificationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, NotificationSid, options)(fetch, basePath);
        },
        /**
         * Get a notification entry.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} NotificationSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidNotificationsNotificationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, NotificationSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidNotificationsNotificationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, NotificationSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of notifications generated for an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidNotificationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidNotificationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Deletes the caller ID from the account. Returns an HTTP 204 response if successful, with no body.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} OutgoingCallerIdSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options)(fetch, basePath);
        },
        /**
         * Get the set of an account's verified phone numbers.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} OutgoingCallerIdSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options)(fetch, basePath);
        },
        /**
         * Updates the caller id, and returns the updated resource if successful.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} OutgoingCallerIdSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options)(fetch, basePath);
        },
        /**
         * Updates the caller id, and returns the updated resource if successful.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} OutgoingCallerIdSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of OutgoingCallerId resource representations, each representing a Caller ID number valid for an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidOutgoingCallerIdsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Adds a new CallerID to your account.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidOutgoingCallerIdsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidOutgoingCallerIdsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Get a specific member.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, CallSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, CallSid, options)(fetch, basePath);
        },
        /**
         * Posting a URL and Method to a Queue instance will dequeue a member from a queue and have the member's call begin executing the TwiML document at that URL When redirecting a member of a queue addressed by CallSid, only the first request will succeed and return a 200 response code. A second request will fail and return an appropriate 400 response code.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CallSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, CallSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, CallSid, options)(fetch, basePath);
        },
        /**
         * Get a front member.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Posting a URL and Method to a Queue instance will dequeue a member from a queue and have the member's call begin executing the TwiML document at that URL When dequeuing the 'Front' of the queue, the next call in the queue will be redirected.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns the list of members in the queue identified by {QueueSid}.
         * @param {string} AccountSid
         * @param {string} QueueSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidMembersmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidQueuesQueueSidMembersmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * The DELETE method allows you to remove a Queue. Only empty queues are deletable.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} QueueSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, QueueSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidQueuesQueueSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, QueueSid, options)(fetch, basePath);
        },
        /**
         * Get resource's individual Queue instance.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} QueueSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, QueueSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidQueuesQueueSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, QueueSid, options)(fetch, basePath);
        },
        /**
         * This POST request allows you to change the FriendlyName or MaxSize.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} QueueSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesQueueSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, QueueSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidQueuesQueueSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, QueueSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of queues within an account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidQueuesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Create a new Queue resource.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidQueuesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidQueuesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns a set of Transcription resource representations that includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} RecordingSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidRecordingsRecordingSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidRecordingsRecordingSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options)(fetch, basePath);
        },
        /**
         * Deletes a recording  from your account.
         * @param {string} AccountSid
         * @param {'.xml' | '.wav' | '.mp3'} mediaTypeExtension
         * @param {string} RecordingSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidRecordingsRecordingSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, RecordingSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidRecordingsRecordingSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, RecordingSid, options)(fetch, basePath);
        },
        /**
         * Returns one of several representations: Without an extension, or with a \".wav\", a binary WAV audio file is returned with mime-type \"audio/x-wav\". Appending \".mp3\" to the URI returns a binary MP3 audio file with mime-type type \"audio/mpeg\". Appending \".xml\" to the URI returns a XML representation.
         * @param {string} AccountSid
         * @param {'.xml' | '.wav' | '.mp3'} mediaTypeExtension
         * @param {string} RecordingSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidRecordingsRecordingSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidRecordingsRecordingSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of Recording resource representations, each representing a recording generated during the course of a phone call.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidRecordingsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidRecordingsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Remove a Credential from a CredentialList.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CredentialSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionDelete(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionDelete(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options)(fetch, basePath);
        },
        /**
         * Get a specific Credential in a list. Though a password is stored for each username in your list, the password is not returned to protect your password. If you cannot remember your password, you will need to POST to this resource to update it.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CredentialSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options)(fetch, basePath);
        },
        /**
         * Change the password of a Credential record.  If the change is successful, Twilio will respond with the Credential record but will not include the password in the response.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CredentialSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options)(fetch, basePath);
        },
        /**
         * Get the list of Credentials in a CredentialList. The passwords for the Credentials are intentionally not returned so as to protect them.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Add a Credential to the CredentialList.  When creating a Credential, you will POST both a username and password, but only receive the username back in the response. The password is intentionally not returned so as to protect it.
         * @param {string} AccountSid
         * @param {string} CLSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Delete a CredentialList from your account. It can only be deleted if no domains are mapped to it. If you attempt to delete one that is mapped to a domain, you will receive an error.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CLSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, CLSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, CLSid, options)(fetch, basePath);
        },
        /**
         * Get a credential list instance resource
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CLSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CLSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CLSid, options)(fetch, basePath);
        },
        /**
         * Change the FriendlyName of the list
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CLSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CLSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CLSid, options)(fetch, basePath);
        },
        /**
         * Gets a list of Credential Lists for an account
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPCredentialListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Create a new Credential List.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPCredentialListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPCredentialListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Remove a CredentialListMapping from a domain
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} CLSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsCLSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, CLSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsCLSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, CLSid, options)(fetch, basePath);
        },
        /**
         * Get the user lists mapped to this domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Map a CredentialList to the domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Remove a mapping from this domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ALSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options)(fetch, basePath);
        },
        /**
         * Return a specific IpAccessControlListMapping instance by Sid.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ALSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options)(fetch, basePath);
        },
        /**
         * Return the IpAccessControlListMappings that are associated to this domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Map an IpAccessControlList to this domain.
         * @param {string} AccountSid
         * @param {string} SipDomainSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Delete a domain. If you have created subdomains of a domain, you will not be able to delete the domain until you first delete all subdomains of it.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} SipDomainSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, SipDomainSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, SipDomainSid, options)(fetch, basePath);
        },
        /**
         * Return a specific instance by Sid.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} SipDomainSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, SipDomainSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, SipDomainSid, options)(fetch, basePath);
        },
        /**
         * Update the attributes of a domain.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} SipDomainSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, SipDomainSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, SipDomainSid, options)(fetch, basePath);
        },
        /**
         * Returns a paged list of the domains for an account.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPDomainsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Creates a new Domain and returns its instance resource. You must pick a unique domain name that ends in \".sip.twilio.com\". After creating a Domain, you must map it to an authentication method before the domain is ready to receive traffic.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPDomainsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPDomainsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Deletes an IP address entry from the list.
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAddressSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionDelete(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionDelete(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options)(fetch, basePath);
        },
        /**
         * Return a single IP Address resource.
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAddressSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options)(fetch, basePath);
        },
        /**
         * Change the description or IP address of a given IpAddress instance resource
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAddressSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options)(fetch, basePath);
        },
        /**
         * List the IP Addresses contained in this list.
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Add an IP Address to the list with a description.
         * @param {string} AccountSid
         * @param {string} IpAccessControlListSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Delete an IpAccessControlList from your account. It can only be deleted if no domains are mapped to it. If you attempt to delete one that is mapped to a domain, you will receive an error.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAccessControlListSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IpAccessControlListSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IpAccessControlListSid, options)(fetch, basePath);
        },
        /**
         * Return a specific IpAccessControlList resource.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAccessControlListSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IpAccessControlListSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IpAccessControlListSid, options)(fetch, basePath);
        },
        /**
         * Rename an IpAccessControlList.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} IpAccessControlListSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IpAccessControlListSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IpAccessControlListSid, options)(fetch, basePath);
        },
        /**
         * Return a paged list of all IpAccessControlLists under this account.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Create a new IpAccessControlList resource.  When created, the list will contain no IP addresses. You will need to add IP addresses to the list for it to be active. To add IP addresses, you will need to POST to the IpAddresses List subresource.
         * @param {string} AccountSid
         * @param {string} mediaTypeExtension
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Get a single message.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ShortCodeSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ShortCodeSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ShortCodeSid, options)(fetch, basePath);
        },
        /**
         * Tries to update the shortcode's properties, and returns the updated resource representation if successful.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} ShortCodeSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ShortCodeSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ShortCodeSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of ShortCode resource representations, each representing a short code within your account. The list includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidSMSShortCodesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidSMSShortCodesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Deletes a transcription from your account.
         * @param {string} AccountSid
         * @param {'.json' | '.csv' | '.html' | '.txt' | '.xml'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} TranscriptionSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, TranscriptionSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, TranscriptionSid, options)(fetch, basePath);
        },
        /**
         * Returns a single Transcription resource representation identified by the given {TranscriptionSid}. By default Twilio will respond with the XML metadata for the Transcription. If you append \".txt\" to the end of the Transcription resource's URI Twilio will just return you the transcription tex.
         * @param {string} AccountSid
         * @param {'.json' | '.csv' | '.html' | '.txt' | '.xml'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} TranscriptionSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, TranscriptionSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, TranscriptionSid, options)(fetch, basePath);
        },
        /**
         * Returns a set of Transcription resource representations that includes paging information.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns UsageRecords for all usage categories for a specified period.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {'Daily' | 'Monthly' | 'Yearly' | 'AllTime' | 'Today' | 'Yesterday' | 'ThisMonth' | 'LastMonth'} Subresource |Subresource|Description| |---|---| |Daily|Return multiple UsageRecords for each usage category, each representing usage over a daily time-interval.| |Monthly|Return multiple UsageRecords for each usage category, each representing usage over a monthly time-interval.| |Yearly|Return multple UsageRecords for each usage category, each representing usage over a yearly time-interval.| |AllTime|  Return a single UsageRecord for each usage category, each representing usage over the date-range specified. This is the same as the root /Usage/Records.| |Today|Return a single UsageRecord per usage category, for today&#39;s usage only.| ||Yesterday|Return a single UsageRecord per usage category, for yesterday&#39;s usage only.| |ThisMonth|Return a single UsageRecord per usage category, for this month&#39;s usage only.| |LastMonth|Return a single UsageRecord per usage category, for last month&#39;s usage only.|
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageRecordsSubresourcemediaTypeExtensionGet(AccountSid, mediaTypeExtension, Subresource, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidUsageRecordsSubresourcemediaTypeExtensionGet(AccountSid, mediaTypeExtension, Subresource, options)(fetch, basePath);
        },
        /**
         * Returns UsageRecords for all usage categories. The list includes paging information. By default, the UsageRecords resource will return one UsageRecord for each Category, representing all usage accrued all-time for the account. You can filter the usage Category or change the date-range over which usage is counted using optional GET query parameters.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageRecordsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidUsageRecordsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Delete this UsageTrigger.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} UsageTriggerSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, UsageTriggerSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, UsageTriggerSid, options)(fetch, basePath);
        },
        /**
         * Returns a repesentation of the UsageTrigger.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} UsageTriggerSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, UsageTriggerSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, UsageTriggerSid, options)(fetch, basePath);
        },
        /**
         * Tries to update the UsageTrigger's properties, and returns the updated resource representation if successful.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} UsageTriggerSid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, UsageTriggerSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, UsageTriggerSid, options)(fetch, basePath);
        },
        /**
         * Returns a list of UsageTrigger resource representations. The list includes paging information. By default, all UsageTriggers are returned. You can filter the list by specifying one or more query parameters. Note that the query parameters are case-sensitive
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidUsageTriggersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Creates a new UsageTrigger. Each account can create up to 1,000 UsageTriggers. Currently, UsageTriggers that are no longer active are not deleted automatically. Use DELETE to delete triggers you no longer need.
         * @param {string} AccountSid
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidUsageTriggersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidUsageTriggersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Returns a representation of an account.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} AccountSid A 34 character string that uniquely identifies this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidmediaTypeExtensionGet(mediaTypeExtension, AccountSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidmediaTypeExtensionGet(mediaTypeExtension, AccountSid, options)(fetch, basePath);
        },
        /**
         * Allows you to modify the properties of an account.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} AccountSid A 34 character string that uniquely identifies this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidmediaTypeExtensionPost(mediaTypeExtension, AccountSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidmediaTypeExtensionPost(mediaTypeExtension, AccountSid, options)(fetch, basePath);
        },
        /**
         * Allows you to modify the properties of an account.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {string} AccountSid A 34 character string that uniquely identifies this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountSidmediaTypeExtensionPut(mediaTypeExtension, AccountSid, options) {
            return exports.DefaultApiFp(configuration).accountsAccountSidmediaTypeExtensionPut(mediaTypeExtension, AccountSid, options)(fetch, basePath);
        },
        /**
         * Retrieve a list of the Account resources belonging to the account used to make the API request. This list will include that Account as well.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsmediaTypeExtensionGet(mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsmediaTypeExtensionGet(mediaTypeExtension, options)(fetch, basePath);
        },
        /**
         * Create a new Account instance resource as a subaccount of the one used to make the request. See Creating Subaccounts for more information.
         * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsmediaTypeExtensionPost(mediaTypeExtension, options) {
            return exports.DefaultApiFp(configuration).accountsmediaTypeExtensionPost(mediaTypeExtension, options)(fetch, basePath);
        },
    };
};
exports.DefaultApiFactory = DefaultApiFactory;
/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
class DefaultApi extends BaseAPI {
    /**
     * Delete this application.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} ApplicationSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidApplicationsApplicationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, ApplicationSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidApplicationsApplicationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, ApplicationSid, options)(this.fetch, this.basePath);
    }
    /**
     * Get application instance resource.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} ApplicationSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidApplicationsApplicationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ApplicationSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidApplicationsApplicationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ApplicationSid, options)(this.fetch, this.basePath);
    }
    /**
     * Tries to update the application's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} ApplicationSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidApplicationsApplicationSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ApplicationSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidApplicationsApplicationSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ApplicationSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of Application resource representations, each representing an application within your account. The list includes paging information.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidApplicationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidApplicationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Creates a new application within your account.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidApplicationsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidApplicationsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Get the properties of the authorized application.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} ConnectAppSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidAuthorizedConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidAuthorizedConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of Connect App resource representations, each representing a Connect App you've authorized to access your account. The list includes paging information.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidAuthorizedConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidAuthorizedConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of local AvailablePhoneNumber resource representations that match the specified filters, each representing a phone number tha is currently available for provisioning within your account.
     * @param {string} AccountSid
     * @param {string} IsoCountryCode ISO 3166-1 alpha-2.
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidAvailablePhoneNumbersIsoCountryCodeLocalmediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidAvailablePhoneNumbersIsoCountryCodeLocalmediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of mobile AvailablePhoneNumber resource representations that match the specified filters, each representing a phone number that is currently available for provisioning within your account.
     * @param {string} AccountSid
     * @param {string} IsoCountryCode ISO 3166-1 alpha-2.
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidAvailablePhoneNumbersIsoCountryCodeMobilemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidAvailablePhoneNumbersIsoCountryCodeMobilemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of toll-free AvailablePhoneNumber elements that match the specified filters, each representing a phone number that is currently available for provisioning within your account. To provision an available phone number, POST the number to the IncomingPhoneNumbers resource.
     * @param {string} AccountSid
     * @param {string} IsoCountryCode ISO 3166-1 alpha-2.
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidAvailablePhoneNumbersIsoCountryCodeTollFreemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidAvailablePhoneNumbersIsoCountryCodeTollFreemediaTypeExtensionGet(AccountSid, IsoCountryCode, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of all AvailablePhoneNumber subresources for your account by ISO Country. For full information about our phone number support, see our Phone Number CSV (http://www.twilio.com/resources/rates/international-phone-number-rates.csv).
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidAvailablePhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidAvailablePhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of notifications generated for an account. The list includes paging information.
     * @param {string} AccountSid
     * @param {string} CallSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidCallsCallSidNotificationsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidCallsCallSidNotificationsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of Recording resource representations, each representing a recording generated during the course of a phone call.
     * @param {string} AccountSid
     * @param {string} CallSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidCallsCallSidRecordingsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidCallsCallSidRecordingsmediaTypeExtensionGet(AccountSid, CallSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the single Call resource identified by {CallSid}.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CallSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidCallsCallSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CallSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidCallsCallSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CallSid, options)(this.fetch, this.basePath);
    }
    /**
     * Modify a phone call.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CallSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidCallsCallSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CallSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidCallsCallSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CallSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of phone calls made to and from the account identified by {AccountSid}.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidCallsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidCallsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * To make a call, make an HTTP POST request. Initiate a new phone call.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidCallsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidCallsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Kick this participant from the conference.
     * @param {string} AccountSid
     * @param {string} ConferenceSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CallSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionDelete(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionDelete(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a representation of this participant.
     * @param {string} AccountSid
     * @param {string} ConferenceSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CallSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options)(this.fetch, this.basePath);
    }
    /**
     * Updates the status of a participant.
     * @param {string} AccountSid
     * @param {string} ConferenceSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CallSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionPost(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidConferencesConferenceSidParticipantsCallSidmediaTypeExtensionPost(AccountSid, ConferenceSid, mediaTypeExtension, CallSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the list of participants in the conference identified by {ConferenceSid}.
     * @param {string} AccountSid
     * @param {string} ConferenceSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidConferencesConferenceSidParticipantsmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidConferencesConferenceSidParticipantsmediaTypeExtensionGet(AccountSid, ConferenceSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a representation of the conference identified by {ConferenceSid}.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} ConferenceSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidConferencesConferenceSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConferenceSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidConferencesConferenceSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConferenceSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of conferences within an account. The list includes paging information.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidConferencesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidConferencesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Get the properties of a Connect App.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} ConnectAppSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ConnectAppSid, options)(this.fetch, this.basePath);
    }
    /**
     * Tries to update the Connect App's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} ConnectAppSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ConnectAppSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidConnectAppsConnectAppSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ConnectAppSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of Connect App resource representations, each representing a Connect App in your account. The list includes paging information.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidConnectAppsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Release this phone number from your account. Twilio will no longer answer calls to this number, and you will stop being billed the monthly phone number fee. The phone number will eventually be recycled and potentially given to another customer, so use with care. If you make a mistake, contac us. We may be able to give you the number back.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} IncomingPhoneNumberSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options)(this.fetch, this.basePath);
    }
    /**
     * Get info about incoming call's phone number.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} IncomingPhoneNumberSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options)(this.fetch, this.basePath);
    }
    /**
     * Tries to update the incoming phone number's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} IncomingPhoneNumberSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options)(this.fetch, this.basePath);
    }
    /**
     * Tries to update the incoming phone number's properties, and returns the updated resource representation if successful. The returned response is identical to that returned above when making a GET request.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} IncomingPhoneNumberSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidIncomingPhoneNumbersIncomingPhoneNumberSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, IncomingPhoneNumberSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of local <IncomingPhoneNumber> elements, each representing a local (not toll-free) phone number given to your account, under an <IncomingPhoneNumbers> list element that includes paging information. Works exactly the same as the IncomingPhoneNumber resource, but filters out toll-free numbers.
     * @param {string} AccountSid
     * @param {string} mediaTypeExtension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Adds a new phone number to your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number.
     * @param {string} AccountSid
     * @param {string} mediaTypeExtension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidIncomingPhoneNumbersLocalmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of local <IncomingPhoneNumber> elements, each representing a mobile phone number given to your account, under an <IncomingPhoneNumbers> list element that includes paging information. Works exactly the same as the IncomingPhoneNumber resource, but filters out local and toll free numbers.
     * @param {string} AccountSid
     * @param {string} mediaTypeExtension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Adds a new phone number to your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number.
     * @param {string} AccountSid
     * @param {string} mediaTypeExtension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidIncomingPhoneNumbersMobilemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of local <IncomingPhoneNumber> elements, each representing a toll-free phone number given to your account, under an <IncomingPhoneNumbers> list element that includes paging information. Works exactly the same as the IncomingPhoneNumber resource, but filters out all numbers that aren't toll-free.
     * @param {string} AccountSid
     * @param {string} mediaTypeExtension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Adds a new phone number to your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number.
     * @param {string} AccountSid
     * @param {string} mediaTypeExtension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidIncomingPhoneNumbersTollFreemediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of IncomingPhoneNumber resource representations, each representing a phone number given to your account. The list includes paging information.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Purchases a new phone number for your account. If a phone number is found for your request, Twilio will add it to your account and bill you for the first month's cost of the phone number. To find an available phone number to POST, use the subresources of the AvailablePhoneNumbers list resource.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidIncomingPhoneNumbersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Without an extension, the media is returned using the mime-type provided when the media was generated.
     * @param {string} AccountSid
     * @param {string} MessageSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} MediaSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidMessagesMessageSidMediaMediaSidmediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, MediaSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidMessagesMessageSidMediaMediaSidmediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, MediaSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of media associated with your message.
     * @param {string} AccountSid
     * @param {string} MessageSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidMessagesMessageSidMediamediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidMessagesMessageSidMediamediaTypeExtensionGet(AccountSid, MessageSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a single message specified by the provided {MessageSid}.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} MessageSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidMessagesMessageSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, MessageSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidMessagesMessageSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, MessageSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of messages associated with your account. The list includes paging information.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidMessagesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidMessagesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * To send a new outgoing message, make an HTTP POST to your Messages list resource URI
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} To The destination phone number. Format with a &#39;+&#39; and country code e.g., +16175551212 (E.164 format).
     * @param {string} [From] A Twilio phone number (in E.164 format) or alphanumeric sender ID enabled for the type of message you wish to send. Phone numbers or short codes purchased from Twilio work here. You cannot (for example) spoof messages from your own cell phone number.
     * @param {string} [MessagingServiceSid] The 34 character unique id of the Messaging Service you want to associate with this Message. Set this parameter to use the Messaging Service Settings and Copilot Features you have configured. When only this parameter is set, Twilio will use your enabled Copilot Features to select the From phone number for delivery.
     * @param {string} [Body] The text of the message you want to send, limited to 1600 characters.
     * @param {string} [MediaUrl] The URL of the media you wish to send out with the message. gif , png and jpeg content is currently supported and will be formatted correctly on the recipient&#39;s device. Other types are also accepted by the API. The media size limit is 5MB. If you wish to send more than one image in the message body, please provide multiple MediaUrls values in the POST request. You may include up to 10 MediaUrls per message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidMessagesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, To, From, MessagingServiceSid, Body, MediaUrl, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidMessagesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, To, From, MessagingServiceSid, Body, MediaUrl, options)(this.fetch, this.basePath);
    }
    /**
     * Deletes the notification identified by {NotificationSid} from an account's log.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} NotificationSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidNotificationsNotificationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, NotificationSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidNotificationsNotificationSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, NotificationSid, options)(this.fetch, this.basePath);
    }
    /**
     * Get a notification entry.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} NotificationSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidNotificationsNotificationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, NotificationSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidNotificationsNotificationSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, NotificationSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of notifications generated for an account. The list includes paging information.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidNotificationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidNotificationsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Deletes the caller ID from the account. Returns an HTTP 204 response if successful, with no body.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} OutgoingCallerIdSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options)(this.fetch, this.basePath);
    }
    /**
     * Get the set of an account's verified phone numbers.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} OutgoingCallerIdSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options)(this.fetch, this.basePath);
    }
    /**
     * Updates the caller id, and returns the updated resource if successful.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} OutgoingCallerIdSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options)(this.fetch, this.basePath);
    }
    /**
     * Updates the caller id, and returns the updated resource if successful.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} OutgoingCallerIdSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidOutgoingCallerIdsOutgoingCallerIdSidmediaTypeExtensionPut(AccountSid, mediaTypeExtension, OutgoingCallerIdSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of OutgoingCallerId resource representations, each representing a Caller ID number valid for an account. The list includes paging information.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidOutgoingCallerIdsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidOutgoingCallerIdsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Adds a new CallerID to your account.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidOutgoingCallerIdsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidOutgoingCallerIdsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Get a specific member.
     * @param {string} AccountSid
     * @param {string} QueueSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CallSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, CallSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, CallSid, options)(this.fetch, this.basePath);
    }
    /**
     * Posting a URL and Method to a Queue instance will dequeue a member from a queue and have the member's call begin executing the TwiML document at that URL When redirecting a member of a queue addressed by CallSid, only the first request will succeed and return a 200 response code. A second request will fail and return an appropriate 400 response code.
     * @param {string} AccountSid
     * @param {string} QueueSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CallSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, CallSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidQueuesQueueSidMembersCallSidmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, CallSid, options)(this.fetch, this.basePath);
    }
    /**
     * Get a front member.
     * @param {string} AccountSid
     * @param {string} QueueSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Posting a URL and Method to a Queue instance will dequeue a member from a queue and have the member's call begin executing the TwiML document at that URL When dequeuing the 'Front' of the queue, the next call in the queue will be redirected.
     * @param {string} AccountSid
     * @param {string} QueueSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidQueuesQueueSidMembersFrontmediaTypeExtensionPost(AccountSid, QueueSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the list of members in the queue identified by {QueueSid}.
     * @param {string} AccountSid
     * @param {string} QueueSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidQueuesQueueSidMembersmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidQueuesQueueSidMembersmediaTypeExtensionGet(AccountSid, QueueSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * The DELETE method allows you to remove a Queue. Only empty queues are deletable.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} QueueSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidQueuesQueueSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, QueueSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidQueuesQueueSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, QueueSid, options)(this.fetch, this.basePath);
    }
    /**
     * Get resource's individual Queue instance.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} QueueSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidQueuesQueueSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, QueueSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidQueuesQueueSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, QueueSid, options)(this.fetch, this.basePath);
    }
    /**
     * This POST request allows you to change the FriendlyName or MaxSize.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} QueueSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidQueuesQueueSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, QueueSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidQueuesQueueSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, QueueSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of queues within an account. The list includes paging information.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidQueuesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidQueuesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new Queue resource.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidQueuesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidQueuesmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a set of Transcription resource representations that includes paging information.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} RecordingSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidRecordingsRecordingSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidRecordingsRecordingSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options)(this.fetch, this.basePath);
    }
    /**
     * Deletes a recording  from your account.
     * @param {string} AccountSid
     * @param {'.xml' | '.wav' | '.mp3'} mediaTypeExtension
     * @param {string} RecordingSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidRecordingsRecordingSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, RecordingSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidRecordingsRecordingSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, RecordingSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns one of several representations: Without an extension, or with a \".wav\", a binary WAV audio file is returned with mime-type \"audio/x-wav\". Appending \".mp3\" to the URI returns a binary MP3 audio file with mime-type type \"audio/mpeg\". Appending \".xml\" to the URI returns a XML representation.
     * @param {string} AccountSid
     * @param {'.xml' | '.wav' | '.mp3'} mediaTypeExtension
     * @param {string} RecordingSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidRecordingsRecordingSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidRecordingsRecordingSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, RecordingSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of Recording resource representations, each representing a recording generated during the course of a phone call.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidRecordingsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidRecordingsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Remove a Credential from a CredentialList.
     * @param {string} AccountSid
     * @param {string} CLSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CredentialSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionDelete(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionDelete(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options)(this.fetch, this.basePath);
    }
    /**
     * Get a specific Credential in a list. Though a password is stored for each username in your list, the password is not returned to protect your password. If you cannot remember your password, you will need to POST to this resource to update it.
     * @param {string} AccountSid
     * @param {string} CLSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CredentialSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options)(this.fetch, this.basePath);
    }
    /**
     * Change the password of a Credential record.  If the change is successful, Twilio will respond with the Credential record but will not include the password in the response.
     * @param {string} AccountSid
     * @param {string} CLSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CredentialSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsCredentialSidmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, CredentialSid, options)(this.fetch, this.basePath);
    }
    /**
     * Get the list of Credentials in a CredentialList. The passwords for the Credentials are intentionally not returned so as to protect them.
     * @param {string} AccountSid
     * @param {string} CLSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionGet(AccountSid, CLSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Add a Credential to the CredentialList.  When creating a Credential, you will POST both a username and password, but only receive the username back in the response. The password is intentionally not returned so as to protect it.
     * @param {string} AccountSid
     * @param {string} CLSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPCredentialListsCLSidCredentialsmediaTypeExtensionPost(AccountSid, CLSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a CredentialList from your account. It can only be deleted if no domains are mapped to it. If you attempt to delete one that is mapped to a domain, you will receive an error.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CLSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, CLSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, CLSid, options)(this.fetch, this.basePath);
    }
    /**
     * Get a credential list instance resource
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CLSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CLSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, CLSid, options)(this.fetch, this.basePath);
    }
    /**
     * Change the FriendlyName of the list
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CLSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CLSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPCredentialListsCLSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, CLSid, options)(this.fetch, this.basePath);
    }
    /**
     * Gets a list of Credential Lists for an account
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPCredentialListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPCredentialListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new Credential List.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPCredentialListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPCredentialListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Remove a CredentialListMapping from a domain
     * @param {string} AccountSid
     * @param {string} SipDomainSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} CLSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsCLSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, CLSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsCLSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, CLSid, options)(this.fetch, this.basePath);
    }
    /**
     * Get the user lists mapped to this domain.
     * @param {string} AccountSid
     * @param {string} SipDomainSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Map a CredentialList to the domain.
     * @param {string} AccountSid
     * @param {string} SipDomainSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPDomainsSipDomainSidCredentialListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Remove a mapping from this domain.
     * @param {string} AccountSid
     * @param {string} SipDomainSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} ALSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionDelete(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options)(this.fetch, this.basePath);
    }
    /**
     * Return a specific IpAccessControlListMapping instance by Sid.
     * @param {string} AccountSid
     * @param {string} SipDomainSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} ALSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsALSidmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, ALSid, options)(this.fetch, this.basePath);
    }
    /**
     * Return the IpAccessControlListMappings that are associated to this domain.
     * @param {string} AccountSid
     * @param {string} SipDomainSid
     * @param {string} mediaTypeExtension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionGet(AccountSid, SipDomainSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Map an IpAccessControlList to this domain.
     * @param {string} AccountSid
     * @param {string} SipDomainSid
     * @param {string} mediaTypeExtension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPDomainsSipDomainSidIpAccessControlListMappingsmediaTypeExtensionPost(AccountSid, SipDomainSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a domain. If you have created subdomains of a domain, you will not be able to delete the domain until you first delete all subdomains of it.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} SipDomainSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, SipDomainSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, SipDomainSid, options)(this.fetch, this.basePath);
    }
    /**
     * Return a specific instance by Sid.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} SipDomainSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, SipDomainSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, SipDomainSid, options)(this.fetch, this.basePath);
    }
    /**
     * Update the attributes of a domain.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} SipDomainSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, SipDomainSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPDomainsSipDomainSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, SipDomainSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a paged list of the domains for an account.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPDomainsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPDomainsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Creates a new Domain and returns its instance resource. You must pick a unique domain name that ends in \".sip.twilio.com\". After creating a Domain, you must map it to an authentication method before the domain is ready to receive traffic.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPDomainsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPDomainsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Deletes an IP address entry from the list.
     * @param {string} AccountSid
     * @param {string} IpAccessControlListSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} IpAddressSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionDelete(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionDelete(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options)(this.fetch, this.basePath);
    }
    /**
     * Return a single IP Address resource.
     * @param {string} AccountSid
     * @param {string} IpAccessControlListSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} IpAddressSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options)(this.fetch, this.basePath);
    }
    /**
     * Change the description or IP address of a given IpAddress instance resource
     * @param {string} AccountSid
     * @param {string} IpAccessControlListSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} IpAddressSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesIpAddressSidmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, IpAddressSid, options)(this.fetch, this.basePath);
    }
    /**
     * List the IP Addresses contained in this list.
     * @param {string} AccountSid
     * @param {string} IpAccessControlListSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionGet(AccountSid, IpAccessControlListSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Add an IP Address to the list with a description.
     * @param {string} AccountSid
     * @param {string} IpAccessControlListSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidIpAddressesmediaTypeExtensionPost(AccountSid, IpAccessControlListSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Delete an IpAccessControlList from your account. It can only be deleted if no domains are mapped to it. If you attempt to delete one that is mapped to a domain, you will receive an error.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} IpAccessControlListSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IpAccessControlListSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, IpAccessControlListSid, options)(this.fetch, this.basePath);
    }
    /**
     * Return a specific IpAccessControlList resource.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} IpAccessControlListSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IpAccessControlListSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, IpAccessControlListSid, options)(this.fetch, this.basePath);
    }
    /**
     * Rename an IpAccessControlList.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} IpAccessControlListSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IpAccessControlListSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPIpAccessControlListsIpAccessControlListSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, IpAccessControlListSid, options)(this.fetch, this.basePath);
    }
    /**
     * Return a paged list of all IpAccessControlLists under this account.
     * @param {string} AccountSid
     * @param {string} mediaTypeExtension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new IpAccessControlList resource.  When created, the list will contain no IP addresses. You will need to add IP addresses to the list for it to be active. To add IP addresses, you will need to POST to the IpAddresses List subresource.
     * @param {string} AccountSid
     * @param {string} mediaTypeExtension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSIPIpAccessControlListsmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Get a single message.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} ShortCodeSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ShortCodeSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, ShortCodeSid, options)(this.fetch, this.basePath);
    }
    /**
     * Tries to update the shortcode's properties, and returns the updated resource representation if successful.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} ShortCodeSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ShortCodeSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSMSShortCodesShortCodeSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, ShortCodeSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of ShortCode resource representations, each representing a short code within your account. The list includes paging information.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidSMSShortCodesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidSMSShortCodesmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Deletes a transcription from your account.
     * @param {string} AccountSid
     * @param {'.json' | '.csv' | '.html' | '.txt' | '.xml'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} TranscriptionSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, TranscriptionSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, TranscriptionSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a single Transcription resource representation identified by the given {TranscriptionSid}. By default Twilio will respond with the XML metadata for the Transcription. If you append \".txt\" to the end of the Transcription resource's URI Twilio will just return you the transcription tex.
     * @param {string} AccountSid
     * @param {'.json' | '.csv' | '.html' | '.txt' | '.xml'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} TranscriptionSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, TranscriptionSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidTranscriptionsTranscriptionSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, TranscriptionSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a set of Transcription resource representations that includes paging information.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidTranscriptionsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns UsageRecords for all usage categories for a specified period.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {'Daily' | 'Monthly' | 'Yearly' | 'AllTime' | 'Today' | 'Yesterday' | 'ThisMonth' | 'LastMonth'} Subresource |Subresource|Description| |---|---| |Daily|Return multiple UsageRecords for each usage category, each representing usage over a daily time-interval.| |Monthly|Return multiple UsageRecords for each usage category, each representing usage over a monthly time-interval.| |Yearly|Return multple UsageRecords for each usage category, each representing usage over a yearly time-interval.| |AllTime|  Return a single UsageRecord for each usage category, each representing usage over the date-range specified. This is the same as the root /Usage/Records.| |Today|Return a single UsageRecord per usage category, for today&#39;s usage only.| ||Yesterday|Return a single UsageRecord per usage category, for yesterday&#39;s usage only.| |ThisMonth|Return a single UsageRecord per usage category, for this month&#39;s usage only.| |LastMonth|Return a single UsageRecord per usage category, for last month&#39;s usage only.|
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidUsageRecordsSubresourcemediaTypeExtensionGet(AccountSid, mediaTypeExtension, Subresource, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidUsageRecordsSubresourcemediaTypeExtensionGet(AccountSid, mediaTypeExtension, Subresource, options)(this.fetch, this.basePath);
    }
    /**
     * Returns UsageRecords for all usage categories. The list includes paging information. By default, the UsageRecords resource will return one UsageRecord for each Category, representing all usage accrued all-time for the account. You can filter the usage Category or change the date-range over which usage is counted using optional GET query parameters.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidUsageRecordsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidUsageRecordsmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Delete this UsageTrigger.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} UsageTriggerSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, UsageTriggerSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionDelete(AccountSid, mediaTypeExtension, UsageTriggerSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a repesentation of the UsageTrigger.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} UsageTriggerSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, UsageTriggerSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionGet(AccountSid, mediaTypeExtension, UsageTriggerSid, options)(this.fetch, this.basePath);
    }
    /**
     * Tries to update the UsageTrigger's properties, and returns the updated resource representation if successful.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} UsageTriggerSid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, UsageTriggerSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidUsageTriggersUsageTriggerSidmediaTypeExtensionPost(AccountSid, mediaTypeExtension, UsageTriggerSid, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of UsageTrigger resource representations. The list includes paging information. By default, all UsageTriggers are returned. You can filter the list by specifying one or more query parameters. Note that the query parameters are case-sensitive
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidUsageTriggersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidUsageTriggersmediaTypeExtensionGet(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Creates a new UsageTrigger. Each account can create up to 1,000 UsageTriggers. Currently, UsageTriggers that are no longer active are not deleted automatically. Use DELETE to delete triggers you no longer need.
     * @param {string} AccountSid
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidUsageTriggersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidUsageTriggersmediaTypeExtensionPost(AccountSid, mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a representation of an account.
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} AccountSid A 34 character string that uniquely identifies this account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidmediaTypeExtensionGet(mediaTypeExtension, AccountSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidmediaTypeExtensionGet(mediaTypeExtension, AccountSid, options)(this.fetch, this.basePath);
    }
    /**
     * Allows you to modify the properties of an account.
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} AccountSid A 34 character string that uniquely identifies this account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidmediaTypeExtensionPost(mediaTypeExtension, AccountSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidmediaTypeExtensionPost(mediaTypeExtension, AccountSid, options)(this.fetch, this.basePath);
    }
    /**
     * Allows you to modify the properties of an account.
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {string} AccountSid A 34 character string that uniquely identifies this account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsAccountSidmediaTypeExtensionPut(mediaTypeExtension, AccountSid, options) {
        return exports.DefaultApiFp(this.configuration).accountsAccountSidmediaTypeExtensionPut(mediaTypeExtension, AccountSid, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve a list of the Account resources belonging to the account used to make the API request. This list will include that Account as well.
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsmediaTypeExtensionGet(mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsmediaTypeExtensionGet(mediaTypeExtension, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new Account instance resource as a subaccount of the one used to make the request. See Creating Subaccounts for more information.
     * @param {'.xml' | '.json' | '.csv' | '.html'} mediaTypeExtension By default, Twilio&#39;s REST API returns XML. You may obtain CSV, JSON or HTML by appending \&quot;.csv\&quot;, \&quot;.json\&quot;, or \&quot;.html\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    accountsmediaTypeExtensionPost(mediaTypeExtension, options) {
        return exports.DefaultApiFp(this.configuration).accountsmediaTypeExtensionPost(mediaTypeExtension, options)(this.fetch, this.basePath);
    }
}
exports.DefaultApi = DefaultApi;
//# sourceMappingURL=api.js.map

/***/ }),
/* 198 */
/***/ (function(module, exports) {

// dummy unused file for future constants use


/***/ }),
/* 199 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/* unused harmony export BatchRequestContent */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _RequestMethod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */

/**
 * @module BatchRequestContent
 */

/**
 * @class
 * Class for handling BatchRequestContent
 */
class BatchRequestContent {
    /**
     * @public
     * @constructor
     * Constructs a BatchRequestContent instance
     * @param {BatchRequestStep[]} [requests] - Array of requests value
     * @returns An instance of a BatchRequestContent
     */
    constructor(requests) {
        this.requests = new Map();
        if (typeof requests !== "undefined") {
            const limit = BatchRequestContent.requestLimit;
            if (requests.length > limit) {
                const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);
                error.name = "Limit Exceeded Error";
                throw error;
            }
            for (const req of requests) {
                this.addRequest(req);
            }
        }
    }
    /**
     * @private
     * @static
     * Validates the dependency chain of the requests
     *
     * Note:
     * Individual requests can depend on other individual requests. Currently, requests can only depend on a single other request, and must follow one of these three patterns:
     * 1. Parallel - no individual request states a dependency in the dependsOn property.
     * 2. Serial - all individual requests depend on the previous individual request.
     * 3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.
     * As JSON batching matures, these limitations will be removed.
     * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}
     *
     * @param {Map<string, BatchRequestStep>} requests - The map of requests.
     * @returns The boolean indicating the validation status
     */
    static validateDependencies(requests) {
        const isParallel = (reqs) => {
            const iterator = reqs.entries();
            let cur = iterator.next();
            while (!cur.done) {
                const curReq = cur.value[1];
                if (curReq.dependsOn !== undefined && curReq.dependsOn.length > 0) {
                    return false;
                }
                cur = iterator.next();
            }
            return true;
        };
        const isSerial = (reqs) => {
            const iterator = reqs.entries();
            let cur = iterator.next();
            const firstRequest = cur.value[1];
            if (firstRequest.dependsOn !== undefined && firstRequest.dependsOn.length > 0) {
                return false;
            }
            let prev = cur;
            cur = iterator.next();
            while (!cur.done) {
                const curReq = cur.value[1];
                if (curReq.dependsOn === undefined || curReq.dependsOn.length !== 1 || curReq.dependsOn[0] !== prev.value[1].id) {
                    return false;
                }
                prev = cur;
                cur = iterator.next();
            }
            return true;
        };
        const isSame = (reqs) => {
            const iterator = reqs.entries();
            let cur = iterator.next();
            const firstRequest = cur.value[1];
            let dependencyId;
            if (firstRequest.dependsOn === undefined || firstRequest.dependsOn.length === 0) {
                dependencyId = firstRequest.id;
            }
            else {
                if (firstRequest.dependsOn.length === 1) {
                    const fDependencyId = firstRequest.dependsOn[0];
                    if (fDependencyId !== firstRequest.id && reqs.has(fDependencyId)) {
                        dependencyId = fDependencyId;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
            cur = iterator.next();
            while (!cur.done) {
                const curReq = cur.value[1];
                if ((curReq.dependsOn === undefined || curReq.dependsOn.length === 0) && dependencyId !== curReq.id) {
                    return false;
                }
                if (curReq.dependsOn !== undefined && curReq.dependsOn.length !== 0) {
                    if (curReq.dependsOn.length === 1 && (curReq.id === dependencyId || curReq.dependsOn[0] !== dependencyId)) {
                        return false;
                    }
                    if (curReq.dependsOn.length > 1) {
                        return false;
                    }
                }
                cur = iterator.next();
            }
            return true;
        };
        if (requests.size === 0) {
            const error = new Error("Empty requests map, Please provide at least one request.");
            error.name = "Empty Requests Error";
            throw error;
        }
        return isParallel(requests) || isSerial(requests) || isSame(requests);
    }
    /**
     * @private
     * @static
     * @async
     * Converts Request Object instance to a JSON
     * @param {IsomorphicRequest} request - The IsomorphicRequest Object instance
     * @returns A promise that resolves to JSON representation of a request
     */
    static getRequestData(request) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            const requestData = {
                url: "",
            };
            const hasHttpRegex = new RegExp("^https?://");
            // Stripping off hostname, port and url scheme
            requestData.url = hasHttpRegex.test(request.url) ? "/" + request.url.split(/.*?\/\/.*?\//)[1] : request.url;
            requestData.method = request.method;
            const headers = {};
            request.headers.forEach((value, key) => {
                headers[key] = value;
            });
            if (Object.keys(headers).length) {
                requestData.headers = headers;
            }
            if (request.method === _RequestMethod__WEBPACK_IMPORTED_MODULE_1__[/* RequestMethod */ "a"].PATCH || request.method === _RequestMethod__WEBPACK_IMPORTED_MODULE_1__[/* RequestMethod */ "a"].POST || request.method === _RequestMethod__WEBPACK_IMPORTED_MODULE_1__[/* RequestMethod */ "a"].PUT) {
                requestData.body = yield BatchRequestContent.getRequestBody(request);
            }
            /**
             * TODO: Check any other property needs to be used from the Request object and add them
             */
            return requestData;
        });
    }
    /**
     * @private
     * @static
     * @async
     * Gets the body of a Request object instance
     * @param {IsomorphicRequest} request - The IsomorphicRequest object instance
     * @returns The Promise that resolves to a body value of a Request
     */
    static getRequestBody(request) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            let bodyParsed = false;
            let body;
            try {
                const cloneReq = request.clone();
                body = yield cloneReq.json();
                bodyParsed = true;
            }
            catch (e) {
                // tslint:disable-line: no-empty
            }
            if (!bodyParsed) {
                try {
                    if (typeof Blob !== "undefined") {
                        const blob = yield request.blob();
                        const reader = new FileReader();
                        body = yield new Promise((resolve) => {
                            reader.addEventListener("load", () => {
                                const dataURL = reader.result;
                                /**
                                 * Some valid dataURL schemes:
                                 *  1. data:text/vnd-example+xyz;foo=bar;base64,R0lGODdh
                                 *  2. data:text/plain;charset=UTF-8;page=21,the%20data:1234,5678
                                 *  3. data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==
                                 *  4. data:image/png,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==
                                 *  5. data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==
                                 * @see Syntax {@link https://en.wikipedia.org/wiki/Data_URI_scheme} for more
                                 */
                                const regex = new RegExp("^s*data:(.+?/.+?(;.+?=.+?)*)?(;base64)?,(.*)s*$");
                                const segments = regex.exec(dataURL);
                                resolve(segments[4]);
                            }, false);
                            reader.readAsDataURL(blob);
                        });
                    }
                    else if (typeof Buffer !== "undefined") {
                        const buffer = yield request.buffer();
                        body = buffer.toString("base64");
                    }
                    bodyParsed = true;
                }
                catch (e) {
                    // tslint:disable-line: no-empty
                }
            }
            return body;
        });
    }
    /**
     * @public
     * Adds a request to the batch request content
     * @param {BatchRequestStep} request - The request value
     * @returns The id of the added request
     */
    addRequest(request) {
        const limit = BatchRequestContent.requestLimit;
        if (request.id === "") {
            const error = new Error(`Id for a request is empty, Please provide an unique id`);
            error.name = "Empty Id For Request";
            throw error;
        }
        if (this.requests.size === limit) {
            const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);
            error.name = "Limit Exceeded Error";
            throw error;
        }
        if (this.requests.has(request.id)) {
            const error = new Error(`Adding request with duplicate id ${request.id}, Make the id of the requests unique`);
            error.name = "Duplicate RequestId Error";
            throw error;
        }
        this.requests.set(request.id, request);
        return request.id;
    }
    /**
     * @public
     * Removes request from the batch payload and its dependencies from all dependents
     * @param {string} requestId - The id of a request that needs to be removed
     * @returns The boolean indicating removed status
     */
    removeRequest(requestId) {
        const deleteStatus = this.requests.delete(requestId);
        const iterator = this.requests.entries();
        let cur = iterator.next();
        /**
         * Removing dependencies where this request is present as a dependency
         */
        while (!cur.done) {
            const dependencies = cur.value[1].dependsOn;
            if (typeof dependencies !== "undefined") {
                const index = dependencies.indexOf(requestId);
                if (index !== -1) {
                    dependencies.splice(index, 1);
                }
                if (dependencies.length === 0) {
                    delete cur.value[1].dependsOn;
                }
            }
            cur = iterator.next();
        }
        return deleteStatus;
    }
    /**
     * @public
     * @async
     * Serialize content from BatchRequestContent instance
     * @returns The body content to make batch request
     */
    getContent() {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            const requests = [];
            const requestBody = {
                requests,
            };
            const iterator = this.requests.entries();
            let cur = iterator.next();
            if (cur.done) {
                const error = new Error("No requests added yet, Please add at least one request.");
                error.name = "Empty Payload";
                throw error;
            }
            if (!BatchRequestContent.validateDependencies(this.requests)) {
                const error = new Error(`Invalid dependency found, Dependency should be:
1. Parallel - no individual request states a dependency in the dependsOn property.
2. Serial - all individual requests depend on the previous individual request.
3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.`);
                error.name = "Invalid Dependency";
                throw error;
            }
            while (!cur.done) {
                const requestStep = cur.value[1];
                const batchRequestData = (yield BatchRequestContent.getRequestData(requestStep.request));
                /**
                 * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/json_batching#request-format}
                 */
                if (batchRequestData.body !== undefined && (batchRequestData.headers === undefined || batchRequestData.headers["content-type"] === undefined)) {
                    const error = new Error(`Content-type header is not mentioned for request #${requestStep.id}, For request having body, Content-type header should be mentioned`);
                    error.name = "Invalid Content-type header";
                    throw error;
                }
                batchRequestData.id = requestStep.id;
                if (requestStep.dependsOn !== undefined && requestStep.dependsOn.length > 0) {
                    batchRequestData.dependsOn = requestStep.dependsOn;
                }
                requests.push(batchRequestData);
                cur = iterator.next();
            }
            requestBody.requests = requests;
            return requestBody;
        });
    }
    /**
     * @public
     * Adds a dependency for a given dependent request
     * @param {string} dependentId - The id of the dependent request
     * @param {string} [dependencyId] - The id of the dependency request, if not specified the preceding request will be considered as a dependency
     * @returns Nothing
     */
    addDependency(dependentId, dependencyId) {
        if (!this.requests.has(dependentId)) {
            const error = new Error(`Dependent ${dependentId} does not exists, Please check the id`);
            error.name = "Invalid Dependent";
            throw error;
        }
        if (typeof dependencyId !== "undefined" && !this.requests.has(dependencyId)) {
            const error = new Error(`Dependency ${dependencyId} does not exists, Please check the id`);
            error.name = "Invalid Dependency";
            throw error;
        }
        if (typeof dependencyId !== "undefined") {
            const dependent = this.requests.get(dependentId);
            if (dependent.dependsOn === undefined) {
                dependent.dependsOn = [];
            }
            if (dependent.dependsOn.indexOf(dependencyId) !== -1) {
                const error = new Error(`Dependency ${dependencyId} is already added for the request ${dependentId}`);
                error.name = "Duplicate Dependency";
                throw error;
            }
            dependent.dependsOn.push(dependencyId);
        }
        else {
            const iterator = this.requests.entries();
            let prev;
            let cur = iterator.next();
            while (!cur.done && cur.value[1].id !== dependentId) {
                prev = cur;
                cur = iterator.next();
            }
            if (typeof prev !== "undefined") {
                const dId = prev.value[0];
                if (cur.value[1].dependsOn === undefined) {
                    cur.value[1].dependsOn = [];
                }
                if (cur.value[1].dependsOn.indexOf(dId) !== -1) {
                    const error = new Error(`Dependency ${dId} is already added for the request ${dependentId}`);
                    error.name = "Duplicate Dependency";
                    throw error;
                }
                cur.value[1].dependsOn.push(dId);
            }
            else {
                const error = new Error(`Can't add dependency ${dependencyId}, There is only a dependent request in the batch`);
                error.name = "Invalid Dependency Addition";
                throw error;
            }
        }
    }
    /**
     * @public
     * Removes a dependency for a given dependent request id
     * @param {string} dependentId - The id of the dependent request
     * @param {string} [dependencyId] - The id of the dependency request, if not specified will remove all the dependencies of that request
     * @returns The boolean indicating removed status
     */
    removeDependency(dependentId, dependencyId) {
        const request = this.requests.get(dependentId);
        if (typeof request === "undefined" || request.dependsOn === undefined || request.dependsOn.length === 0) {
            return false;
        }
        if (typeof dependencyId !== "undefined") {
            const index = request.dependsOn.indexOf(dependencyId);
            if (index === -1) {
                return false;
            }
            request.dependsOn.splice(index, 1);
            return true;
        }
        else {
            delete request.dependsOn;
            return true;
        }
    }
}
/**
 * @private
 * @static
 * Limit for number of requests {@link - https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}
 */
BatchRequestContent.requestLimit = 20;
//# sourceMappingURL=BatchRequestContent.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 200 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export MiddlewareFactory */
/* harmony import */ var _AuthenticationHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48);
/* harmony import */ var _HTTPMessageHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
/* harmony import */ var _options_RedirectHandlerOptions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28);
/* harmony import */ var _options_RetryHandlerOptions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31);
/* harmony import */ var _RedirectHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);
/* harmony import */ var _RetryHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(50);
/* harmony import */ var _TelemetryHandler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(52);
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */







/**
 * @private
 * To check whether the environment is node or not
 * @returns A boolean representing the environment is node or not
 */
const isNodeEnvironment = () => {
    return typeof process === "object" && "function" === "function";
};
/**
 * @class
 * Class containing function(s) related to the middleware pipelines.
 */
class MiddlewareFactory {
    /**
     * @public
     * @static
     * Returns the default middleware chain an array with the  middleware handlers
     * @param {AuthenticationProvider} authProvider - The authentication provider instance
     * @returns an array of the middleware handlers of the default middleware chain
     */
    static getDefaultMiddlewareChain(authProvider) {
        const middleware = [];
        const authenticationHandler = new _AuthenticationHandler__WEBPACK_IMPORTED_MODULE_0__[/* AuthenticationHandler */ "a"](authProvider);
        const retryHandler = new _RetryHandler__WEBPACK_IMPORTED_MODULE_5__[/* RetryHandler */ "a"](new _options_RetryHandlerOptions__WEBPACK_IMPORTED_MODULE_3__[/* RetryHandlerOptions */ "a"]());
        const telemetryHandler = new _TelemetryHandler__WEBPACK_IMPORTED_MODULE_6__[/* TelemetryHandler */ "a"]();
        const httpMessageHandler = new _HTTPMessageHandler__WEBPACK_IMPORTED_MODULE_1__[/* HTTPMessageHandler */ "a"]();
        middleware.push(authenticationHandler);
        middleware.push(retryHandler);
        if (isNodeEnvironment()) {
            const redirectHandler = new _RedirectHandler__WEBPACK_IMPORTED_MODULE_4__[/* RedirectHandler */ "a"](new _options_RedirectHandlerOptions__WEBPACK_IMPORTED_MODULE_2__[/* RedirectHandlerOptions */ "a"]());
            middleware.push(redirectHandler);
        }
        middleware.push(telemetryHandler);
        middleware.push(httpMessageHandler);
        return middleware;
    }
}
//# sourceMappingURL=MiddlewareFactory.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/* unused harmony export OneDriveLargeFileUploadTask */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _LargeFileUploadTask__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80);
/* harmony import */ var _OneDriveLargeFileUploadTaskUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(207);
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */



/**
 * @class
 * Class representing OneDriveLargeFileUploadTask
 */
class OneDriveLargeFileUploadTask extends _LargeFileUploadTask__WEBPACK_IMPORTED_MODULE_1__[/* LargeFileUploadTask */ "a"] {
    /**
     * @public
     * @constructor
     * Constructs a OneDriveLargeFileUploadTask
     * @param {Client} client - The GraphClient instance
     * @param {FileObject} file - The FileObject holding details of a file that needs to be uploaded
     * @param {LargeFileUploadSession} uploadSession - The upload session to which the upload has to be done
     * @param {LargeFileUploadTaskOptions} options - The upload task options
     * @returns An instance of OneDriveLargeFileUploadTask
     */
    constructor(client, file, uploadSession, options) {
        super(client, file, uploadSession, options);
    }
    /**
     * @private
     * @static
     * Constructs the create session url for Onedrive
     * @param {string} fileName - The name of the file
     * @param {path} [path = OneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH] - The path for the upload
     * @returns The constructed create session url
     */
    static constructCreateSessionUrl(fileName, path = OneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH) {
        fileName = fileName.trim();
        path = path.trim();
        if (path === "") {
            path = "/";
        }
        if (path[0] !== "/") {
            path = `/${path}`;
        }
        if (path[path.length - 1] !== "/") {
            path = `${path}/`;
        }
        // we choose to encode each component of the file path separately because when encoding full URI
        // with encodeURI, special characters like # or % in the file name doesn't get encoded as desired
        return `/me/drive/root:${path
            .split("/")
            .map((p) => encodeURIComponent(p))
            .join("/")}${encodeURIComponent(fileName)}:/createUploadSession`;
    }
    /**
     * @public
     * @static
     * @async
     * Creates a OneDriveLargeFileUploadTask
     * @param {Client} client - The GraphClient instance
     * @param {Blob | Buffer | File} file - File represented as Blob, Buffer or File
     * @param {OneDriveLargeFileUploadOptions} options - The options for upload task
     * @returns The promise that will be resolves to OneDriveLargeFileUploadTask instance
     */
    static create(client, file, options) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            const name = options.fileName;
            let content;
            let size;
            if (typeof Blob !== "undefined" && file instanceof Blob) {
                content = new File([file], name);
                size = content.size;
            }
            else if (typeof File !== "undefined" && file instanceof File) {
                content = file;
                size = content.size;
            }
            else if (typeof Buffer !== "undefined" && file instanceof Buffer) {
                const b = file;
                size = b.byteLength - b.byteOffset;
                content = b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);
            }
            try {
                const requestUrl = OneDriveLargeFileUploadTask.constructCreateSessionUrl(options.fileName, options.path);
                const session = yield OneDriveLargeFileUploadTask.createUploadSession(client, requestUrl, options.fileName);
                const rangeSize = Object(_OneDriveLargeFileUploadTaskUtil__WEBPACK_IMPORTED_MODULE_2__[/* getValidRangeSize */ "a"])(options.rangeSize);
                const fileObj = {
                    name,
                    content,
                    size,
                };
                return new OneDriveLargeFileUploadTask(client, fileObj, session, {
                    rangeSize,
                });
            }
            catch (err) {
                throw err;
            }
        });
    }
    /**
     * @public
     * @static
     * @async
     * Makes request to the server to create an upload session
     * @param {Client} client - The GraphClient instance
     * @param {string} requestUrl - The URL to create the upload session
     * @param {string} fileName - The name of a file to upload, (with extension)
     * @returns The promise that resolves to LargeFileUploadSession
     */
    static createUploadSession(client, requestUrl, fileName) {
        const _super = Object.create(null, {
            createUploadSession: { get: () => super.createUploadSession }
        });
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            const payload = {
                item: {
                    "@microsoft.graph.conflictBehavior": "rename",
                    name: fileName,
                },
            };
            try {
                return _super.createUploadSession.call(this, client, requestUrl, payload);
            }
            catch (err) {
                throw err;
            }
        });
    }
    /**
     * @public
     * Commits upload session to end uploading
     * @param {string} requestUrl - The URL to commit the upload session
     * @returns The promise resolves to committed response
     */
    commit(requestUrl) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "a"](this, void 0, void 0, function* () {
            try {
                const payload = {
                    name: this.file.name,
                    "@microsoft.graph.conflictBehavior": "rename",
                    "@microsoft.graph.sourceUrl": this.uploadSession.url,
                };
                return yield this.client.api(requestUrl).put(payload);
            }
            catch (err) {
                throw err;
            }
        });
    }
}
/**
 * @private
 * @static
 * Default path for the file being uploaded
 */
OneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH = "/";
//# sourceMappingURL=OneDriveLargeFileUploadTask.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 202 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/lib/index.ts + 2 modules
var lib = __webpack_require__(7);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/app.ts















const URN_APP = 'urn:io.iopa:app'

const AppRef = Object(lib["a" /* createIopaRef */])({
    id: URN_APP,
    description:
        'Iopa App Capability common to every Iopa App, includes host name and version',
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/bot-dialog.ts












const URN_BOT_DIALOG = 'urn:io.iopa.bot:dialog'

const BotDialogRef = Object(lib["a" /* createIopaRef */])({
  id: URN_BOT_DIALOG,
  description: 'Iopa Bot Dialog registry and helper to start a dialog'
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/bot-skills.ts




const URN_BOT_SKILLS = 'urn:io.iopa.bot:skills'















const BotSkillsRef = Object(lib["a" /* createIopaRef */])({
  id: URN_BOT_SKILLS,
  description: 'Iopa Bot Skills registry'
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/bot-surface.ts


const URN_BOT_SURFACE = 'urn:io-iopa:bot:surface'






























const BotSurfaceRef = Object(lib["a" /* createIopaRef */])({
  id: URN_BOT_SURFACE,
  description:
    'Iopa Bot Surface API to show modals, restart the surface, download updates and restart etc.'
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/consumer-profile.ts


const URN_CONSUMER_PROFILE = 'urn:consumer:profile'























































const ConsumerProfileRef = Object(lib["a" /* createIopaRef */])({
  id: URN_CONSUMER_PROFILE,
  description:
    'User profile store including name, tenant, UTM codes, authentication status and methods'
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/devtools-bridge.ts


const URN_DEVTOOLS_BRIDGE = 'urn:ai:karla:devtools:bridge'






const DevToolsBridgeRef = Object(lib["a" /* createIopaRef */])({
  id: URN_DEVTOOLS_BRIDGE,
  description:
    'Development tools bridge to invoke functions across worker sandbox walls'
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/devtools-renderer.ts


const URN_DEVTOOLS_RENDERER = 'urn:ai:karla:devtools:renderer'





const DevToolsRendererRef = Object(lib["a" /* createIopaRef */])({
  id: URN_DEVTOOLS_RENDERER,
  description:
    'Development tools renderer utility to invoke functions across renderer sandbox walls'
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/edge-simple-storage.ts


const URN_EDGE_SIMPLE_STORAGE_DEV =
  'urn:io.iopa.simplestorage:edge:development'
const URN_EDGE_SIMPLE_STORAGE_STAGING =
  'urn:io.iopa.simplestorage:edge:staging'
const URN_EDGE_SIMPLE_STORAGE_PROD =
  'urn:io.iopa.simplestorage:edge:production'













const EdgeSimpleStorageDevRef = Object(lib["a" /* createIopaRef */])({
  id: URN_EDGE_SIMPLE_STORAGE_DEV,
  description:
    'Simple cloud storage API to get signed URL for given file bucket [development]'
})

const EdgeSimpleStorageStagingRef = Object(lib["a" /* createIopaRef */])({
  id: URN_EDGE_SIMPLE_STORAGE_STAGING,
  description:
    'Simple cloud storage API to get signed URL for given file bucket [staging]'
})

const EdgeSimpleStorageProdRef = Object(lib["a" /* createIopaRef */])({
  id: URN_EDGE_SIMPLE_STORAGE_PROD,
  description:
    'Simple cloud storage API to get signed URL for given file bucket [production]'
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/filehost.ts


const URN_FILEHOST = 'urn:io.iopa:filehost'







const FileHostRef = Object(lib["a" /* createIopaRef */])({
  id: URN_FILEHOST,
  description: 'Capability to get a file from cloud storage or post a response'
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/filestorage.ts


const URN_FILE_STORAGE = 'urn:io.iopa.filestorage'






const FileStorageRef = Object(lib["a" /* createIopaRef */])({
  id: URN_FILE_STORAGE,
  description: 'Capability to save a file in local storage or delete a file'
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/message-store.ts




const URN_MESSAGE_STORE = 'urn:io.iopa.bot:messages'
const URN_MESSAGE_STORE_SIMPLE = 'urn:io.iopa.bot:messages:simple'








































const MessageStoreRef = Object(lib["a" /* createIopaRef */])({
  id: URN_MESSAGE_STORE,
  description: 'Main message store used by the IOPA Bot Runtime'
})

const MessageStoreSimpleRef = Object(lib["a" /* createIopaRef */])({
  id: URN_MESSAGE_STORE_SIMPLE,
  description:
    'Limited API footprint message store used by the IOPA Bot Simulator'
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/reactive-dialogs.ts




const URN_REACTIVE_DIALOGS_SIMPLE =
  'urn:io.iopa.bot:reactive-dialogs:simple'
const URN_REACTIVE_DIALOGS = 'urn:io.iopa.bot:reactive-dialogs'



























































const ReactiveDialogsSimpleRef = Object(lib["a" /* createIopaRef */])

({
  id: URN_REACTIVE_DIALOGS_SIMPLE,
  description: 'Limited footprint API (readonly)to render dialogs at runtime '
})

const ReactiveDialogsRef = Object(lib["a" /* createIopaRef */])({
  id: URN_REACTIVE_DIALOGS,
  description:
    'Capability to register dialogs using JSX and render dialogs at runtime'
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/session.ts



const URN_SESSION = 'urn:io.iopa.bot:session'
















const SessionRef = Object(lib["a" /* createIopaRef */])({
  id: URN_SESSION,
  description: 'Iopa Bot session manager including asynchronous CRUD methods '
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/session-database.ts


const URN_SESSION_DATABASE = 'urn:io.iopa.database:session'











const SessionDatabaseRef = Object(lib["a" /* createIopaRef */])({
  id: URN_SESSION_DATABASE,
  description:
    'Iopa Bot session database including asynchronous CRUD persistant storage methods '
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/simple-database.ts


const URN_SIMPLE_DATABASE = 'urn:io.iopa.database'











const SimpleDatabaseRef = Object(lib["a" /* createIopaRef */])({
  id: URN_SIMPLE_DATABASE,
  description:
    'Iopa Bot simple database including asynchronous CRUD persistant storage methods '
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/speech.ts


const URN_SPEECH = 'urn:io.iopa.bot:speech'






const SpeechRef = Object(lib["a" /* createIopaRef */])({
  id: URN_SPEECH,
  description: 'Text to speech capability'
})

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-types/src/capabilities/index.ts
/* unused concated harmony import AppRef */
/* unused concated harmony import BotDialogRef */
/* unused concated harmony import BotSkillsRef */
/* unused concated harmony import BotSurfaceRef */
/* unused concated harmony import ConsumerProfileRef */
/* unused concated harmony import DevToolsBridgeRef */
/* unused concated harmony import DevToolsRendererRef */
/* unused concated harmony import EdgeSimpleStorageDevRef */
/* unused concated harmony import EdgeSimpleStorageStagingRef */
/* unused concated harmony import EdgeSimpleStorageProdRef */
/* unused concated harmony import FileHostRef */
/* unused concated harmony import FileStorageRef */
/* unused concated harmony import MessageStoreRef */
/* unused concated harmony import MessageStoreSimpleRef */
/* unused concated harmony import ReactiveDialogsRef */
/* unused concated harmony import ReactiveDialogsSimpleRef */
/* unused concated harmony import SessionRef */
/* unused concated harmony import SessionDatabaseRef */
/* unused concated harmony import SimpleDatabaseRef */
/* unused concated harmony import SpeechRef */


























































// OTHER IMPORTS







































//
// CAPABILITY BASE PROPERTY COLLECTIONS
//































/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createEdgeApp; });
/* harmony import */ var url_search_params_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(211);
/* harmony import */ var url_search_params_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(url_search_params_polyfill__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var iopa__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/* harmony import */ var _iopa_edge_store_kv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(210);
/* harmony import */ var _iopa_edge_contrib_stackdriver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(209);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(205);







// fix missing URLSearchParams











url__WEBPACK_IMPORTED_MODULE_1__["URLSearchParams"] = URLSearchParams

const { version } = __webpack_require__(228)

global.navigator = global.navigator || {}
global.window = global.window || global

function createEdgeApp() {
    const cloudflareIopa = new CloudflareIopa()

    addEventListener('fetch', (_event) => {
        const event = _event 

        if (
             false ||
            false === 'true'
        ) {
            event.respondWith(cloudflareIopa.handleRequestEdge(event))
        } else if (true) {
            cloudflareIopa.handleRequestLocal(event)
        }
    })

    return cloudflareIopa.app
}

class CloudflareIopa {
    

    constructor() {
        const app = (new iopa__WEBPACK_IMPORTED_MODULE_2__[/* App */ "a"]({
            'server.Version': version,
        }) ) 

        app.logging = {
            flush: () => {
                /** noop */
            },
            log: (context, ...args) => {
                console.log(...args)
            },
            warn: (context, ...args) => {
                console.log(...args)
            },
            error: (context, ex, ...optionalArgs) => {
                console.error(ex, ...optionalArgs)
            },
        }

        app.use(_iopa_edge_contrib_stackdriver__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], 'StackDriverCapability')

        app.db = getKV()

        this.app = app
    }

    /** Cloud edge request handler or 'localhost' */
     async handleRequestEdge(event) {
        try {
            const { request } = event
            const [context, response] = Object(_context__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(request)
            context.log = context.log || console.log
            context.error = context.error || console.error
            console.log(`CF> ${request.method} ${request.url}`)

            const workerpromise = this.app.invoke(context)

            const timeoutPromise = delay(10000)

            const value = await Promise.race([timeoutPromise, response])

            if (!value) {
                context.log(
                    `CF- Timed out but still wating on responses ${context.get(
                        'server.TimeElapsed'
                    )}ms`
                )
                event.waitUntil(
                    this.cleanup(
                        context,
                        Promise.race([
                            Promise.all([workerpromise, response]),
                            delay(49000),
                        ])
                    )
                )
                return new Response('Timeout')
            }
            context.log(
                `CF- Response sent, checking for completion of work ${context.get(
                    'server.TimeElapsed'
                )}ms`
            )
            event.waitUntil(
                this.cleanup(
                    context,
                    Promise.race([workerpromise, delay(49000)])
                )
            )
            console.log('STATUS: ', value.status)
            return value
        } catch (ex) {
            console.error(ex)
            await this.app.logging.flush()
            return new Response('Error', {
                status: 500,
                statusText: ex.message,
            })
        }
    }

     async cleanup(context, childpromise) {
        await childpromise
        await context.log(
            `CF= Activity Completed or Timed-out ${context.get(
                'server.TimeElapsed'
            )}ms`
        )
        await this.app.logging.flush()
    }

    /** Development Request handler (not localhost): pass over wire to localhost */
     async handleRequestLocal(event) {
        const { request } = event

        if (
            request.headers.get('Forwarded') === 'by=SLIPWAY' ||
            request.headers.get('Forwarded') === 'by=IOPA'
        ) {
            event.respondWith(
                new Response('ALREADY FORWARDED BY IOPA', { status: 500 })
            )
            return
        }

        const url = new URL(request.url)
        url.hostname = new URL("https://39c33526ea38.ngrok.io").hostname

        const headers = {}
        Array.from(request.headers.entries()).forEach((kv) => {
            headers[kv[0]] = kv[1]
        })
        // eslint-disable-next-line dot-notation
        headers['Forwarded'] = 'by=IOPA'

        const doFetch = async (data) => {
            const reqOpts = {
                headers,
                method: request.method,
            }
            if (data) {
                reqOpts.body = data
            }
            const result = await self.fetch(url.href, reqOpts)
            return result
        }

        if (['GET', 'HEAD'].includes(request.method)) {
            event.respondWith(doFetch())
        } else {
            event.respondWith(event.request.arrayBuffer().then(doFetch))
        }
    }
}

function delay(/** timeout in ms */ timeout) {
    return new Promise((resolve) => {
        setTimeout(resolve, timeout)
    })
}

/** Cloudflare global namespace for KV datastore */

function getKV() {
    try {
        return new _iopa_edge_store_kv__WEBPACK_IMPORTED_MODULE_3__[/* KVStore */ "a"]({
            get: async (path) => {
                const result = await IOPA_EDGE_DB.get(path, 'json')
                return result
            },
            put: async (path, body) => {
                await IOPA_EDGE_DB.put(path, JSON.stringify(body))
            },
            delete: async (path) => {
                await IOPA_EDGE_DB.delete(path)
            },
        })
    } catch (ex) {
        console.error(ex)
        return null
    }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16)))

/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(128);
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/* harmony import */ var _jwk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _jws__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40);
/* harmony import */ var _jwt__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(134);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _jwt__WEBPACK_IMPORTED_MODULE_4__["a"]; });

/* harmony import */ var _converters__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(18);










/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export IopaWebRequest */
/* unused harmony export IopaWebResponse */
/* unused harmony export IopaWebContext */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return toIopa; });
/* harmony import */ var iopa__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);





























const $$url = Symbol('url')
const $$labels = Symbol('labels')
const $$request = Symbol('request')
const $$status = Symbol('status')
const $$statustext = Symbol('statustext')
const $$headers = Symbol('headers')
const $$body = Symbol('body')
const $$size = Symbol('size')
const $$events = Symbol('events')




class IopaWebRequest
    extends iopa__WEBPACK_IMPORTED_MODULE_0__[/* ContextBase */ "b"]
 {
    

    

    

    

     set 'iopa.RawRequest'(request) {
        this[$$request] = request
        this[$$url] = new URL(request.url)

        const { cf } = this[$$request]
        this['server.Source'] = (cf && cf.colo) || 'unknown'
    }

     get 'iopa.RawRequest'() {
        return this[$$request]
    }

     get 'iopa.Headers'() {
        return new iopa__WEBPACK_IMPORTED_MODULE_0__[/* IopaHeaders */ "d"](Array.from(this[$$request].headers.entries()))
    }

     get 'iopa.Method'() {
        return this[$$request].method
    }

     get 'iopa.Labels'() {
        if (!this[$$labels]) {
            this[$$labels] = new Map()
        }
        return this[$$labels]
    }

     get 'iopa.OriginalUrl'() {
        return this[$$request].url
    }

     get 'iopa.Url'() {
        return this[$$url]
    }

     get 'iopa.Path'() {
        return this[$$url].pathname
    }

     get 'iopa.Protocol'() {
        return 'HTTP/2.0'
    }

     get 'iopa.QueryString'() {
        return this[$$url].search.replace(/^\?/, '')
    }

     get 'iopa.Scheme'() {
        return this[$$url].protocol
    }

     get 'iopa.Body'() {
        if (this[$$body]) {
            return this[$$body]
        }

        // eslint-disable-next-line no-async-promise-executor, consistent-return
        this[$$body] = new Promise(async (resolve, reject) => {
            let body

            const contentTypeCharSet =
                this[$$request].headers.get('content-type') || ''
            const contentType = contentTypeCharSet.split(';')[0]

            if (this[$$request].method === 'GET') {
                return resolve({})
            }

            if (contentType === 'application/x-www-form-urlencoded') {
                const text = await this[$$request].text()
                // eslint-disable-next-line dot-notation
                body = Object.fromEntries(new URLSearchParams(text).entries())
            } else if (contentType === 'application/json') {
                try {
                    body = await this[$$request].json()
                } catch (ex) {
                    console.error(ex)
                    body = {}
                }
            } else {
                body = await this[$$request].text()
            }

            resolve(body)
        })

        return this[$$body]
    }

     get 'iopa.RemoteAddress'() {
        return (
            this[$$request].headers.get('x-forwarded-for') ||
            this[$$request].headers.get('CF-Connecting-IP')
        )
    }

     toJSON() {
        const jsonObj = super.toJSON()

        // eslint-disable-next-line dot-notation
        jsonObj['body'] = this[$$body]

        jsonObj['bot.Capability'] = jsonObj['bot.Capability']
            ? { activity: jsonObj['bot.Capability'].activity }
            : undefined

        return jsonObj
    }
}

class IopaWebResponse
    extends iopa__WEBPACK_IMPORTED_MODULE_0__[/* ResponseBase */ "e"]
 {
    

    

    

    

    

    

    constructor() {
        super()
        this[$$status] = 200
        this[$$statustext] = 'OK'
        this[$$body] = null
        this[$$size] = 0
        this[$$headers] = new iopa__WEBPACK_IMPORTED_MODULE_0__[/* IopaHeaders */ "d"]({
            'Content-Type': 'application/json',
        })
    }

     set 'iopa.Body'(value) {
        this[$$body] = value
    }

     get 'iopa.Headers'() {
        return this[$$headers]
    }

     set 'iopa.Headers'(value) {
        this[$$headers] = value
    }

     get 'iopa.Size'() {
        return this[$$size]
    }

     get 'iopa.StatusCode'() {
        return this[$$status]
    }

     set 'iopa.StatusCode'(value) {
        this[$$status] = value
    }

     get 'iopa.StatusText'() {
        return this[$$statustext]
    }

     set 'iopa.StatusText'(value) {
        this[$$statustext] = value
    }

     get 'iopa.Protocol'() {
        return 'HTTP/2.0'
    }

     _send(
        chunk,
        options
    ) {
        return this.end(chunk, options)
    }

    send(chunk, options) {
        /** Note:  Prototype ay be overriden, e.g., in iopa botadapter, so always use _send private method for base */
        return this._send(chunk, options)
    }

    async _end(chunk, options) {
        if (
            chunk &&
            typeof chunk === 'object' &&
            !options &&
            ('status' in chunk || 'headers' in chunk)
        ) {
            options = (chunk ) 
            chunk = null
        }

        if (chunk && (chunk ).length) {
            this[$$size] += (chunk ).length
        }

        if (options) {
            if (options.headers) {
                this['iopa.Headers'] = new iopa__WEBPACK_IMPORTED_MODULE_0__[/* IopaHeaders */ "d"](
                    options.headers,
                    this['iopa.Headers']
                )
            }
            if (options.status) {
                this['iopa.StatusCode'] = options.status
            }
            if (options.statusText) {
                this['iopa.StatusText'] = options.statusText
            }
        }

        let body

        if (this[$$body] == null) {
            body = chunk
        } else if (chunk == null) {
            body = this[$$body]
        } else if (typeof this[$$body] === 'string') {
            body = this[$$body] + (chunk )
        } else if (ArrayBuffer.isView(this[$$body])) {
            body = appendBuffer(
                this[$$body] ,
                chunk 
            )
        } else {
            body = this[$$body]
            ;((body ) ).getWriter().write(chunk)
        }

        this[$$body] = body

        const response = new Response(this[$$body], {
            headers: Array.from(this[$$headers].entries()),
            status: this[$$status],
            statusText: this[$$statustext],
        })

        this[$$events].emit('end', response)
    }

    end(chunk, options) {
        return this._end(chunk, options)
    }

    webrespond(response) {
        this[$$events].emit('end', response)
    }

    toJSON() {
        const jsonObj = super.toJSON()

        delete jsonObj['bot.Capability']

        return jsonObj
    }
}

class IopaWebContext
    extends IopaWebRequest
     {
    static __initStatic() {this.contextFactory = new iopa__WEBPACK_IMPORTED_MODULE_0__[/* Factory */ "c"](
        'IopaWebContext',
        null,
        () => new IopaWebContext()
    )}

    static __initStatic2() {this.responseFactory = new iopa__WEBPACK_IMPORTED_MODULE_0__[/* Factory */ "c"](
        'IopaWebResponse',
        null,
        () => new IopaWebResponse() 
    )}

    

    init() {
        super.init()

        this.response = IopaWebContext.responseFactory.createContext()

        this.response[$$events] = this['iopa.Events']

        this.response.set(
            'server.Capabilities',
            this.get('server.Capabilities')
        )

        return this
    }
} IopaWebContext.__initStatic(); IopaWebContext.__initStatic2();

function toIopa(
    request
) {
    const context = IopaWebContext.contextFactory.createContext()
    context['iopa.RawRequest'] = request

    const webresponse = new Promise((resolve, reject) => {
        context['iopa.Events'].once('end', (response) => resolve(response))
    })

    return [(context ) , webresponse]
}

function appendBuffer(buffer1, buffer2) {
    const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength)
    tmp.set(new Uint8Array(buffer1), 0)
    tmp.set(new Uint8Array(buffer2), buffer1.byteLength)
    return tmp.buffer
}

Object.fromEntries =
    Object.fromEntries ||
    function fromEntries(iterable) {
        return [...iterable].reduce((obj, [key, val]) => {
            obj[key] = val
            return obj
        }, {})
    }


/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TokenHelpers; });
/* harmony import */ var iopa_botadapter_schema_tokens__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(115);
/* harmony import */ var iopa_botadapter_schema_tokens__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(iopa_botadapter_schema_tokens__WEBPACK_IMPORTED_MODULE_0__);









const OAUTH_ENDPOINT = 'https://api.botframework.com'

class TokenHelpers  {
    

    constructor(context) {
        this._context = context
    }

    /** An asynchronous method that attempts to retrieve the token for a user that's in a login flow.  */
     async getUserToken(
        connectionName,
        magicCode
    ) {
        const { activity } = this._context['bot.Capability']

        if (!activity.from || !activity.from.id) {
            throw new Error(
                `TokenHelpers.getUserToken(): missing from or from.id`
            )
        }
        if (!connectionName) {
            throw new Error(
                'getUserToken() requires a connectionName but none was provided.'
            )
        }
        const userId = activity.from.id
        const url = this.oauthApiUrl(this._context)
        const client = this.createUserTokenApiClient(url)

        return client.userTokenGetToken(
            userId,
            connectionName,
            activity.channelId,
            magicCode
        )
    }

    /** An asynchronous method that signs out the user from the token server.  */
     async signOutUser(
        connectionName,
        userId
    ) {
        const { activity } = this._context['bot.Capability']

        if (!activity.from || !activity.from.id) {
            throw new Error(
                `TokenHelpers.signOutUser(): missing from or from.id`
            )
        }
        if (!userId) {
            userId = activity.from.id
        }

        const url = this.oauthApiUrl(this._context)
        const client = this.createUserTokenApiClient(url)
        await client.userTokenSignOut(
            userId,
            connectionName,
            activity.channelId
        )
    }

    /** An asynchronous method that gets a sign-in link from the token server that can be sent as part */
     async getSignInLink(connectionName) {
        const { adapter, activity } = this._context['bot.Capability']

        const conversation = adapter.getConversationReference(
            activity
        )
        const url = this.oauthApiUrl(this._context)
        const client = this.createBotSignInApiClient(url)
        const state = {
            ConnectionName: connectionName,
            Conversation: conversation,
            MsAppId: adapter.credentials.appId,
        }

        const finalState = Buffer.from(JSON.stringify(state)).toString(
            'base64'
        )
        return JSON.parse(await client.botSignInGetSignInUrl(finalState))
    }

    /** An asynchronous method that retrieves the token status for each configured connection for the given user.  */
     async getTokenStatus(
        userId,
        includeFilter
    ) {
        const { activity } = this._context['bot.Capability']

        if (!userId && (!activity.from || !activity.from.id)) {
            throw new Error(
                `TokenHelpers.getTokenStatus(): missing from or from.id`
            )
        }
        userId = userId || activity.from.id
        const url = this.oauthApiUrl(this._context)
        const client = this.createUserTokenApiClient(url)

        return client.userTokenGetTokenStatus(
            userId,
            activity.channelId,
            includeFilter
        )
    }

    /** An asynchronous method that signs out the user from the token server. */
     async getAadTokens(
        connectionName,
        resourceUrls
    )

 {
        const { activity } = this._context['bot.Capability']

        if (!activity.from || !activity.from.id) {
            throw new Error(
                `TokenHelpers.getAadTokens(): missing from or from.id`
            )
        }
        const userId = activity.from.id
        const url = this.oauthApiUrl(this._context)
        const client = this.createUserTokenApiClient(url)

        return client.userTokenGetAadTokens(
            userId,
            connectionName,
            { resourceUrls },
            activity.channelId
        )
    }

    /** Creates an OAuth API client. */
     createUserTokenApiClient(serviceUrl) {
        const fetchProxy = async (url, init) => {
            await this._context[
                'bot.Capability'
            ].adapter.credentials.signRequest(url, init)
            return fetch(url, init)
        }

        const client = new iopa_botadapter_schema_tokens__WEBPACK_IMPORTED_MODULE_0__["UserTokenApi"](
            {},
            serviceUrl.replace(/\/+$/, ''),
            fetchProxy
        )

        return client
    }

    /** Creates an OAuth API client. */
     createBotSignInApiClient(serviceUrl) {
        const fetchProxy = async (url, init) => {
            await this._context[
                'bot.Capability'
            ].adapter.credentials.signRequest(url, init)
            return fetch(url, init)
        }

        const client = new iopa_botadapter_schema_tokens__WEBPACK_IMPORTED_MODULE_0__["BotSignInApi"](
            {},
            serviceUrl.replace(/\/+$/, ''),
            fetchProxy
        )

        return client
    }

    /** Gets the OAuth API endpoint. */
     oauthApiUrl(
        contextOrServiceUrl
    ) {
        return OAUTH_ENDPOINT
    }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getValidRangeSize; });
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @module OneDriveLargeFileUploadTaskUtil
 */
/**
 * @constant
 * Default value for the rangeSize
 * Recommended size is between 5 - 10 MB {@link https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/driveitem_createuploadsession#best-practices}
 */
const DEFAULT_FILE_SIZE = 5 * 1024 * 1024;
/**
 * @constant
 * Rounds off the given value to a multiple of 320 KB
 * @param {number} value - The value
 * @returns The rounded off value
 */
const roundTo320KB = (value) => {
    if (value > 320 * 1024) {
        value = Math.floor(value / (320 * 1024)) * 320 * 1024;
    }
    return value;
};
/**
 * @constant
 * Get the valid rangeSize for a file slicing (validity is based on the constrains mentioned in here
 * {@link https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/driveitem_createuploadsession#upload-bytes-to-the-upload-session})
 *
 * @param {number} [rangeSize = DEFAULT_FILE_SIZE] - The rangeSize value.
 * @returns The valid rangeSize
 */
const getValidRangeSize = (rangeSize = DEFAULT_FILE_SIZE) => {
    const sixtyMB = 60 * 1024 * 1024;
    if (rangeSize > sixtyMB) {
        rangeSize = sixtyMB;
    }
    return roundTo320KB(rangeSize);
};
//# sourceMappingURL=OneDriveLargeFileUploadTaskUtil.js.map

/***/ }),
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HTTPClientFactory; });
/* harmony import */ var _HTTPClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83);
/* harmony import */ var _middleware_AuthenticationHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);
/* harmony import */ var _middleware_HTTPMessageHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49);
/* harmony import */ var _middleware_options_RedirectHandlerOptions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28);
/* harmony import */ var _middleware_options_RetryHandlerOptions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31);
/* harmony import */ var _middleware_RedirectHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(51);
/* harmony import */ var _middleware_RetryHandler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(50);
/* harmony import */ var _middleware_TelemetryHandler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(52);
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @module HTTPClientFactory
 */








/**
 * @private
 * To check whether the environment is node or not
 * @returns A boolean representing the environment is node or not
 */
const isNodeEnvironment = () => {
    return typeof process === "object" && "function" === "function";
};
/**
 * @class
 * Class representing HTTPClientFactory
 */
class HTTPClientFactory {
    /**
     * @public
     * @static
     * Creates HTTPClient with default middleware chain
     * @param {AuthenticationProvider} authProvider - The authentication provider instance
     * @returns A HTTPClient instance
     *
     * NOTE: These are the things that we need to remember while doing modifications in the below default pipeline.
     * 		* HTTPMessageHander should be the last one in the middleware pipeline, because this makes the actual network call of the request
     * 		* TelemetryHandler should be the one prior to the last middleware in the chain, because this is the one which actually collects and appends the usage flag and placing this handler 	*		  before making the actual network call ensures that the usage of all features are recorded in the flag.
     * 		* The best place for AuthenticationHandler is in the starting of the pipeline, because every other handler might have to work for multiple times for a request but the auth token for
     * 		  them will remain same. For example, Retry and Redirect handlers might be working multiple times for a request based on the response but their auth token would remain same.
     */
    static createWithAuthenticationProvider(authProvider) {
        const authenticationHandler = new _middleware_AuthenticationHandler__WEBPACK_IMPORTED_MODULE_1__[/* AuthenticationHandler */ "a"](authProvider);
        const retryHandler = new _middleware_RetryHandler__WEBPACK_IMPORTED_MODULE_6__[/* RetryHandler */ "a"](new _middleware_options_RetryHandlerOptions__WEBPACK_IMPORTED_MODULE_4__[/* RetryHandlerOptions */ "a"]());
        const telemetryHandler = new _middleware_TelemetryHandler__WEBPACK_IMPORTED_MODULE_7__[/* TelemetryHandler */ "a"]();
        const httpMessageHandler = new _middleware_HTTPMessageHandler__WEBPACK_IMPORTED_MODULE_2__[/* HTTPMessageHandler */ "a"]();
        authenticationHandler.setNext(retryHandler);
        if (isNodeEnvironment()) {
            const redirectHandler = new _middleware_RedirectHandler__WEBPACK_IMPORTED_MODULE_5__[/* RedirectHandler */ "a"](new _middleware_options_RedirectHandlerOptions__WEBPACK_IMPORTED_MODULE_3__[/* RedirectHandlerOptions */ "a"]());
            retryHandler.setNext(redirectHandler);
            redirectHandler.setNext(telemetryHandler);
        }
        else {
            retryHandler.setNext(telemetryHandler);
        }
        telemetryHandler.setNext(httpMessageHandler);
        return HTTPClientFactory.createWithMiddleware(authenticationHandler);
    }
    /**
     * @public
     * @static
     * Creates a middleware chain with the given one
     * @property {...Middleware} middleware - The first middleware of the middleware chain or a sequence of all the Middleware handlers
     * @returns A HTTPClient instance
     */
    static createWithMiddleware(...middleware) {
        // Middleware should not empty or undefined. This is check is present in the HTTPClient constructor.
        return new _HTTPClient__WEBPACK_IMPORTED_MODULE_0__[/* HTTPClient */ "a"](...middleware);
    }
}
//# sourceMappingURL=HTTPClientFactory.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-edge-contrib/packages/iopa-edge-stackdriver-schema/dist/index.js
var dist = __webpack_require__(29);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-jsonwebtoken/src/index.ts
var src = __webpack_require__(204);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge-contrib/packages/iopa-edge-stackdriver-auth/src/token-service.ts
/* eslint-disable @typescript-eslint/camelcase */
// eslint-disable-next-line import/no-named-default




class token_service_TokenService {
   static __initStatic() {this.cache





 = new Map()}

  static async getToken(scopes) {
    const scope = scopes.join(' ')

    const token = this.cache.get(scope)

    if (token && token.expires_at > Date.now()) {
      return token.access_token
    }

    const _jwt = await src["default"].signAsync(
      {
        iss: "sync-24-7-cloudflare@sync-24-7.iam.gserviceaccount.com",
        scope,
        aud: 'https://www.googleapis.com/oauth2/v4/token'
      },
      "-----BEGIN PRIVATE KEY-----MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQCx/SXJY4eslJ9L5wA7w9pYlJTTwpfU7tjvWlyMlJSjMiJvW1Mj3e6kRTqrxcsYWa7yV72Xa/l/5aLZvI0iIta74rqOAyvBSBxQTE6p2MItl9ikaKhd2J5rAlMGGO74Sevp5O3hb1L0rTw8Qx8xnm8nQAaRWM9U2zeOo+aIfk/GYIM6+Y5QCoPLXQi9qqKOGo3a3UUe2VBsxBtXbFXs1hMXprHT017sQUHgmQnof1/GzenZAN82iaWG63hNzD8FgQEyK8gUGIKvn/KSaTxldY1eCFy7ix6cR8dMLXp8Nr5jJHqxGnaGyCfxs5P3HaPO4lvI7ZOwrDBWMeAhSpHk9RtNAgMBAAECggEACUohmT+5GpBNOhxt3jCsKjhjBiRfYU0wBFoOf4XXtibNNkupbLNOG8PDOqjhnz07DMn4irkndf3pwHx/TztLQtYkD3pp47YcSDKbXnECPXfx5i7SLse6CPK/m49clZfiGLyKj9wME9ogzTJho+jVe1JzpU1h0Nd6MFcslo4lIsDbfs8AxGtv7TIBcPJMcrIN8VXAYuN+Ar/u9eU+JWV5hdwzDB7XTt2+MkJWPoZ957g1+MSgaf0vbxL24N4boV02mxMVWUlhmsStU05+Nbp6QXu2yENsgLdP9VgHV8i3wq53PwMhxKhpXw5fduZY+YrYw1FI4eGSJv6zkY1vPKCoMQKBgQDadd6UKDDa/LIJxWPFn5zejLRmBSoI5GE3W2LeG2/4p64PhxB3mskQgETAaF6ggUlXvtX+U8bRz+LRquAg03kKy/La7DgzJW+fcO9gdnjtKdDS67blQ3+Q0Jr1HkGCkK4n9SWc0FHvGklp2NaSb7ZYyvqeGJ3rfp2br+u0JoRjOQKBgQDQkuxhvnTIYY1ZFY9RnLABmnKJqB6nM4THVR9IGGDVOFiqDz+1m2kR55rwQr02Gy9/WwyEHAImXAhRVABmiHx+vc/QuacjjvUniTjIMiTuCyFnAvf6njZxfA9OtVUaowhFrP87jE/TUc1K13PyDuqTgFJeeUx/jSitDd3j6e6UtQKBgQCvfjaioDK3CH5heQ8wR4t2AGQ+/HELGaO7G4+tyy7E+rbKRH8HBfH1boVMZ8t0dsebVHOFznkOPUkBk5pe5GL9OF9MXKy88Zrc45V40VNNeeUGO1L+k52bkOiadoa7w0wUT0u60GKxiFVnUUj19AXxCIYRkMbz0g/8bHMVkkeRiQKBgQC5+lgma9HsHvgPeCb8KY/TTilVT4BNrKV3rBIhkgM9/Gkq8j/nqnTMz0ybcZcPmLwIfmIxplvQYn3ULufQhWElDhEw12oOTdmRcE0eTYAadfhJxx7g7JQ1Kt7nWs9Q2hB1OGW5bkp7blR0qJqtOtm1vlU0AkrQ7UhYzqWNJTlkhQKBgQCvr+Oo8+ZNBOig1EwUCgzn0HdpvZQhSrqxevi4L8J1m7cVbNOUe2jDIToSeUlAD+HRLQ3sYP/jaH9XU5XKa1oHIYES0+dSSowv82/sJfSJKvqek8EQsL/H3IhtSi0crJfBPJldtQWClHhFW6LsJAR2eor30nsjR5ZwrpmRUzkW+Q==-----END PRIVATE KEY-----".replace(new RegExp('\\n', 'g'), '\n'),
      {
        algorithm: 'RS256',
        expiresIn: '20m'
      }
    )

    try {
      const googleTokenParams = new URLSearchParams()
      googleTokenParams.append(
        'grant_type',
        'urn:ietf:params:oauth:grant-type:jwt-bearer'
      )
      googleTokenParams.append('assertion', _jwt)

      const googleTokenResponse = await fetch(
        'https://www.googleapis.com/oauth2/v4/token',
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
          },
          body: googleTokenParams
        }
      )

      const googleTokenResponseJson = await googleTokenResponse.json()
      if (googleTokenResponse.status >= 400) {
        console.error(googleTokenResponse.statusText)
        throw new Error('Failed to get token')
      }

      const { access_token } = googleTokenResponseJson

      const expires_at = Date.now() + googleTokenResponseJson.expires_in * 1000

      this.cache.set(scope, { access_token, expires_at })

      return access_token
    } catch (e) {
      console.error(e)
      return null
    }
  }
} token_service_TokenService.__initStatic();

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge-contrib/packages/iopa-edge-stackdriver-auth/src/index.ts


// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/async-retry/lib/index.js
var lib = __webpack_require__(114);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge-contrib/packages/iopa-edge-stackdriver/src/buffered-queue.ts
/**
 * Buffered queue of items that calls the flush function with an array of items
 * when either the maxSize is reached or a time interval has passed
 */
class BufferedQueue {
     __init() {this.items = []}

    

    

    

    

    constructor(
        flush,
        options
    ) {;BufferedQueue.prototype.__init.call(this);
        this.flush = flush
        this.maxSize = options.size
        this.flushTimeout = options.flushTimeout
        this.intervalId = null
        this.onFlush = this.onFlush.bind(this)
    }

     maxQueueSizeReached() {
        return this.items.length >= this.maxSize
    }

     async onFlush() {
        this.stopTimeout()
        const data = this.items.splice(0, this.items.length)
        await this.flush(data)
    }

     startTimeout() {
        if (!this.intervalId && this.flushTimeout) {
            this.intervalId = setTimeout(this.onFlush, this.flushTimeout) 
        }
    }

     stopTimeout() {
        if (this.intervalId && this.flushTimeout) {
            clearTimeout(this.intervalId)
            this.intervalId = null
        }
    }

    push(item) {
        this.items.push(item)
        if (this.maxQueueSizeReached()) {
            this.onFlush()
        } else {
            this.startTimeout()
        }
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge-contrib/packages/iopa-edge-stackdriver/src/index.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return src_StackDriverCapability; });
/* unused concated harmony import LogEntry */








const SCOPES = ['https://www.googleapis.com/auth/logging.write']

const _log = console.log
const _error = console.error
const _warn = console.warn
const cache = []
console.log = (x) => {
  _log(x)
  cache.push(x)
}
console.error = (e) => {
  _error(e)
  cache.push(e.stack || e)
}

class src_StackDriverCapability {
  

  constructor(app) {
    this.app = app
    app.logging = {
      flush: () => src_StackDriver.flush(),
      log: (context, ...args) => {
        _log(...args)
        src_StackDriver.log(args[0], dist["LogEntry"].SeverityEnum.DEFAULT, {}, context)
      },
      warn: (context, ...args) => {
        _log(...args)
        src_StackDriver.log(args[0], dist["LogEntry"].SeverityEnum.WARNING, {}, context)
      },
      error: (context, ex, ...optionalArgs) => {
        if (typeof ex === 'string') {
          _error(ex)
          if (/UnhandledPromiseRejectionWarning.*at /s.test(ex)) {
            void src_StackDriver.error(
              ex,
              this.app.properties.get('server.Version'),
              context
            )
          } else {
            src_StackDriver.log(ex, dist["LogEntry"].SeverityEnum.ERROR, {}, context)
          }
        } else {
          _error(ex.message)
          void src_StackDriver.error(
            ex,
            this.app.properties.get('server.Version'),
            context
          )
        }
      }
    }
  }

  async invoke(context, next) {
    context.log = (message, ...args) => {
      this.app.logging.log(context, message, ...args)
    }

    context.warn = (message, ...args) => {
      this.app.logging.warn(context, message, ...args)
    }

    context.error = (message, ...args) => {
      this.app.logging.error(context, message, ...args)
    }

    console.log = context.log
    console.warn = context.warn
    console.error = context.error

    await next()

    const body = await context.get('iopa.Body')

    const labels = Array.from(context.get('iopa.Labels')).reduce(
      (obj, [key, value]) => {
        obj[key] = value
        return obj
      },
      {}
    )

    cache.forEach((x) => context.log(x))
    cache.length = 0

    src_StackDriver.log(
      { logs: body },
      context.response.get('iopa.StatusCode') < 300
        ? dist["LogEntry"].SeverityEnum.INFO
        : dist["LogEntry"].SeverityEnum.WARNING,
      labels,
      context,
      true
    )

    await src_StackDriver.flush()

    console.log = _log
    console.error = _error
    console.warn = _warn
  }
}

class src_StackDriver {
   static __initStatic() {this.error_client = src_StackDriver.createErrorReportingClient()}

   static __initStatic2() {this.log_client = src_StackDriver.createLoggingClient()}

   static __initStatic3() {this.queue = new BufferedQueue(
    src_StackDriver.writeEntries,
    {
      size: 100,
      flushTimeout: 2000
    }
  )}

   static log(
    payload,
    severity,
    labels,
    context,
    isRequest = false
  ) {
    if (false) {}

    const logEntry = {
      //      timestamp: new Date().toISOString(),
      textPayload: payload,
      severity,
      labels,
      trace: `projects/${"sync-24-7"}/traces/${context.get(
        'server.Id'
      )}`,
      logName: `projects/${"sync-24-7"}/logs/${
        isRequest
          ? `${"development"}-request`
          : `${"development"}`
      }`,
      resource: {
        labels: {
          project_id: "sync-24-7",
          function_name: context
            .get('iopa.Path')
            .replace(/^\//, '')
            .replace(/\//g, '-'),
          region: context.get('server.Source')
        },
        type: 'cloud_function'
      }
    }

    if (isRequest) {
      logEntry.httpRequest = {
        requestMethod: context.get('iopa.Method'),
        remoteIp: context.get('iopa.RemoteAddress'),
        responseSize: `${context.response.get('iopa.Size')}`,
        requestUrl: context.get('iopa.OriginalUrl'),
        status: context.response.get('iopa.StatusCode'),
        latency: `${context.get('server.TimeElapsed') / 1000}s`
      }
    }

    if (typeof payload !== 'string') {
      logEntry.jsonPayload = payload
      delete logEntry.textPayload
    }

    src_StackDriver.queue.push(logEntry)
  }

   static async flush() {
    await src_StackDriver.queue.onFlush()
  }

   static async error(
    ex,
    version,
    context
  ) {
    if (false) {}

    const jsonPayload = {
      '@type':
        'type.googleapis.com/google.devtools.clouderrorreporting.v1beta1.ReportedErrorEvent',
      message: typeof ex === 'string' ? ex : ex.stack,
      serviceContext: {
        service: context
          .get('iopa.Path')
          .replace(/^\//, '')
          .replace(/\//g, '-'),
        version,
        resourceType: 'cloud_function'
      }
    }

    const logEntry = {
      timestamp: new Date().toISOString(),
      jsonPayload,
      severity: dist["LogEntry"].SeverityEnum.ERROR,
      labels: {},
      trace: `projects/${"sync-24-7"}/traces/${context.get(
        'server.Id'
      )}`,
      logName: `projects/${"sync-24-7"}/logs/reported-error`,
      resource: {
        labels: {
          project_id: "sync-24-7",
          function_name: context
            .get('iopa.Path')
            .replace(/^\//, '')
            .replace(/\//g, '-'),
          region: context.get('server.Source')
        },
        type: 'cloud_function'
      }
    }

    src_StackDriver.queue.push(logEntry)
  }

   static async writeEntries(entries) {
    const body = {
      dryRun: false,
      entries,
      partialSuccess: true
    }

    void src_StackDriver.log_client.loggingEntriesWrite(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      body,
      {}
    )
  }

   static async signRequest(
    url,
    request
  ) {
    const token = await token_service_TokenService.getToken(SCOPES)

    if (request.headers.set) {
      request.headers.set('authorization', `Bearer ${token}`)
    } else {
      request.headers.authorization = `Bearer ${token}`
    }
  }

   static async fetchProxy(url, init) {
    if (init && init.body && init.body instanceof URLSearchParams) {
      init.headers.set(
        'Content-Type',
        'application/x-www-form-urlencoded; charset=UTF-8'
      )
    }

    try {
      await src_StackDriver.signRequest(url, init)

      const result = await lib(
        async (bail) => {
          const result = await fetch(url, init)

          if (result.status === 403) {
            bail(new Error('Unauthorized'))
          } else if (result.status === 404) {
            bail(
              new Error(`Not Found ${JSON.stringify(init)}`) +
                JSON.stringify(result)
            )
          }

          // override json in case of empty successful (202) responses
          if (result.status === 202) {
            result.json = async () => ({})
          }

          return result
        },
        {
          retries: 3,
          minTimeout: 2000
        }
      )

      return result
    } catch (ex) {
      // rethrow for stack trace upon timeout
      try {
        throw ex
      } catch (ex) {
        console.log(`Fetch Error getting ${url}`)
        console.error(ex)
        return {
          status: 500
        }
      }
    }
  }

   static createLoggingClient() {
    const client = new dist["EntriesApi"]({}, undefined, src_StackDriver.fetchProxy)
    return client
  }

   static createErrorReportingClient() {
    const client = new dist["ErrorReportingApi"]({}, undefined, src_StackDriver.fetchProxy)
    return client
  }
} src_StackDriver.__initStatic(); src_StackDriver.__initStatic2(); src_StackDriver.__initStatic3();


/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-store-kv/src/kv-store.ts











class KVStore  {
    

    constructor(kv) {
        this.kv = kv
    }

     collection(id) {
        return new KVCollection(this.kv, id)
    }

     doc(path) {
        const items = path.split(/(.+)\//)
        return new KVCollection(this.kv, items[1]).doc(items[2])
    }
}

class KVCollection  {
    

    

    constructor(kv, path) {
        this.kv = kv
        this.path = path
    }

     doc(id = guid()) {
        return new KVDocument(this.kv, `${this.path}/${id}`)
    }

     async get() {
        const data = await this.kv.get(this.path)
        return new KVQuerySnapshot(data)
    }
}

class KVDocument {
    

    

    

    constructor(kv, path) {
        this.kv = kv
        this.path = path
        this._data = undefined
    }

     get id() {
        return this.path.split(/(.+)\//)[2]
    }

     collection(id) {
        return new KVCollection(this.kv, `${this.path}/${id}`)
    }

     async set(body, options = { merge: false }) {
        try {
            let result

            if (options.merge) {
                const existing = (await this.kv.get(this.path)) || ({} )
                result = Object.assign(existing, body)
            } else {
                result = body
            }

            const writeResult = new WriteResultImpl()

            ;(result ).updated = writeResult.writeTime.toMillis()

            await this.kv.put(this.path, result)

            return writeResult
        } catch (ex) {
            console.error(ex)
            return new WriteResultImpl()
        }
    }

     async get() {
        try {
            const data = await this.kv.get(this.path)
            return new KVSnapshot(data)
        } catch (ex) {
            console.error(ex)
            return new KVSnapshot(undefined)
        }
    }

     async delete() {
        try {
            await this.kv.delete(this.path)
        } catch (ex) {
            console.error(ex)
        }
        return new WriteResultImpl()
    }
}

class KVQuerySnapshot {
    

    constructor(docs) {
        docs = docs || []
        this._docs = docs.map((doc) => new KVSnapshot(doc))
    }

     get empty() {
        return this._docs !== null && this._docs.length !== 0
    }

     get docs() {
        return this._docs
    }

     get size() {
        return (this._docs && this._docs.length) || 0
    }
}

class KVSnapshot {
    

    constructor(data) {
        this._data = data
    }

     get exists() {
        return this._data !== null
    }

     data() {
        return this._data
    }
}

class WriteResultImpl  {
    /**
     * The write time as set by the Firestore servers.
     */
    

    constructor() {
        this.writeTime = TimestampImpl.now()
    }

    /**
     * Returns true if this `WriteResult` is equal to the provided one.
     *
     * @param other The `WriteResult` to compare against.
     * @return true if this `WriteResult` is equal to the provided one.
     */
    isEqual(other) {
        return this.writeTime === other.writeTime
    }
}

/**
 * A Timestamp represents a point in time independent of any time zone or
 * calendar, represented as seconds and fractions of seconds at nanosecond
 * resolution in UTC Epoch time. It is encoded using the Proleptic Gregorian
 * Calendar which extends the Gregorian calendar backwards to year one. It is
 * encoded assuming all minutes are 60 seconds long, i.e. leap seconds are
 * "smeared" so that no leap second table is needed for interpretation. Range
 * is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z.
 *
 * @see https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto
 */
class TimestampImpl  {
    /**
     * Creates a new timestamp with the current date, with millisecond precision.
     *
     * @return A new `Timestamp` representing the current date.
     */
    static now() {
        return TimestampImpl.fromDate(new Date())
    }

    /**
     * Creates a new timestamp from the given date.
     *
     * @param date The date to initialize the `Timestamp` from.
     * @return A new `Timestamp` representing the same point in time as the
     * given date.
     */
    static fromDate(date) {
        return new TimestampImpl(date)
    }

    /**
     * Creates a new timestamp from the given number of milliseconds.
     *
     * @param milliseconds Number of milliseconds since Unix epoch
     * 1970-01-01T00:00:00Z.
     * @return A new `Timestamp` representing the same point in time as the
     * given number of milliseconds.
     */
    static fromMillis(milliseconds) {
        throw new Error('Not Implemented')
    }

    

    constructor(date) {
        this.date = date
    }

    /**
     * Returns a new `Date` corresponding to this timestamp. This may lose
     * precision.
     *
     * @return JavaScript `Date` object representing the same point in time as
     * this `Timestamp`, with millisecond precision.
     */
    toDate() {
        return this.date
    }

    /**
     * Returns the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
     *
     * @return The point in time corresponding to this timestamp, represented as
     * the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
     */
    toMillis() {
        return this.date.getTime()
    }

    /**
     * Returns true if this `Timestamp` is equal to the provided one.
     *
     * @param other The `Timestamp` to compare against.
     * @return 'true' if this `Timestamp` is equal to the provided one.
     */
    isEqual(other) {
        return this.date === ((other ) ).date
    }
}

/** Create a new guid */
function guid() {
    return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`
}

/** Helper function to create a new 4 character ID (random) */
function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
        .toString(16)
        .substring(1)
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-store-kv/src/index.ts
/* concated harmony reexport KVStore */__webpack_require__.d(__webpack_exports__, "a", function() { return KVStore; });



/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 *
 *
 * @author Jerry Bendy <jerry@icewingcc.com>
 * @licence MIT
 *
 */

(function(self) {
    'use strict';

    var nativeURLSearchParams = (self.URLSearchParams && self.URLSearchParams.prototype.get) ? self.URLSearchParams : null,
        isSupportObjectConstructor = nativeURLSearchParams && (new nativeURLSearchParams({a: 1})).toString() === 'a=1',
        // There is a bug in safari 10.1 (and earlier) that incorrectly decodes `%2B` as an empty space and not a plus.
        decodesPlusesCorrectly = nativeURLSearchParams && (new nativeURLSearchParams('s=%2B').get('s') === '+'),
        __URLSearchParams__ = "__URLSearchParams__",
        // Fix bug in Edge which cannot encode ' &' correctly
        encodesAmpersandsCorrectly = nativeURLSearchParams ? (function() {
            var ampersandTest = new nativeURLSearchParams();
            ampersandTest.append('s', ' &');
            return ampersandTest.toString() === 's=+%26';
        })() : true,
        prototype = URLSearchParamsPolyfill.prototype,
        iterable = !!(self.Symbol && self.Symbol.iterator);

    if (nativeURLSearchParams && isSupportObjectConstructor && decodesPlusesCorrectly && encodesAmpersandsCorrectly) {
        return;
    }


    /**
     * Make a URLSearchParams instance
     *
     * @param {object|string|URLSearchParams} search
     * @constructor
     */
    function URLSearchParamsPolyfill(search) {
        search = search || "";

        // support construct object with another URLSearchParams instance
        if (search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill) {
            search = search.toString();
        }
        this [__URLSearchParams__] = parseToDict(search);
    }


    /**
     * Appends a specified key/value pair as a new search parameter.
     *
     * @param {string} name
     * @param {string} value
     */
    prototype.append = function(name, value) {
        appendTo(this [__URLSearchParams__], name, value);
    };

    /**
     * Deletes the given search parameter, and its associated value,
     * from the list of all search parameters.
     *
     * @param {string} name
     */
    prototype['delete'] = function(name) {
        delete this [__URLSearchParams__] [name];
    };

    /**
     * Returns the first value associated to the given search parameter.
     *
     * @param {string} name
     * @returns {string|null}
     */
    prototype.get = function(name) {
        var dict = this [__URLSearchParams__];
        return name in dict ? dict[name][0] : null;
    };

    /**
     * Returns all the values association with a given search parameter.
     *
     * @param {string} name
     * @returns {Array}
     */
    prototype.getAll = function(name) {
        var dict = this [__URLSearchParams__];
        return name in dict ? dict [name].slice(0) : [];
    };

    /**
     * Returns a Boolean indicating if such a search parameter exists.
     *
     * @param {string} name
     * @returns {boolean}
     */
    prototype.has = function(name) {
        return name in this [__URLSearchParams__];
    };

    /**
     * Sets the value associated to a given search parameter to
     * the given value. If there were several values, delete the
     * others.
     *
     * @param {string} name
     * @param {string} value
     */
    prototype.set = function set(name, value) {
        this [__URLSearchParams__][name] = ['' + value];
    };

    /**
     * Returns a string containg a query string suitable for use in a URL.
     *
     * @returns {string}
     */
    prototype.toString = function() {
        var dict = this[__URLSearchParams__], query = [], i, key, name, value;
        for (key in dict) {
            name = encode(key);
            for (i = 0, value = dict[key]; i < value.length; i++) {
                query.push(name + '=' + encode(value[i]));
            }
        }
        return query.join('&');
    };

    // There is a bug in Safari 10.1 and `Proxy`ing it is not enough.
    var forSureUsePolyfill = !decodesPlusesCorrectly;
    var useProxy = (!forSureUsePolyfill && nativeURLSearchParams && !isSupportObjectConstructor && self.Proxy);
    /*
     * Apply polifill to global object and append other prototype into it
     */
    Object.defineProperty(self, 'URLSearchParams', {
        value: (useProxy ?
            // Safari 10.0 doesn't support Proxy, so it won't extend URLSearchParams on safari 10.0
            new Proxy(nativeURLSearchParams, {
                construct: function(target, args) {
                    return new target((new URLSearchParamsPolyfill(args[0]).toString()));
                }
            }) :
            URLSearchParamsPolyfill)
    });

    var USPProto = self.URLSearchParams.prototype;

    USPProto.polyfill = true;

    /**
     *
     * @param {function} callback
     * @param {object} thisArg
     */
    USPProto.forEach = USPProto.forEach || function(callback, thisArg) {
        var dict = parseToDict(this.toString());
        Object.getOwnPropertyNames(dict).forEach(function(name) {
            dict[name].forEach(function(value) {
                callback.call(thisArg, value, name, this);
            }, this);
        }, this);
    };

    /**
     * Sort all name-value pairs
     */
    USPProto.sort = USPProto.sort || function() {
        var dict = parseToDict(this.toString()), keys = [], k, i, j;
        for (k in dict) {
            keys.push(k);
        }
        keys.sort();

        for (i = 0; i < keys.length; i++) {
            this['delete'](keys[i]);
        }
        for (i = 0; i < keys.length; i++) {
            var key = keys[i], values = dict[key];
            for (j = 0; j < values.length; j++) {
                this.append(key, values[j]);
            }
        }
    };

    /**
     * Returns an iterator allowing to go through all keys of
     * the key/value pairs contained in this object.
     *
     * @returns {function}
     */
    USPProto.keys = USPProto.keys || function() {
        var items = [];
        this.forEach(function(item, name) {
            items.push(name);
        });
        return makeIterator(items);
    };

    /**
     * Returns an iterator allowing to go through all values of
     * the key/value pairs contained in this object.
     *
     * @returns {function}
     */
    USPProto.values = USPProto.values || function() {
        var items = [];
        this.forEach(function(item) {
            items.push(item);
        });
        return makeIterator(items);
    };

    /**
     * Returns an iterator allowing to go through all key/value
     * pairs contained in this object.
     *
     * @returns {function}
     */
    USPProto.entries = USPProto.entries || function() {
        var items = [];
        this.forEach(function(item, name) {
            items.push([name, item]);
        });
        return makeIterator(items);
    };


    if (iterable) {
        USPProto[self.Symbol.iterator] = USPProto[self.Symbol.iterator] || USPProto.entries;
    }


    function encode(str) {
        var replace = {
            '!': '%21',
            "'": '%27',
            '(': '%28',
            ')': '%29',
            '~': '%7E',
            '%20': '+',
            '%00': '\x00'
        };
        return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function(match) {
            return replace[match];
        });
    }

    function decode(str) {
        return str
            .replace(/[ +]/g, '%20')
            .replace(/(%[a-f0-9]{2})+/ig, function(match) {
                return decodeURIComponent(match);
            });
    }

    function makeIterator(arr) {
        var iterator = {
            next: function() {
                var value = arr.shift();
                return {done: value === undefined, value: value};
            }
        };

        if (iterable) {
            iterator[self.Symbol.iterator] = function() {
                return iterator;
            };
        }

        return iterator;
    }

    function parseToDict(search) {
        var dict = {};

        if (typeof search === "object") {
            // if `search` is an array, treat it as a sequence
            if (isArray(search)) {
                for (var i = 0; i < search.length; i++) {
                    var item = search[i];
                    if (isArray(item) && item.length === 2) {
                        appendTo(dict, item[0], item[1]);
                    } else {
                        throw new TypeError("Failed to construct 'URLSearchParams': Sequence initializer must only contain pair elements");
                    }
                }

            } else {
                for (var key in search) {
                    if (search.hasOwnProperty(key)) {
                        appendTo(dict, key, search[key]);
                    }
                }
            }

        } else {
            // remove first '?'
            if (search.indexOf("?") === 0) {
                search = search.slice(1);
            }

            var pairs = search.split("&");
            for (var j = 0; j < pairs.length; j++) {
                var value = pairs [j],
                    index = value.indexOf('=');

                if (-1 < index) {
                    appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));

                } else {
                    if (value) {
                        appendTo(dict, decode(value), '');
                    }
                }
            }
        }

        return dict;
    }

    function appendTo(dict, name, value) {
        var val = typeof value === 'string' ? value : (
            value !== null && value !== undefined && typeof value.toString === 'function' ? value.toString() : JSON.stringify(value)
        )

        if (name in dict) {
            dict[name].push(val);
        } else {
            dict[name] = [val];
        }
    }

    function isArray(val) {
        return !!val && '[object Array]' === Object.prototype.toString.call(val);
    }

})(typeof global !== 'undefined' ? global : (typeof window !== 'undefined' ? window : this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16)))

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)(module), __webpack_require__(16)))

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(215);
exports.encode = exports.stringify = __webpack_require__(216);


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 217 */
/***/ (function(module) {

module.exports = {"name":"iopa","version":"3.0.0","description":"API-first, Internet of Things (IoT) stack for Typescript, official implementation of the Internet Open Protocol Alliance (IOPA) reference pattern","main":"dist/index.js","ts:main":"src/index.ts","types":"src/index.ts","author":"IOPA","homepage":"https://iopa.io","keywords":["iopa","owin","middleware","router","route","http","connect","express","promise","async","framework","node","tasks"],"license":"Apache-2.0","maintainers":[{"name":"iopa","email":"build@iopa.io"}],"repository":{"type":"git","url":"https://github.com/iopa-io/iopa.git"},"scripts":{"build":"rm -rf ./dist && tsc","lint":"berun-dev lint"},"dependencies":{"iopa-types":"^3.0.0"},"devDependencies":{"@berun/dev-scripts":"^7.0.3","@types/jest":"^25.2.3"},"peerDependencies":{}};

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable
/**
 * Stackdriver Logging
 * Writes log entries and manages your Stackdriver Logging configuration. The table entries below are presented in alphabetical order, not in order of common use. For explanations of the concepts found in the table entries, read the Stackdriver Logging documentation.
 *
 * OpenAPI spec version: v2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(219), exports);
__exportStar(__webpack_require__(221), exports);
//# sourceMappingURL=index.js.map

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Stackdriver Logging
 * Writes log entries and manages your Stackdriver Logging configuration. The table entries below are presented in alphabetical order, not in order of common use. For explanations of the concepts found in the table entries, read the Stackdriver Logging documentation.
 *
 * OpenAPI spec version: v2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectsApi = exports.ProjectsApiFactory = exports.ProjectsApiFp = exports.ProjectsApiFetchParamCreator = exports.OrganizationsApi = exports.OrganizationsApiFactory = exports.OrganizationsApiFp = exports.OrganizationsApiFetchParamCreator = exports.MonitoredResourceDescriptorsApi = exports.MonitoredResourceDescriptorsApiFactory = exports.MonitoredResourceDescriptorsApiFp = exports.MonitoredResourceDescriptorsApiFetchParamCreator = exports.EntriesApi = exports.EntriesApiFactory = exports.EntriesApiFp = exports.EntriesApiFetchParamCreator = exports.MonitoredResourceDescriptor = exports.MetricDescriptorMetadata = exports.MetricDescriptor = exports.LogSink = exports.LogMetric = exports.LogLine = exports.LogEntry = exports.LabelDescriptor = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = void 0;
const url = __webpack_require__(12);
const portableFetch = __webpack_require__(41);
const BASE_PATH = 'https://logging.googleapis.com'.replace(/\/+$/, '');
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|'
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, fetch = portableFetch) {
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace LabelDescriptor
 */
var LabelDescriptor;
(function (LabelDescriptor) {
    /**
     * @export
     * @enum {string}
     */
    let ValueTypeEnum;
    (function (ValueTypeEnum) {
        ValueTypeEnum[ValueTypeEnum["STRING"] = 'STRING'] = "STRING";
        ValueTypeEnum[ValueTypeEnum["BOOL"] = 'BOOL'] = "BOOL";
        ValueTypeEnum[ValueTypeEnum["INT64"] = 'INT64'] = "INT64";
    })(ValueTypeEnum = LabelDescriptor.ValueTypeEnum || (LabelDescriptor.ValueTypeEnum = {}));
})(LabelDescriptor = exports.LabelDescriptor || (exports.LabelDescriptor = {}));
/**
 * @export
 * @namespace LogEntry
 */
var LogEntry;
(function (LogEntry) {
    /**
     * @export
     * @enum {string}
     */
    let SeverityEnum;
    (function (SeverityEnum) {
        SeverityEnum[SeverityEnum["DEFAULT"] = 'DEFAULT'] = "DEFAULT";
        SeverityEnum[SeverityEnum["DEBUG"] = 'DEBUG'] = "DEBUG";
        SeverityEnum[SeverityEnum["INFO"] = 'INFO'] = "INFO";
        SeverityEnum[SeverityEnum["NOTICE"] = 'NOTICE'] = "NOTICE";
        SeverityEnum[SeverityEnum["WARNING"] = 'WARNING'] = "WARNING";
        SeverityEnum[SeverityEnum["ERROR"] = 'ERROR'] = "ERROR";
        SeverityEnum[SeverityEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
        SeverityEnum[SeverityEnum["ALERT"] = 'ALERT'] = "ALERT";
        SeverityEnum[SeverityEnum["EMERGENCY"] = 'EMERGENCY'] = "EMERGENCY";
    })(SeverityEnum = LogEntry.SeverityEnum || (LogEntry.SeverityEnum = {}));
})(LogEntry = exports.LogEntry || (exports.LogEntry = {}));
/**
 * @export
 * @namespace LogLine
 */
var LogLine;
(function (LogLine) {
    /**
     * @export
     * @enum {string}
     */
    let SeverityEnum;
    (function (SeverityEnum) {
        SeverityEnum[SeverityEnum["DEFAULT"] = 'DEFAULT'] = "DEFAULT";
        SeverityEnum[SeverityEnum["DEBUG"] = 'DEBUG'] = "DEBUG";
        SeverityEnum[SeverityEnum["INFO"] = 'INFO'] = "INFO";
        SeverityEnum[SeverityEnum["NOTICE"] = 'NOTICE'] = "NOTICE";
        SeverityEnum[SeverityEnum["WARNING"] = 'WARNING'] = "WARNING";
        SeverityEnum[SeverityEnum["ERROR"] = 'ERROR'] = "ERROR";
        SeverityEnum[SeverityEnum["CRITICAL"] = 'CRITICAL'] = "CRITICAL";
        SeverityEnum[SeverityEnum["ALERT"] = 'ALERT'] = "ALERT";
        SeverityEnum[SeverityEnum["EMERGENCY"] = 'EMERGENCY'] = "EMERGENCY";
    })(SeverityEnum = LogLine.SeverityEnum || (LogLine.SeverityEnum = {}));
})(LogLine = exports.LogLine || (exports.LogLine = {}));
/**
 * @export
 * @namespace LogMetric
 */
var LogMetric;
(function (LogMetric) {
    /**
     * @export
     * @enum {string}
     */
    let VersionEnum;
    (function (VersionEnum) {
        VersionEnum[VersionEnum["V2"] = 'V2'] = "V2";
        VersionEnum[VersionEnum["V1"] = 'V1'] = "V1";
    })(VersionEnum = LogMetric.VersionEnum || (LogMetric.VersionEnum = {}));
})(LogMetric = exports.LogMetric || (exports.LogMetric = {}));
/**
 * @export
 * @namespace LogSink
 */
var LogSink;
(function (LogSink) {
    /**
     * @export
     * @enum {string}
     */
    let OutputVersionFormatEnum;
    (function (OutputVersionFormatEnum) {
        OutputVersionFormatEnum[OutputVersionFormatEnum["VERSIONFORMATUNSPECIFIED"] = 'VERSION_FORMAT_UNSPECIFIED'] = "VERSIONFORMATUNSPECIFIED";
        OutputVersionFormatEnum[OutputVersionFormatEnum["V2"] = 'V2'] = "V2";
        OutputVersionFormatEnum[OutputVersionFormatEnum["V1"] = 'V1'] = "V1";
    })(OutputVersionFormatEnum = LogSink.OutputVersionFormatEnum || (LogSink.OutputVersionFormatEnum = {}));
})(LogSink = exports.LogSink || (exports.LogSink = {}));
/**
 * @export
 * @namespace MetricDescriptor
 */
var MetricDescriptor;
(function (MetricDescriptor) {
    /**
     * @export
     * @enum {string}
     */
    let LaunchStageEnum;
    (function (LaunchStageEnum) {
        LaunchStageEnum[LaunchStageEnum["LAUNCHSTAGEUNSPECIFIED"] = 'LAUNCH_STAGE_UNSPECIFIED'] = "LAUNCHSTAGEUNSPECIFIED";
        LaunchStageEnum[LaunchStageEnum["EARLYACCESS"] = 'EARLY_ACCESS'] = "EARLYACCESS";
        LaunchStageEnum[LaunchStageEnum["ALPHA"] = 'ALPHA'] = "ALPHA";
        LaunchStageEnum[LaunchStageEnum["BETA"] = 'BETA'] = "BETA";
        LaunchStageEnum[LaunchStageEnum["GA"] = 'GA'] = "GA";
        LaunchStageEnum[LaunchStageEnum["DEPRECATED"] = 'DEPRECATED'] = "DEPRECATED";
    })(LaunchStageEnum = MetricDescriptor.LaunchStageEnum || (MetricDescriptor.LaunchStageEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let MetricKindEnum;
    (function (MetricKindEnum) {
        MetricKindEnum[MetricKindEnum["METRICKINDUNSPECIFIED"] = 'METRIC_KIND_UNSPECIFIED'] = "METRICKINDUNSPECIFIED";
        MetricKindEnum[MetricKindEnum["GAUGE"] = 'GAUGE'] = "GAUGE";
        MetricKindEnum[MetricKindEnum["DELTA"] = 'DELTA'] = "DELTA";
        MetricKindEnum[MetricKindEnum["CUMULATIVE"] = 'CUMULATIVE'] = "CUMULATIVE";
    })(MetricKindEnum = MetricDescriptor.MetricKindEnum || (MetricDescriptor.MetricKindEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let ValueTypeEnum;
    (function (ValueTypeEnum) {
        ValueTypeEnum[ValueTypeEnum["VALUETYPEUNSPECIFIED"] = 'VALUE_TYPE_UNSPECIFIED'] = "VALUETYPEUNSPECIFIED";
        ValueTypeEnum[ValueTypeEnum["BOOL"] = 'BOOL'] = "BOOL";
        ValueTypeEnum[ValueTypeEnum["INT64"] = 'INT64'] = "INT64";
        ValueTypeEnum[ValueTypeEnum["DOUBLE"] = 'DOUBLE'] = "DOUBLE";
        ValueTypeEnum[ValueTypeEnum["STRING"] = 'STRING'] = "STRING";
        ValueTypeEnum[ValueTypeEnum["DISTRIBUTION"] = 'DISTRIBUTION'] = "DISTRIBUTION";
        ValueTypeEnum[ValueTypeEnum["MONEY"] = 'MONEY'] = "MONEY";
    })(ValueTypeEnum = MetricDescriptor.ValueTypeEnum || (MetricDescriptor.ValueTypeEnum = {}));
})(MetricDescriptor = exports.MetricDescriptor || (exports.MetricDescriptor = {}));
/**
 * @export
 * @namespace MetricDescriptorMetadata
 */
var MetricDescriptorMetadata;
(function (MetricDescriptorMetadata) {
    /**
     * @export
     * @enum {string}
     */
    let LaunchStageEnum;
    (function (LaunchStageEnum) {
        LaunchStageEnum[LaunchStageEnum["LAUNCHSTAGEUNSPECIFIED"] = 'LAUNCH_STAGE_UNSPECIFIED'] = "LAUNCHSTAGEUNSPECIFIED";
        LaunchStageEnum[LaunchStageEnum["EARLYACCESS"] = 'EARLY_ACCESS'] = "EARLYACCESS";
        LaunchStageEnum[LaunchStageEnum["ALPHA"] = 'ALPHA'] = "ALPHA";
        LaunchStageEnum[LaunchStageEnum["BETA"] = 'BETA'] = "BETA";
        LaunchStageEnum[LaunchStageEnum["GA"] = 'GA'] = "GA";
        LaunchStageEnum[LaunchStageEnum["DEPRECATED"] = 'DEPRECATED'] = "DEPRECATED";
    })(LaunchStageEnum = MetricDescriptorMetadata.LaunchStageEnum || (MetricDescriptorMetadata.LaunchStageEnum = {}));
})(MetricDescriptorMetadata = exports.MetricDescriptorMetadata || (exports.MetricDescriptorMetadata = {}));
/**
 * @export
 * @namespace MonitoredResourceDescriptor
 */
var MonitoredResourceDescriptor;
(function (MonitoredResourceDescriptor) {
    /**
     * @export
     * @enum {string}
     */
    let LaunchStageEnum;
    (function (LaunchStageEnum) {
        LaunchStageEnum[LaunchStageEnum["LAUNCHSTAGEUNSPECIFIED"] = 'LAUNCH_STAGE_UNSPECIFIED'] = "LAUNCHSTAGEUNSPECIFIED";
        LaunchStageEnum[LaunchStageEnum["EARLYACCESS"] = 'EARLY_ACCESS'] = "EARLYACCESS";
        LaunchStageEnum[LaunchStageEnum["ALPHA"] = 'ALPHA'] = "ALPHA";
        LaunchStageEnum[LaunchStageEnum["BETA"] = 'BETA'] = "BETA";
        LaunchStageEnum[LaunchStageEnum["GA"] = 'GA'] = "GA";
        LaunchStageEnum[LaunchStageEnum["DEPRECATED"] = 'DEPRECATED'] = "DEPRECATED";
    })(LaunchStageEnum = MonitoredResourceDescriptor.LaunchStageEnum || (MonitoredResourceDescriptor.LaunchStageEnum = {}));
})(MonitoredResourceDescriptor = exports.MonitoredResourceDescriptor || (exports.MonitoredResourceDescriptor = {}));
/**
 * EntriesApi - fetch parameter creator
 * @export
 */
const EntriesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Lists log entries. Use this method to retrieve log entries that originated from a project/folder/organization/billing account. For ways to export log entries, see Exporting Logs.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {ListLogEntriesRequest} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingEntriesList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options = {}) {
            const localVarPath = `/v2/entries:list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Writes log entries to Logging. This API method is the only way to send log entries to Logging. This method is used, directly or indirectly, by the Logging agent (fluentd) and all logging libraries configured to use Logging. A single request may contain log entries for a maximum of 1000 different resources (projects, organizations, billing accounts or folders)
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {WriteLogEntriesRequest} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingEntriesWrite(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options = {}) {
            const localVarPath = `/v2/entries:write`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.write'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.write'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
exports.EntriesApiFetchParamCreator = EntriesApiFetchParamCreator;
/**
 * EntriesApi - functional programming interface
 * @export
 */
const EntriesApiFp = function (configuration) {
    return {
        /**
         * Lists log entries. Use this method to retrieve log entries that originated from a project/folder/organization/billing account. For ways to export log entries, see Exporting Logs.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {ListLogEntriesRequest} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingEntriesList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            const localVarFetchArgs = exports.EntriesApiFetchParamCreator(configuration).loggingEntriesList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Writes log entries to Logging. This API method is the only way to send log entries to Logging. This method is used, directly or indirectly, by the Logging agent (fluentd) and all logging libraries configured to use Logging. A single request may contain log entries for a maximum of 1000 different resources (projects, organizations, billing accounts or folders)
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {WriteLogEntriesRequest} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingEntriesWrite(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            const localVarFetchArgs = exports.EntriesApiFetchParamCreator(configuration).loggingEntriesWrite(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        }
    };
};
exports.EntriesApiFp = EntriesApiFp;
/**
 * EntriesApi - factory interface
 * @export
 */
const EntriesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Lists log entries. Use this method to retrieve log entries that originated from a project/folder/organization/billing account. For ways to export log entries, see Exporting Logs.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {ListLogEntriesRequest} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingEntriesList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            return exports.EntriesApiFp(configuration).loggingEntriesList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(fetch, basePath);
        },
        /**
         * Writes log entries to Logging. This API method is the only way to send log entries to Logging. This method is used, directly or indirectly, by the Logging agent (fluentd) and all logging libraries configured to use Logging. A single request may contain log entries for a maximum of 1000 different resources (projects, organizations, billing accounts or folders)
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {WriteLogEntriesRequest} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingEntriesWrite(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            return exports.EntriesApiFp(configuration).loggingEntriesWrite(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(fetch, basePath);
        }
    };
};
exports.EntriesApiFactory = EntriesApiFactory;
/**
 * EntriesApi - object-oriented interface
 * @export
 * @class EntriesApi
 * @extends {BaseAPI}
 */
class EntriesApi extends BaseAPI {
    /**
     * Lists log entries. Use this method to retrieve log entries that originated from a project/folder/organization/billing account. For ways to export log entries, see Exporting Logs.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {ListLogEntriesRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntriesApi
     */
    loggingEntriesList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
        return exports.EntriesApiFp(this.configuration).loggingEntriesList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(this.fetch, this.basePath);
    }
    /**
     * Writes log entries to Logging. This API method is the only way to send log entries to Logging. This method is used, directly or indirectly, by the Logging agent (fluentd) and all logging libraries configured to use Logging. A single request may contain log entries for a maximum of 1000 different resources (projects, organizations, billing accounts or folders)
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {WriteLogEntriesRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntriesApi
     */
    loggingEntriesWrite(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
        return exports.EntriesApiFp(this.configuration).loggingEntriesWrite(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(this.fetch, this.basePath);
    }
}
exports.EntriesApi = EntriesApi;
/**
 * MonitoredResourceDescriptorsApi - fetch parameter creator
 * @export
 */
const MonitoredResourceDescriptorsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Lists the descriptors for monitored resource types used by Logging.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingMonitoredResourceDescriptorsList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options = {}) {
            const localVarPath = `/v2/monitoredResourceDescriptors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter.pageSize = pageSize;
            }
            if (pageToken !== undefined) {
                localVarQueryParameter.pageToken = pageToken;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
exports.MonitoredResourceDescriptorsApiFetchParamCreator = MonitoredResourceDescriptorsApiFetchParamCreator;
/**
 * MonitoredResourceDescriptorsApi - functional programming interface
 * @export
 */
const MonitoredResourceDescriptorsApiFp = function (configuration) {
    return {
        /**
         * Lists the descriptors for monitored resource types used by Logging.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingMonitoredResourceDescriptorsList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
            const localVarFetchArgs = exports.MonitoredResourceDescriptorsApiFetchParamCreator(configuration).loggingMonitoredResourceDescriptorsList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        }
    };
};
exports.MonitoredResourceDescriptorsApiFp = MonitoredResourceDescriptorsApiFp;
/**
 * MonitoredResourceDescriptorsApi - factory interface
 * @export
 */
const MonitoredResourceDescriptorsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Lists the descriptors for monitored resource types used by Logging.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingMonitoredResourceDescriptorsList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
            return exports.MonitoredResourceDescriptorsApiFp(configuration).loggingMonitoredResourceDescriptorsList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options)(fetch, basePath);
        }
    };
};
exports.MonitoredResourceDescriptorsApiFactory = MonitoredResourceDescriptorsApiFactory;
/**
 * MonitoredResourceDescriptorsApi - object-oriented interface
 * @export
 * @class MonitoredResourceDescriptorsApi
 * @extends {BaseAPI}
 */
class MonitoredResourceDescriptorsApi extends BaseAPI {
    /**
     * Lists the descriptors for monitored resource types used by Logging.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
     * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitoredResourceDescriptorsApi
     */
    loggingMonitoredResourceDescriptorsList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
        return exports.MonitoredResourceDescriptorsApiFp(this.configuration).loggingMonitoredResourceDescriptorsList(_xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options)(this.fetch, this.basePath);
    }
}
exports.MonitoredResourceDescriptorsApi = MonitoredResourceDescriptorsApi;
/**
 * OrganizationsApi - fetch parameter creator
 * @export
 */
const OrganizationsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates a new exclusion in a specified parent resource. Only log entries belonging to that resource can be excluded. You can have up to 10 exclusions in a resource.
         * @param {string} parent Required. The parent resource in which to create the exclusion: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot; Examples: \&quot;projects/my-logging-project\&quot;, \&quot;organizations/123456789\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogExclusion} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options = {}) {
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent', 'Required parameter parent was null or undefined when calling loggingOrganizationsExclusionsCreate.');
            }
            const localVarPath = `/v2/{parent}/exclusions`.replace(`{${'parent'}}`, encodeURIComponent(String(parent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Deletes an exclusion.
         * @param {string} name Required. The resource name of an existing exclusion to delete: \&quot;projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\&quot; Example: \&quot;projects/my-project-id/exclusions/my-exclusion-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsDelete(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options = {}) {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling loggingOrganizationsExclusionsDelete.');
            }
            const localVarPath = `/v2/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Gets the description of an exclusion.
         * @param {string} name Required. The resource name of an existing exclusion: \&quot;projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\&quot; Example: \&quot;projects/my-project-id/exclusions/my-exclusion-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsGet(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options = {}) {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling loggingOrganizationsExclusionsGet.');
            }
            const localVarPath = `/v2/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Lists all the exclusions in a parent resource.
         * @param {string} parent Required. The parent resource whose exclusions are to be listed. \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options = {}) {
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent', 'Required parameter parent was null or undefined when calling loggingOrganizationsExclusionsList.');
            }
            const localVarPath = `/v2/{parent}/exclusions`.replace(`{${'parent'}}`, encodeURIComponent(String(parent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter.pageSize = pageSize;
            }
            if (pageToken !== undefined) {
                localVarQueryParameter.pageToken = pageToken;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Changes one or more properties of an existing exclusion.
         * @param {string} name Required. The resource name of the exclusion to update: \&quot;projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\&quot; Example: \&quot;projects/my-project-id/exclusions/my-exclusion-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogExclusion} [body]
         * @param {string} [updateMask] Required. A non-empty list of fields to change in the existing exclusion. New values for the fields are taken from the corresponding fields in the LogExclusion included in this request. Fields not mentioned in update_mask are not changed and are ignored in the request.For example, to change the filter and description of an exclusion, specify an update_mask of \&quot;filter,description\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsPatch(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, updateMask, options = {}) {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling loggingOrganizationsExclusionsPatch.');
            }
            const localVarPath = `/v2/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            if (updateMask !== undefined) {
                localVarQueryParameter.updateMask = updateMask;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Deletes all the log entries in a log. The log reappears if it receives new entries. Log entries written shortly before the delete operation might not be deleted.
         * @param {string} logName Required. The resource name of the log to delete: \&quot;projects/[PROJECT_ID]/logs/[LOG_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/logs/[LOG_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]\&quot; \&quot;folders/[FOLDER_ID]/logs/[LOG_ID]\&quot; [LOG_ID] must be URL-encoded. For example, \&quot;projects/my-project-id/logs/syslog\&quot;, \&quot;organizations/1234567890/logs/cloudresourcemanager.googleapis.com%2Factivity\&quot;. For more information about log names, see LogEntry.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsLogsDelete(logName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options = {}) {
            // verify required parameter 'logName' is not null or undefined
            if (logName === null || logName === undefined) {
                throw new RequiredError('logName', 'Required parameter logName was null or undefined when calling loggingOrganizationsLogsDelete.');
            }
            const localVarPath = `/v2/{logName}`.replace(`{${'logName'}}`, encodeURIComponent(String(logName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Lists the logs in projects, organizations, folders, or billing accounts. Only logs that have entries are listed.
         * @param {string} parent Required. The resource name that owns the logs: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsLogsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options = {}) {
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent', 'Required parameter parent was null or undefined when calling loggingOrganizationsLogsList.');
            }
            const localVarPath = `/v2/{parent}/logs`.replace(`{${'parent'}}`, encodeURIComponent(String(parent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter.pageSize = pageSize;
            }
            if (pageToken !== undefined) {
                localVarQueryParameter.pageToken = pageToken;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Creates a sink that exports specified log entries to a destination. The export of newly-ingested log entries begins immediately, unless the sink's writer_identity is not permitted to write to the destination. A sink can export log entries only from the resource owning the sink.
         * @param {string} parent Required. The resource in which to create the sink: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot; Examples: \&quot;projects/my-logging-project\&quot;, \&quot;organizations/123456789\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogSink} [body]
         * @param {boolean} [uniqueWriterIdentity] Optional. Determines the kind of IAM identity returned as writer_identity in the new sink. If this value is omitted or set to false, and if the sink&#39;s parent is a project, then the value returned as writer_identity is the same group or service account used by Logging before the addition of writer identities to this API. The sink&#39;s destination must be in the same project as the sink itself.If this field is set to true, or if the sink is owned by a non-project resource such as an organization, then the value of writer_identity will be a unique service account used only for exports from the new sink. For more information, see writer_identity in LogSink.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, options = {}) {
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent', 'Required parameter parent was null or undefined when calling loggingOrganizationsSinksCreate.');
            }
            const localVarPath = `/v2/{parent}/sinks`.replace(`{${'parent'}}`, encodeURIComponent(String(parent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            if (uniqueWriterIdentity !== undefined) {
                localVarQueryParameter.uniqueWriterIdentity = uniqueWriterIdentity;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Deletes a sink. If the sink has a unique writer_identity, then that service account is also deleted.
         * @param {string} sinkName Required. The full resource name of the sink to delete, including the parent resource and the sink identifier: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksDelete(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options = {}) {
            // verify required parameter 'sinkName' is not null or undefined
            if (sinkName === null || sinkName === undefined) {
                throw new RequiredError('sinkName', 'Required parameter sinkName was null or undefined when calling loggingOrganizationsSinksDelete.');
            }
            const localVarPath = `/v2/{sinkName}`.replace(`{${'sinkName'}}`, encodeURIComponent(String(sinkName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Gets a sink.
         * @param {string} sinkName Required. The resource name of the sink: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksGet(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options = {}) {
            // verify required parameter 'sinkName' is not null or undefined
            if (sinkName === null || sinkName === undefined) {
                throw new RequiredError('sinkName', 'Required parameter sinkName was null or undefined when calling loggingOrganizationsSinksGet.');
            }
            const localVarPath = `/v2/{sinkName}`.replace(`{${'sinkName'}}`, encodeURIComponent(String(sinkName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Lists sinks.
         * @param {string} parent Required. The parent resource whose sinks are to be listed: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options = {}) {
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent', 'Required parameter parent was null or undefined when calling loggingOrganizationsSinksList.');
            }
            const localVarPath = `/v2/{parent}/sinks`.replace(`{${'parent'}}`, encodeURIComponent(String(parent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter.pageSize = pageSize;
            }
            if (pageToken !== undefined) {
                localVarQueryParameter.pageToken = pageToken;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Updates a sink. This method replaces the following fields in the existing sink with values from the new sink: destination, and filter.The updated sink might also have a new writer_identity; see the unique_writer_identity field.
         * @param {string} sinkName Required. The full resource name of the sink to update, including the parent resource and the sink identifier: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogSink} [body]
         * @param {boolean} [uniqueWriterIdentity] Optional. See sinks.create for a description of this field. When updating a sink, the effect of this field on the value of writer_identity in the updated sink depends on both the old and new values of this field: If the old and new values of this field are both false or both true, then there is no change to the sink&#39;s writer_identity. If the old value is false and the new value is true, then writer_identity is changed to a unique service account. It is an error if the old value is true and the new value is set to false or defaulted to false.
         * @param {string} [updateMask] Optional. Field mask that specifies the fields in sink that need an update. A sink field will be overwritten if, and only if, it is in the update mask. name and output only fields cannot be updated.An empty updateMask is temporarily treated as using the following mask for backwards compatibility purposes:  destination,filter,includeChildren At some point in the future, behavior will be removed and specifying an empty updateMask will be an error.For a detailed FieldMask definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMaskExample: updateMask&#x3D;filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksPatch(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options = {}) {
            // verify required parameter 'sinkName' is not null or undefined
            if (sinkName === null || sinkName === undefined) {
                throw new RequiredError('sinkName', 'Required parameter sinkName was null or undefined when calling loggingOrganizationsSinksPatch.');
            }
            const localVarPath = `/v2/{sinkName}`.replace(`{${'sinkName'}}`, encodeURIComponent(String(sinkName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            if (uniqueWriterIdentity !== undefined) {
                localVarQueryParameter.uniqueWriterIdentity = uniqueWriterIdentity;
            }
            if (updateMask !== undefined) {
                localVarQueryParameter.updateMask = updateMask;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Updates a sink. This method replaces the following fields in the existing sink with values from the new sink: destination, and filter.The updated sink might also have a new writer_identity; see the unique_writer_identity field.
         * @param {string} sinkName Required. The full resource name of the sink to update, including the parent resource and the sink identifier: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogSink} [body]
         * @param {boolean} [uniqueWriterIdentity] Optional. See sinks.create for a description of this field. When updating a sink, the effect of this field on the value of writer_identity in the updated sink depends on both the old and new values of this field: If the old and new values of this field are both false or both true, then there is no change to the sink&#39;s writer_identity. If the old value is false and the new value is true, then writer_identity is changed to a unique service account. It is an error if the old value is true and the new value is set to false or defaulted to false.
         * @param {string} [updateMask] Optional. Field mask that specifies the fields in sink that need an update. A sink field will be overwritten if, and only if, it is in the update mask. name and output only fields cannot be updated.An empty updateMask is temporarily treated as using the following mask for backwards compatibility purposes:  destination,filter,includeChildren At some point in the future, behavior will be removed and specifying an empty updateMask will be an error.For a detailed FieldMask definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMaskExample: updateMask&#x3D;filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksUpdate(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options = {}) {
            // verify required parameter 'sinkName' is not null or undefined
            if (sinkName === null || sinkName === undefined) {
                throw new RequiredError('sinkName', 'Required parameter sinkName was null or undefined when calling loggingOrganizationsSinksUpdate.');
            }
            const localVarPath = `/v2/{sinkName}`.replace(`{${'sinkName'}}`, encodeURIComponent(String(sinkName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.admin'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            if (uniqueWriterIdentity !== undefined) {
                localVarQueryParameter.uniqueWriterIdentity = uniqueWriterIdentity;
            }
            if (updateMask !== undefined) {
                localVarQueryParameter.updateMask = updateMask;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
exports.OrganizationsApiFetchParamCreator = OrganizationsApiFetchParamCreator;
/**
 * OrganizationsApi - functional programming interface
 * @export
 */
const OrganizationsApiFp = function (configuration) {
    return {
        /**
         * Creates a new exclusion in a specified parent resource. Only log entries belonging to that resource can be excluded. You can have up to 10 exclusions in a resource.
         * @param {string} parent Required. The parent resource in which to create the exclusion: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot; Examples: \&quot;projects/my-logging-project\&quot;, \&quot;organizations/123456789\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogExclusion} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            const localVarFetchArgs = exports.OrganizationsApiFetchParamCreator(configuration).loggingOrganizationsExclusionsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an exclusion.
         * @param {string} name Required. The resource name of an existing exclusion to delete: \&quot;projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\&quot; Example: \&quot;projects/my-project-id/exclusions/my-exclusion-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsDelete(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            const localVarFetchArgs = exports.OrganizationsApiFetchParamCreator(configuration).loggingOrganizationsExclusionsDelete(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the description of an exclusion.
         * @param {string} name Required. The resource name of an existing exclusion: \&quot;projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\&quot; Example: \&quot;projects/my-project-id/exclusions/my-exclusion-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsGet(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            const localVarFetchArgs = exports.OrganizationsApiFetchParamCreator(configuration).loggingOrganizationsExclusionsGet(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists all the exclusions in a parent resource.
         * @param {string} parent Required. The parent resource whose exclusions are to be listed. \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
            const localVarFetchArgs = exports.OrganizationsApiFetchParamCreator(configuration).loggingOrganizationsExclusionsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Changes one or more properties of an existing exclusion.
         * @param {string} name Required. The resource name of the exclusion to update: \&quot;projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\&quot; Example: \&quot;projects/my-project-id/exclusions/my-exclusion-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogExclusion} [body]
         * @param {string} [updateMask] Required. A non-empty list of fields to change in the existing exclusion. New values for the fields are taken from the corresponding fields in the LogExclusion included in this request. Fields not mentioned in update_mask are not changed and are ignored in the request.For example, to change the filter and description of an exclusion, specify an update_mask of \&quot;filter,description\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsPatch(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, updateMask, options) {
            const localVarFetchArgs = exports.OrganizationsApiFetchParamCreator(configuration).loggingOrganizationsExclusionsPatch(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, updateMask, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes all the log entries in a log. The log reappears if it receives new entries. Log entries written shortly before the delete operation might not be deleted.
         * @param {string} logName Required. The resource name of the log to delete: \&quot;projects/[PROJECT_ID]/logs/[LOG_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/logs/[LOG_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]\&quot; \&quot;folders/[FOLDER_ID]/logs/[LOG_ID]\&quot; [LOG_ID] must be URL-encoded. For example, \&quot;projects/my-project-id/logs/syslog\&quot;, \&quot;organizations/1234567890/logs/cloudresourcemanager.googleapis.com%2Factivity\&quot;. For more information about log names, see LogEntry.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsLogsDelete(logName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            const localVarFetchArgs = exports.OrganizationsApiFetchParamCreator(configuration).loggingOrganizationsLogsDelete(logName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists the logs in projects, organizations, folders, or billing accounts. Only logs that have entries are listed.
         * @param {string} parent Required. The resource name that owns the logs: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsLogsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
            const localVarFetchArgs = exports.OrganizationsApiFetchParamCreator(configuration).loggingOrganizationsLogsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a sink that exports specified log entries to a destination. The export of newly-ingested log entries begins immediately, unless the sink's writer_identity is not permitted to write to the destination. A sink can export log entries only from the resource owning the sink.
         * @param {string} parent Required. The resource in which to create the sink: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot; Examples: \&quot;projects/my-logging-project\&quot;, \&quot;organizations/123456789\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogSink} [body]
         * @param {boolean} [uniqueWriterIdentity] Optional. Determines the kind of IAM identity returned as writer_identity in the new sink. If this value is omitted or set to false, and if the sink&#39;s parent is a project, then the value returned as writer_identity is the same group or service account used by Logging before the addition of writer identities to this API. The sink&#39;s destination must be in the same project as the sink itself.If this field is set to true, or if the sink is owned by a non-project resource such as an organization, then the value of writer_identity will be a unique service account used only for exports from the new sink. For more information, see writer_identity in LogSink.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, options) {
            const localVarFetchArgs = exports.OrganizationsApiFetchParamCreator(configuration).loggingOrganizationsSinksCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a sink. If the sink has a unique writer_identity, then that service account is also deleted.
         * @param {string} sinkName Required. The full resource name of the sink to delete, including the parent resource and the sink identifier: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksDelete(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            const localVarFetchArgs = exports.OrganizationsApiFetchParamCreator(configuration).loggingOrganizationsSinksDelete(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a sink.
         * @param {string} sinkName Required. The resource name of the sink: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksGet(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            const localVarFetchArgs = exports.OrganizationsApiFetchParamCreator(configuration).loggingOrganizationsSinksGet(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists sinks.
         * @param {string} parent Required. The parent resource whose sinks are to be listed: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
            const localVarFetchArgs = exports.OrganizationsApiFetchParamCreator(configuration).loggingOrganizationsSinksList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a sink. This method replaces the following fields in the existing sink with values from the new sink: destination, and filter.The updated sink might also have a new writer_identity; see the unique_writer_identity field.
         * @param {string} sinkName Required. The full resource name of the sink to update, including the parent resource and the sink identifier: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogSink} [body]
         * @param {boolean} [uniqueWriterIdentity] Optional. See sinks.create for a description of this field. When updating a sink, the effect of this field on the value of writer_identity in the updated sink depends on both the old and new values of this field: If the old and new values of this field are both false or both true, then there is no change to the sink&#39;s writer_identity. If the old value is false and the new value is true, then writer_identity is changed to a unique service account. It is an error if the old value is true and the new value is set to false or defaulted to false.
         * @param {string} [updateMask] Optional. Field mask that specifies the fields in sink that need an update. A sink field will be overwritten if, and only if, it is in the update mask. name and output only fields cannot be updated.An empty updateMask is temporarily treated as using the following mask for backwards compatibility purposes:  destination,filter,includeChildren At some point in the future, behavior will be removed and specifying an empty updateMask will be an error.For a detailed FieldMask definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMaskExample: updateMask&#x3D;filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksPatch(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options) {
            const localVarFetchArgs = exports.OrganizationsApiFetchParamCreator(configuration).loggingOrganizationsSinksPatch(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a sink. This method replaces the following fields in the existing sink with values from the new sink: destination, and filter.The updated sink might also have a new writer_identity; see the unique_writer_identity field.
         * @param {string} sinkName Required. The full resource name of the sink to update, including the parent resource and the sink identifier: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogSink} [body]
         * @param {boolean} [uniqueWriterIdentity] Optional. See sinks.create for a description of this field. When updating a sink, the effect of this field on the value of writer_identity in the updated sink depends on both the old and new values of this field: If the old and new values of this field are both false or both true, then there is no change to the sink&#39;s writer_identity. If the old value is false and the new value is true, then writer_identity is changed to a unique service account. It is an error if the old value is true and the new value is set to false or defaulted to false.
         * @param {string} [updateMask] Optional. Field mask that specifies the fields in sink that need an update. A sink field will be overwritten if, and only if, it is in the update mask. name and output only fields cannot be updated.An empty updateMask is temporarily treated as using the following mask for backwards compatibility purposes:  destination,filter,includeChildren At some point in the future, behavior will be removed and specifying an empty updateMask will be an error.For a detailed FieldMask definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMaskExample: updateMask&#x3D;filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksUpdate(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options) {
            const localVarFetchArgs = exports.OrganizationsApiFetchParamCreator(configuration).loggingOrganizationsSinksUpdate(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        }
    };
};
exports.OrganizationsApiFp = OrganizationsApiFp;
/**
 * OrganizationsApi - factory interface
 * @export
 */
const OrganizationsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates a new exclusion in a specified parent resource. Only log entries belonging to that resource can be excluded. You can have up to 10 exclusions in a resource.
         * @param {string} parent Required. The parent resource in which to create the exclusion: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot; Examples: \&quot;projects/my-logging-project\&quot;, \&quot;organizations/123456789\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogExclusion} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            return exports.OrganizationsApiFp(configuration).loggingOrganizationsExclusionsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(fetch, basePath);
        },
        /**
         * Deletes an exclusion.
         * @param {string} name Required. The resource name of an existing exclusion to delete: \&quot;projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\&quot; Example: \&quot;projects/my-project-id/exclusions/my-exclusion-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsDelete(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            return exports.OrganizationsApiFp(configuration).loggingOrganizationsExclusionsDelete(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(fetch, basePath);
        },
        /**
         * Gets the description of an exclusion.
         * @param {string} name Required. The resource name of an existing exclusion: \&quot;projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\&quot; Example: \&quot;projects/my-project-id/exclusions/my-exclusion-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsGet(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            return exports.OrganizationsApiFp(configuration).loggingOrganizationsExclusionsGet(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(fetch, basePath);
        },
        /**
         * Lists all the exclusions in a parent resource.
         * @param {string} parent Required. The parent resource whose exclusions are to be listed. \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
            return exports.OrganizationsApiFp(configuration).loggingOrganizationsExclusionsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options)(fetch, basePath);
        },
        /**
         * Changes one or more properties of an existing exclusion.
         * @param {string} name Required. The resource name of the exclusion to update: \&quot;projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\&quot; Example: \&quot;projects/my-project-id/exclusions/my-exclusion-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogExclusion} [body]
         * @param {string} [updateMask] Required. A non-empty list of fields to change in the existing exclusion. New values for the fields are taken from the corresponding fields in the LogExclusion included in this request. Fields not mentioned in update_mask are not changed and are ignored in the request.For example, to change the filter and description of an exclusion, specify an update_mask of \&quot;filter,description\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsExclusionsPatch(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, updateMask, options) {
            return exports.OrganizationsApiFp(configuration).loggingOrganizationsExclusionsPatch(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, updateMask, options)(fetch, basePath);
        },
        /**
         * Deletes all the log entries in a log. The log reappears if it receives new entries. Log entries written shortly before the delete operation might not be deleted.
         * @param {string} logName Required. The resource name of the log to delete: \&quot;projects/[PROJECT_ID]/logs/[LOG_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/logs/[LOG_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]\&quot; \&quot;folders/[FOLDER_ID]/logs/[LOG_ID]\&quot; [LOG_ID] must be URL-encoded. For example, \&quot;projects/my-project-id/logs/syslog\&quot;, \&quot;organizations/1234567890/logs/cloudresourcemanager.googleapis.com%2Factivity\&quot;. For more information about log names, see LogEntry.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsLogsDelete(logName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            return exports.OrganizationsApiFp(configuration).loggingOrganizationsLogsDelete(logName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(fetch, basePath);
        },
        /**
         * Lists the logs in projects, organizations, folders, or billing accounts. Only logs that have entries are listed.
         * @param {string} parent Required. The resource name that owns the logs: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsLogsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
            return exports.OrganizationsApiFp(configuration).loggingOrganizationsLogsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options)(fetch, basePath);
        },
        /**
         * Creates a sink that exports specified log entries to a destination. The export of newly-ingested log entries begins immediately, unless the sink's writer_identity is not permitted to write to the destination. A sink can export log entries only from the resource owning the sink.
         * @param {string} parent Required. The resource in which to create the sink: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot; Examples: \&quot;projects/my-logging-project\&quot;, \&quot;organizations/123456789\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogSink} [body]
         * @param {boolean} [uniqueWriterIdentity] Optional. Determines the kind of IAM identity returned as writer_identity in the new sink. If this value is omitted or set to false, and if the sink&#39;s parent is a project, then the value returned as writer_identity is the same group or service account used by Logging before the addition of writer identities to this API. The sink&#39;s destination must be in the same project as the sink itself.If this field is set to true, or if the sink is owned by a non-project resource such as an organization, then the value of writer_identity will be a unique service account used only for exports from the new sink. For more information, see writer_identity in LogSink.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, options) {
            return exports.OrganizationsApiFp(configuration).loggingOrganizationsSinksCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, options)(fetch, basePath);
        },
        /**
         * Deletes a sink. If the sink has a unique writer_identity, then that service account is also deleted.
         * @param {string} sinkName Required. The full resource name of the sink to delete, including the parent resource and the sink identifier: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksDelete(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            return exports.OrganizationsApiFp(configuration).loggingOrganizationsSinksDelete(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(fetch, basePath);
        },
        /**
         * Gets a sink.
         * @param {string} sinkName Required. The resource name of the sink: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksGet(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            return exports.OrganizationsApiFp(configuration).loggingOrganizationsSinksGet(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(fetch, basePath);
        },
        /**
         * Lists sinks.
         * @param {string} parent Required. The parent resource whose sinks are to be listed: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
            return exports.OrganizationsApiFp(configuration).loggingOrganizationsSinksList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options)(fetch, basePath);
        },
        /**
         * Updates a sink. This method replaces the following fields in the existing sink with values from the new sink: destination, and filter.The updated sink might also have a new writer_identity; see the unique_writer_identity field.
         * @param {string} sinkName Required. The full resource name of the sink to update, including the parent resource and the sink identifier: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogSink} [body]
         * @param {boolean} [uniqueWriterIdentity] Optional. See sinks.create for a description of this field. When updating a sink, the effect of this field on the value of writer_identity in the updated sink depends on both the old and new values of this field: If the old and new values of this field are both false or both true, then there is no change to the sink&#39;s writer_identity. If the old value is false and the new value is true, then writer_identity is changed to a unique service account. It is an error if the old value is true and the new value is set to false or defaulted to false.
         * @param {string} [updateMask] Optional. Field mask that specifies the fields in sink that need an update. A sink field will be overwritten if, and only if, it is in the update mask. name and output only fields cannot be updated.An empty updateMask is temporarily treated as using the following mask for backwards compatibility purposes:  destination,filter,includeChildren At some point in the future, behavior will be removed and specifying an empty updateMask will be an error.For a detailed FieldMask definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMaskExample: updateMask&#x3D;filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksPatch(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options) {
            return exports.OrganizationsApiFp(configuration).loggingOrganizationsSinksPatch(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options)(fetch, basePath);
        },
        /**
         * Updates a sink. This method replaces the following fields in the existing sink with values from the new sink: destination, and filter.The updated sink might also have a new writer_identity; see the unique_writer_identity field.
         * @param {string} sinkName Required. The full resource name of the sink to update, including the parent resource and the sink identifier: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogSink} [body]
         * @param {boolean} [uniqueWriterIdentity] Optional. See sinks.create for a description of this field. When updating a sink, the effect of this field on the value of writer_identity in the updated sink depends on both the old and new values of this field: If the old and new values of this field are both false or both true, then there is no change to the sink&#39;s writer_identity. If the old value is false and the new value is true, then writer_identity is changed to a unique service account. It is an error if the old value is true and the new value is set to false or defaulted to false.
         * @param {string} [updateMask] Optional. Field mask that specifies the fields in sink that need an update. A sink field will be overwritten if, and only if, it is in the update mask. name and output only fields cannot be updated.An empty updateMask is temporarily treated as using the following mask for backwards compatibility purposes:  destination,filter,includeChildren At some point in the future, behavior will be removed and specifying an empty updateMask will be an error.For a detailed FieldMask definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMaskExample: updateMask&#x3D;filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingOrganizationsSinksUpdate(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options) {
            return exports.OrganizationsApiFp(configuration).loggingOrganizationsSinksUpdate(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options)(fetch, basePath);
        }
    };
};
exports.OrganizationsApiFactory = OrganizationsApiFactory;
/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
class OrganizationsApi extends BaseAPI {
    /**
     * Creates a new exclusion in a specified parent resource. Only log entries belonging to that resource can be excluded. You can have up to 10 exclusions in a resource.
     * @param {string} parent Required. The parent resource in which to create the exclusion: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot; Examples: \&quot;projects/my-logging-project\&quot;, \&quot;organizations/123456789\&quot;.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {LogExclusion} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    loggingOrganizationsExclusionsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
        return exports.OrganizationsApiFp(this.configuration).loggingOrganizationsExclusionsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(this.fetch, this.basePath);
    }
    /**
     * Deletes an exclusion.
     * @param {string} name Required. The resource name of an existing exclusion to delete: \&quot;projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\&quot; Example: \&quot;projects/my-project-id/exclusions/my-exclusion-id\&quot;.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    loggingOrganizationsExclusionsDelete(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
        return exports.OrganizationsApiFp(this.configuration).loggingOrganizationsExclusionsDelete(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(this.fetch, this.basePath);
    }
    /**
     * Gets the description of an exclusion.
     * @param {string} name Required. The resource name of an existing exclusion: \&quot;projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\&quot; Example: \&quot;projects/my-project-id/exclusions/my-exclusion-id\&quot;.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    loggingOrganizationsExclusionsGet(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
        return exports.OrganizationsApiFp(this.configuration).loggingOrganizationsExclusionsGet(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(this.fetch, this.basePath);
    }
    /**
     * Lists all the exclusions in a parent resource.
     * @param {string} parent Required. The parent resource whose exclusions are to be listed. \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot;
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
     * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    loggingOrganizationsExclusionsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
        return exports.OrganizationsApiFp(this.configuration).loggingOrganizationsExclusionsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options)(this.fetch, this.basePath);
    }
    /**
     * Changes one or more properties of an existing exclusion.
     * @param {string} name Required. The resource name of the exclusion to update: \&quot;projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\&quot; \&quot;folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\&quot; Example: \&quot;projects/my-project-id/exclusions/my-exclusion-id\&quot;.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {LogExclusion} [body]
     * @param {string} [updateMask] Required. A non-empty list of fields to change in the existing exclusion. New values for the fields are taken from the corresponding fields in the LogExclusion included in this request. Fields not mentioned in update_mask are not changed and are ignored in the request.For example, to change the filter and description of an exclusion, specify an update_mask of \&quot;filter,description\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    loggingOrganizationsExclusionsPatch(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, updateMask, options) {
        return exports.OrganizationsApiFp(this.configuration).loggingOrganizationsExclusionsPatch(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, updateMask, options)(this.fetch, this.basePath);
    }
    /**
     * Deletes all the log entries in a log. The log reappears if it receives new entries. Log entries written shortly before the delete operation might not be deleted.
     * @param {string} logName Required. The resource name of the log to delete: \&quot;projects/[PROJECT_ID]/logs/[LOG_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/logs/[LOG_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]\&quot; \&quot;folders/[FOLDER_ID]/logs/[LOG_ID]\&quot; [LOG_ID] must be URL-encoded. For example, \&quot;projects/my-project-id/logs/syslog\&quot;, \&quot;organizations/1234567890/logs/cloudresourcemanager.googleapis.com%2Factivity\&quot;. For more information about log names, see LogEntry.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    loggingOrganizationsLogsDelete(logName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
        return exports.OrganizationsApiFp(this.configuration).loggingOrganizationsLogsDelete(logName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(this.fetch, this.basePath);
    }
    /**
     * Lists the logs in projects, organizations, folders, or billing accounts. Only logs that have entries are listed.
     * @param {string} parent Required. The resource name that owns the logs: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot;
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
     * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    loggingOrganizationsLogsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
        return exports.OrganizationsApiFp(this.configuration).loggingOrganizationsLogsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options)(this.fetch, this.basePath);
    }
    /**
     * Creates a sink that exports specified log entries to a destination. The export of newly-ingested log entries begins immediately, unless the sink's writer_identity is not permitted to write to the destination. A sink can export log entries only from the resource owning the sink.
     * @param {string} parent Required. The resource in which to create the sink: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot; Examples: \&quot;projects/my-logging-project\&quot;, \&quot;organizations/123456789\&quot;.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {LogSink} [body]
     * @param {boolean} [uniqueWriterIdentity] Optional. Determines the kind of IAM identity returned as writer_identity in the new sink. If this value is omitted or set to false, and if the sink&#39;s parent is a project, then the value returned as writer_identity is the same group or service account used by Logging before the addition of writer identities to this API. The sink&#39;s destination must be in the same project as the sink itself.If this field is set to true, or if the sink is owned by a non-project resource such as an organization, then the value of writer_identity will be a unique service account used only for exports from the new sink. For more information, see writer_identity in LogSink.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    loggingOrganizationsSinksCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, options) {
        return exports.OrganizationsApiFp(this.configuration).loggingOrganizationsSinksCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, options)(this.fetch, this.basePath);
    }
    /**
     * Deletes a sink. If the sink has a unique writer_identity, then that service account is also deleted.
     * @param {string} sinkName Required. The full resource name of the sink to delete, including the parent resource and the sink identifier: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    loggingOrganizationsSinksDelete(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
        return exports.OrganizationsApiFp(this.configuration).loggingOrganizationsSinksDelete(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(this.fetch, this.basePath);
    }
    /**
     * Gets a sink.
     * @param {string} sinkName Required. The resource name of the sink: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    loggingOrganizationsSinksGet(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
        return exports.OrganizationsApiFp(this.configuration).loggingOrganizationsSinksGet(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(this.fetch, this.basePath);
    }
    /**
     * Lists sinks.
     * @param {string} parent Required. The parent resource whose sinks are to be listed: \&quot;projects/[PROJECT_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]\&quot; \&quot;folders/[FOLDER_ID]\&quot;
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
     * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    loggingOrganizationsSinksList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
        return exports.OrganizationsApiFp(this.configuration).loggingOrganizationsSinksList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options)(this.fetch, this.basePath);
    }
    /**
     * Updates a sink. This method replaces the following fields in the existing sink with values from the new sink: destination, and filter.The updated sink might also have a new writer_identity; see the unique_writer_identity field.
     * @param {string} sinkName Required. The full resource name of the sink to update, including the parent resource and the sink identifier: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {LogSink} [body]
     * @param {boolean} [uniqueWriterIdentity] Optional. See sinks.create for a description of this field. When updating a sink, the effect of this field on the value of writer_identity in the updated sink depends on both the old and new values of this field: If the old and new values of this field are both false or both true, then there is no change to the sink&#39;s writer_identity. If the old value is false and the new value is true, then writer_identity is changed to a unique service account. It is an error if the old value is true and the new value is set to false or defaulted to false.
     * @param {string} [updateMask] Optional. Field mask that specifies the fields in sink that need an update. A sink field will be overwritten if, and only if, it is in the update mask. name and output only fields cannot be updated.An empty updateMask is temporarily treated as using the following mask for backwards compatibility purposes:  destination,filter,includeChildren At some point in the future, behavior will be removed and specifying an empty updateMask will be an error.For a detailed FieldMask definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMaskExample: updateMask&#x3D;filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    loggingOrganizationsSinksPatch(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options) {
        return exports.OrganizationsApiFp(this.configuration).loggingOrganizationsSinksPatch(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options)(this.fetch, this.basePath);
    }
    /**
     * Updates a sink. This method replaces the following fields in the existing sink with values from the new sink: destination, and filter.The updated sink might also have a new writer_identity; see the unique_writer_identity field.
     * @param {string} sinkName Required. The full resource name of the sink to update, including the parent resource and the sink identifier: \&quot;projects/[PROJECT_ID]/sinks/[SINK_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\&quot; \&quot;folders/[FOLDER_ID]/sinks/[SINK_ID]\&quot; Example: \&quot;projects/my-project-id/sinks/my-sink-id\&quot;.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {LogSink} [body]
     * @param {boolean} [uniqueWriterIdentity] Optional. See sinks.create for a description of this field. When updating a sink, the effect of this field on the value of writer_identity in the updated sink depends on both the old and new values of this field: If the old and new values of this field are both false or both true, then there is no change to the sink&#39;s writer_identity. If the old value is false and the new value is true, then writer_identity is changed to a unique service account. It is an error if the old value is true and the new value is set to false or defaulted to false.
     * @param {string} [updateMask] Optional. Field mask that specifies the fields in sink that need an update. A sink field will be overwritten if, and only if, it is in the update mask. name and output only fields cannot be updated.An empty updateMask is temporarily treated as using the following mask for backwards compatibility purposes:  destination,filter,includeChildren At some point in the future, behavior will be removed and specifying an empty updateMask will be an error.For a detailed FieldMask definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMaskExample: updateMask&#x3D;filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    loggingOrganizationsSinksUpdate(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options) {
        return exports.OrganizationsApiFp(this.configuration).loggingOrganizationsSinksUpdate(sinkName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, uniqueWriterIdentity, updateMask, options)(this.fetch, this.basePath);
    }
}
exports.OrganizationsApi = OrganizationsApi;
/**
 * ProjectsApi - fetch parameter creator
 * @export
 */
const ProjectsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates a logs-based metric.
         * @param {string} parent The resource name of the project in which to create the metric: \&quot;projects/[PROJECT_ID]\&quot; The new metric must be provided in the request.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogMetric} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options = {}) {
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent', 'Required parameter parent was null or undefined when calling loggingProjectsMetricsCreate.');
            }
            const localVarPath = `/v2/{parent}/metrics`.replace(`{${'parent'}}`, encodeURIComponent(String(parent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.write'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.write'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Deletes a logs-based metric.
         * @param {string} metricName The resource name of the metric to delete: \&quot;projects/[PROJECT_ID]/metrics/[METRIC_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsDelete(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options = {}) {
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new RequiredError('metricName', 'Required parameter metricName was null or undefined when calling loggingProjectsMetricsDelete.');
            }
            const localVarPath = `/v2/{metricName}`.replace(`{${'metricName'}}`, encodeURIComponent(String(metricName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.write'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.write'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Gets a logs-based metric.
         * @param {string} metricName The resource name of the desired metric: \&quot;projects/[PROJECT_ID]/metrics/[METRIC_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsGet(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options = {}) {
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new RequiredError('metricName', 'Required parameter metricName was null or undefined when calling loggingProjectsMetricsGet.');
            }
            const localVarPath = `/v2/{metricName}`.replace(`{${'metricName'}}`, encodeURIComponent(String(metricName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Lists logs-based metrics.
         * @param {string} parent Required. The name of the project containing the metrics: \&quot;projects/[PROJECT_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options = {}) {
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent', 'Required parameter parent was null or undefined when calling loggingProjectsMetricsList.');
            }
            const localVarPath = `/v2/{parent}/metrics`.replace(`{${'parent'}}`, encodeURIComponent(String(parent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.read'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter.pageSize = pageSize;
            }
            if (pageToken !== undefined) {
                localVarQueryParameter.pageToken = pageToken;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Creates or updates a logs-based metric.
         * @param {string} metricName The resource name of the metric to update: \&quot;projects/[PROJECT_ID]/metrics/[METRIC_ID]\&quot; The updated metric must be provided in the request and it&#39;s name field must be the same as [METRIC_ID] If the metric does not exist in [PROJECT_ID], then a new metric is created.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogMetric} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsUpdate(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options = {}) {
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new RequiredError('metricName', 'Required parameter metricName was null or undefined when calling loggingProjectsMetricsUpdate.');
            }
            const localVarPath = `/v2/{metricName}`.replace(`{${'metricName'}}`, encodeURIComponent(String(metricName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/logging.write'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/logging.write'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization =
                    'Bearer ' + localVarAccessTokenValue;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
exports.ProjectsApiFetchParamCreator = ProjectsApiFetchParamCreator;
/**
 * ProjectsApi - functional programming interface
 * @export
 */
const ProjectsApiFp = function (configuration) {
    return {
        /**
         * Creates a logs-based metric.
         * @param {string} parent The resource name of the project in which to create the metric: \&quot;projects/[PROJECT_ID]\&quot; The new metric must be provided in the request.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogMetric} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            const localVarFetchArgs = exports.ProjectsApiFetchParamCreator(configuration).loggingProjectsMetricsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a logs-based metric.
         * @param {string} metricName The resource name of the metric to delete: \&quot;projects/[PROJECT_ID]/metrics/[METRIC_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsDelete(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            const localVarFetchArgs = exports.ProjectsApiFetchParamCreator(configuration).loggingProjectsMetricsDelete(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a logs-based metric.
         * @param {string} metricName The resource name of the desired metric: \&quot;projects/[PROJECT_ID]/metrics/[METRIC_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsGet(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            const localVarFetchArgs = exports.ProjectsApiFetchParamCreator(configuration).loggingProjectsMetricsGet(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists logs-based metrics.
         * @param {string} parent Required. The name of the project containing the metrics: \&quot;projects/[PROJECT_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
            const localVarFetchArgs = exports.ProjectsApiFetchParamCreator(configuration).loggingProjectsMetricsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates or updates a logs-based metric.
         * @param {string} metricName The resource name of the metric to update: \&quot;projects/[PROJECT_ID]/metrics/[METRIC_ID]\&quot; The updated metric must be provided in the request and it&#39;s name field must be the same as [METRIC_ID] If the metric does not exist in [PROJECT_ID], then a new metric is created.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogMetric} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsUpdate(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            const localVarFetchArgs = exports.ProjectsApiFetchParamCreator(configuration).loggingProjectsMetricsUpdate(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        }
    };
};
exports.ProjectsApiFp = ProjectsApiFp;
/**
 * ProjectsApi - factory interface
 * @export
 */
const ProjectsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates a logs-based metric.
         * @param {string} parent The resource name of the project in which to create the metric: \&quot;projects/[PROJECT_ID]\&quot; The new metric must be provided in the request.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogMetric} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            return exports.ProjectsApiFp(configuration).loggingProjectsMetricsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(fetch, basePath);
        },
        /**
         * Deletes a logs-based metric.
         * @param {string} metricName The resource name of the metric to delete: \&quot;projects/[PROJECT_ID]/metrics/[METRIC_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsDelete(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            return exports.ProjectsApiFp(configuration).loggingProjectsMetricsDelete(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(fetch, basePath);
        },
        /**
         * Gets a logs-based metric.
         * @param {string} metricName The resource name of the desired metric: \&quot;projects/[PROJECT_ID]/metrics/[METRIC_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsGet(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            return exports.ProjectsApiFp(configuration).loggingProjectsMetricsGet(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(fetch, basePath);
        },
        /**
         * Lists logs-based metrics.
         * @param {string} parent Required. The name of the project containing the metrics: \&quot;projects/[PROJECT_ID]\&quot;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
         * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
            return exports.ProjectsApiFp(configuration).loggingProjectsMetricsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options)(fetch, basePath);
        },
        /**
         * Creates or updates a logs-based metric.
         * @param {string} metricName The resource name of the metric to update: \&quot;projects/[PROJECT_ID]/metrics/[METRIC_ID]\&quot; The updated metric must be provided in the request and it&#39;s name field must be the same as [METRIC_ID] If the metric does not exist in [PROJECT_ID], then a new metric is created.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {LogMetric} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loggingProjectsMetricsUpdate(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            return exports.ProjectsApiFp(configuration).loggingProjectsMetricsUpdate(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(fetch, basePath);
        }
    };
};
exports.ProjectsApiFactory = ProjectsApiFactory;
/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
class ProjectsApi extends BaseAPI {
    /**
     * Creates a logs-based metric.
     * @param {string} parent The resource name of the project in which to create the metric: \&quot;projects/[PROJECT_ID]\&quot; The new metric must be provided in the request.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {LogMetric} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    loggingProjectsMetricsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
        return exports.ProjectsApiFp(this.configuration).loggingProjectsMetricsCreate(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(this.fetch, this.basePath);
    }
    /**
     * Deletes a logs-based metric.
     * @param {string} metricName The resource name of the metric to delete: \&quot;projects/[PROJECT_ID]/metrics/[METRIC_ID]\&quot;
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    loggingProjectsMetricsDelete(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
        return exports.ProjectsApiFp(this.configuration).loggingProjectsMetricsDelete(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(this.fetch, this.basePath);
    }
    /**
     * Gets a logs-based metric.
     * @param {string} metricName The resource name of the desired metric: \&quot;projects/[PROJECT_ID]/metrics/[METRIC_ID]\&quot;
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    loggingProjectsMetricsGet(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
        return exports.ProjectsApiFp(this.configuration).loggingProjectsMetricsGet(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(this.fetch, this.basePath);
    }
    /**
     * Lists logs-based metrics.
     * @param {string} parent Required. The name of the project containing the metrics: \&quot;projects/[PROJECT_ID]\&quot;
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {number} [pageSize] Optional. The maximum number of results to return from this request. Non-positive values are ignored. The presence of nextPageToken in the response indicates that more results might be available.
     * @param {string} [pageToken] Optional. If present, then retrieve the next batch of results from the preceding call to this method. pageToken must be the value of nextPageToken from the previous response. The values of other method parameters should be identical to those in the previous call.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    loggingProjectsMetricsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options) {
        return exports.ProjectsApiFp(this.configuration).loggingProjectsMetricsList(parent, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, pageSize, pageToken, options)(this.fetch, this.basePath);
    }
    /**
     * Creates or updates a logs-based metric.
     * @param {string} metricName The resource name of the metric to update: \&quot;projects/[PROJECT_ID]/metrics/[METRIC_ID]\&quot; The updated metric must be provided in the request and it&#39;s name field must be the same as [METRIC_ID] If the metric does not exist in [PROJECT_ID], then a new metric is created.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {LogMetric} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    loggingProjectsMetricsUpdate(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
        return exports.ProjectsApiFp(this.configuration).loggingProjectsMetricsUpdate(metricName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(this.fetch, this.basePath);
    }
}
exports.ProjectsApi = ProjectsApi;
//# sourceMappingURL=api.js.map

/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Headers", function() { return Headers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Response", function() { return Response; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMException", function() { return DOMException; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetch", function() { return fetch; });
var global =
  (typeof globalThis !== 'undefined' && globalThis) ||
  (typeof self !== 'undefined' && self) ||
  (typeof global !== 'undefined' && global)

var support = {
  searchParams: 'URLSearchParams' in global,
  iterable: 'Symbol' in global && 'iterator' in Symbol,
  blob:
    'FileReader' in global &&
    'Blob' in global &&
    (function() {
      try {
        new Blob()
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in global,
  arrayBuffer: 'ArrayBuffer' in global
}

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ]

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name)
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value)
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift()
      return {done: value === undefined, value: value}
    }
  }

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    }
  }

  return iterator
}

function Headers(headers) {
  this.map = {}

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value)
    }, this)
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1])
    }, this)
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name])
    }, this)
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name)
  value = normalizeValue(value)
  var oldValue = this.map[name]
  this.map[name] = oldValue ? oldValue + ', ' + value : value
}

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)]
}

Headers.prototype.get = function(name) {
  name = normalizeName(name)
  return this.has(name) ? this.map[name] : null
}

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
}

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value)
}

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this)
    }
  }
}

Headers.prototype.keys = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push(name)
  })
  return iteratorFor(items)
}

Headers.prototype.values = function() {
  var items = []
  this.forEach(function(value) {
    items.push(value)
  })
  return iteratorFor(items)
}

Headers.prototype.entries = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push([name, value])
  })
  return iteratorFor(items)
}

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result)
    }
    reader.onerror = function() {
      reject(reader.error)
    }
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsArrayBuffer(blob)
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsText(blob)
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf)
  var chars = new Array(view.length)

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i])
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength)
    view.set(new Uint8Array(buf))
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false

  this._initBody = function(body) {
    /*
      fetch-mock wraps the Response object in an ES6 Proxy to
      provide useful test harness features such as flush. However, on
      ES5 browsers without fetch or Proxy support pollyfills must be used;
      the proxy-pollyfill is unable to proxy an attribute unless it exists
      on the object before the Proxy is created. This change ensures
      Response.bodyUsed exists on the instance, while maintaining the
      semantic of setting Request.bodyUsed in the constructor before
      _initBody is called.
    */
    this.bodyUsed = this.bodyUsed
    this._bodyInit = body
    if (!body) {
      this._bodyText = ''
    } else if (typeof body === 'string') {
      this._bodyText = body
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString()
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer)
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer])
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body)
    } else {
      this._bodyText = body = Object.prototype.toString.call(body)
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8')
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type)
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
      }
    }
  }

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    }

    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        var isConsumed = consumed(this)
        if (isConsumed) {
          return isConsumed
        }
        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
          return Promise.resolve(
            this._bodyArrayBuffer.buffer.slice(
              this._bodyArrayBuffer.byteOffset,
              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
            )
          )
        } else {
          return Promise.resolve(this._bodyArrayBuffer)
        }
      } else {
        return this.blob().then(readBlobAsArrayBuffer)
      }
    }
  }

  this.text = function() {
    var rejected = consumed(this)
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  }

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode)
    }
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  }

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

function normalizeMethod(method) {
  var upcased = method.toUpperCase()
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }

  options = options || {}
  var body = options.body

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url
    this.credentials = input.credentials
    if (!options.headers) {
      this.headers = new Headers(input.headers)
    }
    this.method = input.method
    this.mode = input.mode
    this.signal = input.signal
    if (!body && input._bodyInit != null) {
      body = input._bodyInit
      input.bodyUsed = true
    }
  } else {
    this.url = String(input)
  }

  this.credentials = options.credentials || this.credentials || 'same-origin'
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers)
  }
  this.method = normalizeMethod(options.method || this.method || 'GET')
  this.mode = options.mode || this.mode || null
  this.signal = options.signal || this.signal
  this.referrer = null

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body)

  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      // Search for a '_' parameter in the query string
      var reParamSearch = /([?&])_=[^&]*/
      if (reParamSearch.test(this.url)) {
        // If it already exists then set the value with the current time
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())
      } else {
        // Otherwise add a new '_' parameter to the end with the current time
        var reQueryString = /\?/
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()
      }
    }
  }
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
}

function decode(body) {
  var form = new FormData()
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers()
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
  // https://github.com/github/fetch/issues/748
  // https://github.com/zloirock/core-js/issues/751
  preProcessedHeaders
    .split('\r')
    .map(function(header) {
      return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
    })
    .forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
  return headers
}

Body.call(Request.prototype)

function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }
  if (!options) {
    options = {}
  }

  this.type = 'default'
  this.status = options.status === undefined ? 200 : options.status
  this.ok = this.status >= 200 && this.status < 300
  this.statusText = 'statusText' in options ? options.statusText : ''
  this.headers = new Headers(options.headers)
  this.url = options.url || ''
  this._initBody(bodyInit)
}

Body.call(Response.prototype)

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
}

Response.error = function() {
  var response = new Response(null, {status: 0, statusText: ''})
  response.type = 'error'
  return response
}

var redirectStatuses = [301, 302, 303, 307, 308]

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
}

var DOMException = global.DOMException
try {
  new DOMException()
} catch (err) {
  DOMException = function(message, name) {
    this.message = message
    this.name = name
    var error = Error(message)
    this.stack = error.stack
  }
  DOMException.prototype = Object.create(Error.prototype)
  DOMException.prototype.constructor = DOMException
}

function fetch(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init)

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest()

    function abortXhr() {
      xhr.abort()
    }

    xhr.onload = function() {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
      var body = 'response' in xhr ? xhr.response : xhr.responseText
      setTimeout(function() {
        resolve(new Response(body, options))
      }, 0)
    }

    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'))
      }, 0)
    }

    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'))
      }, 0)
    }

    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException('Aborted', 'AbortError'))
      }, 0)
    }

    function fixUrl(url) {
      try {
        return url === '' && global.location.href ? global.location.href : url
      } catch (e) {
        return url
      }
    }

    xhr.open(request.method, fixUrl(request.url), true)

    if (request.credentials === 'include') {
      xhr.withCredentials = true
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false
    }

    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob'
      } else if (
        support.arrayBuffer &&
        request.headers.get('Content-Type') &&
        request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
      ) {
        xhr.responseType = 'arraybuffer'
      }
    }

    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))
      })
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })
    }

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr)

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr)
        }
      }
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
  })
}

fetch.polyfill = true

if (!global.fetch) {
  global.fetch = fetch
  global.Headers = Headers
  global.Request = Request
  global.Response = Response
}


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable
/**
 * Stackdriver Logging
 * Writes log entries and manages your Stackdriver Logging configuration. The table entries below are presented in alphabetical order, not in order of common use. For explanations of the concepts found in the table entries, read the Stackdriver Logging documentation.
 *
 * OpenAPI spec version: v2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Configuration = void 0;
class Configuration {
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
    }
}
exports.Configuration = Configuration;
//# sourceMappingURL=configuration.js.map

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable
/**
 * Stackdriver Error Reporting
 * Groups and counts similar errors from cloud services and applications, reports new errors, and provides access to error groups and their associated errors.
 *
 * OpenAPI spec version: v1beta1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(223), exports);
__exportStar(__webpack_require__(224), exports);
//# sourceMappingURL=index.js.map

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable @typescript-eslint/camelcase */
// / <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Stackdriver Error Reporting
 * Groups and counts similar errors from cloud services and applications, reports new errors, and provides access to error groups and their associated errors.
 *
 * OpenAPI spec version: v1beta1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectsApi = exports.ProjectsApiFactory = exports.ProjectsApiFp = exports.ProjectsApiFetchParamCreator = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = void 0;
const url = __webpack_require__(12);
const portableFetch = __webpack_require__(41);
const BASE_PATH = 'https://clouderrorreporting.googleapis.com'.replace(/\/+$/, '');
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|'
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, fetch = portableFetch) {
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
exports.RequiredError = RequiredError;
/**
 * ProjectsApi - fetch parameter creator
 * @export
 */
const ProjectsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Deletes all error events of a given project.
         * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &#x60;projects/&#x60; plus the [Google Cloud Platform project ID](https://support.google.com/cloud/answer/6158840). Example: &#x60;projects/my-project-123&#x60;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsDeleteEvents(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options = {}) {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling clouderrorreportingProjectsDeleteEvents.');
            }
            const localVarPath = `/v1beta1/{projectName}/events`.replace(`{${'projectName'}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = {
                method: 'DELETE',
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/cloud-platform'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization = `Bearer ${localVarAccessTokenValue}`;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/cloud-platform'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization = `Bearer ${localVarAccessTokenValue}`;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarUrlObj.query = {
                ...localVarUrlObj.query,
                ...localVarQueryParameter,
                ...options.query
            };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...options.headers
            };
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Lists the specified events.
         * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &#x60;projects/&#x60; plus the [Google Cloud Platform project ID](https://support.google.com/cloud/answer/6158840). Example: &#x60;projects/my-project-123&#x60;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {string} [groupId] [Required] The group for which events shall be returned.
         * @param {number} [pageSize] [Optional] The maximum number of results to return per response.
         * @param {string} [pageToken] [Optional] A &#x60;next_page_token&#x60; provided by a previous response.
         * @param {string} [serviceFilter_resourceType] [Optional] The exact value to match against [&#x60;ServiceContext.resource_type&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.resource_type).
         * @param {string} [serviceFilter_service] [Optional] The exact value to match against [&#x60;ServiceContext.service&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.service).
         * @param {string} [serviceFilter_version] [Optional] The exact value to match against [&#x60;ServiceContext.version&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.version).
         * @param {'PERIOD_UNSPECIFIED' | 'PERIOD_1_HOUR' | 'PERIOD_6_HOURS' | 'PERIOD_1_DAY' | 'PERIOD_1_WEEK' | 'PERIOD_30_DAYS'} [timeRange_period] Restricts the query to the specified time range.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsEventsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, groupId, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, options = {}) {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling clouderrorreportingProjectsEventsList.');
            }
            const localVarPath = `/v1beta1/{projectName}/events`.replace(`{${'projectName'}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/cloud-platform'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization = `Bearer ${localVarAccessTokenValue}`;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/cloud-platform'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization = `Bearer ${localVarAccessTokenValue}`;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            if (groupId !== undefined) {
                localVarQueryParameter.groupId = groupId;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter.pageSize = pageSize;
            }
            if (pageToken !== undefined) {
                localVarQueryParameter.pageToken = pageToken;
            }
            if (serviceFilter_resourceType !== undefined) {
                localVarQueryParameter['serviceFilter.resourceType'] = serviceFilter_resourceType;
            }
            if (serviceFilter_service !== undefined) {
                localVarQueryParameter['serviceFilter.service'] = serviceFilter_service;
            }
            if (serviceFilter_version !== undefined) {
                localVarQueryParameter['serviceFilter.version'] = serviceFilter_version;
            }
            if (timeRange_period !== undefined) {
                localVarQueryParameter['timeRange.period'] = timeRange_period;
            }
            localVarUrlObj.query = {
                ...localVarUrlObj.query,
                ...localVarQueryParameter,
                ...options.query
            };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...options.headers
            };
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Report an individual error event.  This endpoint accepts **either** an OAuth token, **or** an [API key](https://support.google.com/cloud/answer/6158862) for authentication. To use an API key, append it to the URL as the value of a `key` parameter. For example:  `POST https://clouderrorreporting.googleapis.com/v1beta1/projects/example-project/events:report?key=123ABC456`
         * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &#x60;projects/&#x60; plus the [Google Cloud Platform project ID](https://support.google.com/cloud/answer/6158840). Example: &#x60;projects/my-project-123&#x60;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {ReportedErrorEvent} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsEventsReport(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options = {}) {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling clouderrorreportingProjectsEventsReport.');
            }
            const localVarPath = `/v1beta1/{projectName}/events:report`.replace(`{${'projectName'}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/cloud-platform'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization = `Bearer ${localVarAccessTokenValue}`;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/cloud-platform'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization = `Bearer ${localVarAccessTokenValue}`;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = {
                ...localVarUrlObj.query,
                ...localVarQueryParameter,
                ...options.query
            };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...options.headers
            };
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Lists the specified groups.
         * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &lt;code&gt;projects/&lt;/code&gt; plus the &lt;a href&#x3D;\&quot;https://support.google.com/cloud/answer/6158840\&quot;&gt;Google Cloud Platform project ID&lt;/a&gt;.  Example: &lt;code&gt;projects/my-project-123&lt;/code&gt;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {'ERROR_COUNT_ALIGNMENT_UNSPECIFIED' | 'ALIGNMENT_EQUAL_ROUNDED' | 'ALIGNMENT_EQUAL_AT_END'} [alignment] [Optional] The alignment of the timed counts to be returned. Default is &#x60;ALIGNMENT_EQUAL_AT_END&#x60;.
         * @param {string} [alignmentTime] [Optional] Time where the timed counts shall be aligned if rounded alignment is chosen. Default is 00:00 UTC.
         * @param {Array<string>} [groupId] [Optional] List all &lt;code&gt;ErrorGroupStats&lt;/code&gt; with these IDs.
         * @param {'GROUP_ORDER_UNSPECIFIED' | 'COUNT_DESC' | 'LAST_SEEN_DESC' | 'CREATED_DESC' | 'AFFECTED_USERS_DESC'} [order] [Optional] The sort order in which the results are returned. Default is &#x60;COUNT_DESC&#x60;.
         * @param {number} [pageSize] [Optional] The maximum number of results to return per response. Default is 20.
         * @param {string} [pageToken] [Optional] A &#x60;next_page_token&#x60; provided by a previous response. To view additional results, pass this token along with the identical query parameters as the first request.
         * @param {string} [serviceFilter_resourceType] [Optional] The exact value to match against [&#x60;ServiceContext.resource_type&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.resource_type).
         * @param {string} [serviceFilter_service] [Optional] The exact value to match against [&#x60;ServiceContext.service&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.service).
         * @param {string} [serviceFilter_version] [Optional] The exact value to match against [&#x60;ServiceContext.version&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.version).
         * @param {'PERIOD_UNSPECIFIED' | 'PERIOD_1_HOUR' | 'PERIOD_6_HOURS' | 'PERIOD_1_DAY' | 'PERIOD_1_WEEK' | 'PERIOD_30_DAYS'} [timeRange_period] Restricts the query to the specified time range.
         * @param {string} [timedCountDuration] [Optional] The preferred duration for a single returned &#x60;TimedCount&#x60;. If not set, no timed counts are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsGroupStatsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, alignment, alignmentTime, groupId, order, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, timedCountDuration, options = {}) {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling clouderrorreportingProjectsGroupStatsList.');
            }
            const localVarPath = `/v1beta1/{projectName}/groupStats`.replace(`{${'projectName'}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/cloud-platform'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization = `Bearer ${localVarAccessTokenValue}`;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/cloud-platform'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization = `Bearer ${localVarAccessTokenValue}`;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            if (alignment !== undefined) {
                localVarQueryParameter.alignment = alignment;
            }
            if (alignmentTime !== undefined) {
                localVarQueryParameter.alignmentTime = alignmentTime;
            }
            if (groupId) {
                localVarQueryParameter.groupId = groupId;
            }
            if (order !== undefined) {
                localVarQueryParameter.order = order;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter.pageSize = pageSize;
            }
            if (pageToken !== undefined) {
                localVarQueryParameter.pageToken = pageToken;
            }
            if (serviceFilter_resourceType !== undefined) {
                localVarQueryParameter['serviceFilter.resourceType'] = serviceFilter_resourceType;
            }
            if (serviceFilter_service !== undefined) {
                localVarQueryParameter['serviceFilter.service'] = serviceFilter_service;
            }
            if (serviceFilter_version !== undefined) {
                localVarQueryParameter['serviceFilter.version'] = serviceFilter_version;
            }
            if (timeRange_period !== undefined) {
                localVarQueryParameter['timeRange.period'] = timeRange_period;
            }
            if (timedCountDuration !== undefined) {
                localVarQueryParameter.timedCountDuration = timedCountDuration;
            }
            localVarUrlObj.query = {
                ...localVarUrlObj.query,
                ...localVarQueryParameter,
                ...options.query
            };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...options.headers
            };
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Get the specified group.
         * @param {string} packName [Required] The group resource name. Written as &lt;code&gt;projects/&lt;var&gt;projectID&lt;/var&gt;/groups/&lt;var&gt;group_name&lt;/var&gt;&lt;/code&gt;. Call &lt;a href&#x3D;\&quot;/error-reporting/reference/rest/v1beta1/projects.groupStats/list\&quot;&gt; &lt;code&gt;groupStats.list&lt;/code&gt;&lt;/a&gt; to return a list of groups belonging to this project.  Example: &lt;code&gt;projects/my-project-123/groups/my-group&lt;/code&gt;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsGroupsGet(packName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options = {}) {
            // verify required parameter 'packName' is not null or undefined
            if (packName === null || packName === undefined) {
                throw new RequiredError('packName', 'Required parameter packName was null or undefined when calling clouderrorreportingProjectsGroupsGet.');
            }
            const localVarPath = `/v1beta1/{packName}`.replace(`{${'packName'}}`, encodeURIComponent(String(packName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/cloud-platform'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization = `Bearer ${localVarAccessTokenValue}`;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/cloud-platform'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization = `Bearer ${localVarAccessTokenValue}`;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarUrlObj.query = {
                ...localVarUrlObj.query,
                ...localVarQueryParameter,
                ...options.query
            };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...options.headers
            };
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Replace the data for the specified group. Fails if the group does not exist.
         * @param {string} name The group resource name. Example: &lt;code&gt;projects/my-project-123/groups/my-groupid&lt;/code&gt;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {ErrorGroup} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsGroupsUpdate(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options = {}) {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling clouderrorreportingProjectsGroupsUpdate.');
            }
            const localVarPath = `/v1beta1/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = { method: 'PUT', ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2', [
                        'https://www.googleapis.com/auth/cloud-platform'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization = `Bearer ${localVarAccessTokenValue}`;
            }
            // authentication Oauth2c required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken('Oauth2c', [
                        'https://www.googleapis.com/auth/cloud-platform'
                    ])
                    : configuration.accessToken;
                localVarHeaderParameter.Authorization = `Bearer ${localVarAccessTokenValue}`;
            }
            if (_xgafv !== undefined) {
                localVarQueryParameter['$.xgafv'] = _xgafv;
            }
            if (access_token !== undefined) {
                localVarQueryParameter.access_token = access_token;
            }
            if (alt !== undefined) {
                localVarQueryParameter.alt = alt;
            }
            if (callback !== undefined) {
                localVarQueryParameter.callback = callback;
            }
            if (fields !== undefined) {
                localVarQueryParameter.fields = fields;
            }
            if (key !== undefined) {
                localVarQueryParameter.key = key;
            }
            if (oauth_token !== undefined) {
                localVarQueryParameter.oauth_token = oauth_token;
            }
            if (prettyPrint !== undefined) {
                localVarQueryParameter.prettyPrint = prettyPrint;
            }
            if (quotaUser !== undefined) {
                localVarQueryParameter.quotaUser = quotaUser;
            }
            if (uploadType !== undefined) {
                localVarQueryParameter.uploadType = uploadType;
            }
            if (upload_protocol !== undefined) {
                localVarQueryParameter.upload_protocol = upload_protocol;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = {
                ...localVarUrlObj.query,
                ...localVarQueryParameter,
                ...options.query
            };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...options.headers
            };
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
exports.ProjectsApiFetchParamCreator = ProjectsApiFetchParamCreator;
/**
 * ProjectsApi - functional programming interface
 * @export
 */
const ProjectsApiFp = function (configuration) {
    return {
        /**
         * Deletes all error events of a given project.
         * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &#x60;projects/&#x60; plus the [Google Cloud Platform project ID](https://support.google.com/cloud/answer/6158840). Example: &#x60;projects/my-project-123&#x60;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsDeleteEvents(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            const localVarFetchArgs = exports.ProjectsApiFetchParamCreator(configuration).clouderrorreportingProjectsDeleteEvents(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    throw response;
                });
            };
        },
        /**
         * Lists the specified events.
         * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &#x60;projects/&#x60; plus the [Google Cloud Platform project ID](https://support.google.com/cloud/answer/6158840). Example: &#x60;projects/my-project-123&#x60;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {string} [groupId] [Required] The group for which events shall be returned.
         * @param {number} [pageSize] [Optional] The maximum number of results to return per response.
         * @param {string} [pageToken] [Optional] A &#x60;next_page_token&#x60; provided by a previous response.
         * @param {string} [serviceFilter_resourceType] [Optional] The exact value to match against [&#x60;ServiceContext.resource_type&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.resource_type).
         * @param {string} [serviceFilter_service] [Optional] The exact value to match against [&#x60;ServiceContext.service&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.service).
         * @param {string} [serviceFilter_version] [Optional] The exact value to match against [&#x60;ServiceContext.version&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.version).
         * @param {'PERIOD_UNSPECIFIED' | 'PERIOD_1_HOUR' | 'PERIOD_6_HOURS' | 'PERIOD_1_DAY' | 'PERIOD_1_WEEK' | 'PERIOD_30_DAYS'} [timeRange_period] Restricts the query to the specified time range.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsEventsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, groupId, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, options) {
            const localVarFetchArgs = exports.ProjectsApiFetchParamCreator(configuration).clouderrorreportingProjectsEventsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, groupId, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    throw response;
                });
            };
        },
        /**
         * Report an individual error event.  This endpoint accepts **either** an OAuth token, **or** an [API key](https://support.google.com/cloud/answer/6158862) for authentication. To use an API key, append it to the URL as the value of a `key` parameter. For example:  `POST https://clouderrorreporting.googleapis.com/v1beta1/projects/example-project/events:report?key=123ABC456`
         * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &#x60;projects/&#x60; plus the [Google Cloud Platform project ID](https://support.google.com/cloud/answer/6158840). Example: &#x60;projects/my-project-123&#x60;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {ReportedErrorEvent} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsEventsReport(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            const localVarFetchArgs = exports.ProjectsApiFetchParamCreator(configuration).clouderrorreportingProjectsEventsReport(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    throw response;
                });
            };
        },
        /**
         * Lists the specified groups.
         * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &lt;code&gt;projects/&lt;/code&gt; plus the &lt;a href&#x3D;\&quot;https://support.google.com/cloud/answer/6158840\&quot;&gt;Google Cloud Platform project ID&lt;/a&gt;.  Example: &lt;code&gt;projects/my-project-123&lt;/code&gt;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {'ERROR_COUNT_ALIGNMENT_UNSPECIFIED' | 'ALIGNMENT_EQUAL_ROUNDED' | 'ALIGNMENT_EQUAL_AT_END'} [alignment] [Optional] The alignment of the timed counts to be returned. Default is &#x60;ALIGNMENT_EQUAL_AT_END&#x60;.
         * @param {string} [alignmentTime] [Optional] Time where the timed counts shall be aligned if rounded alignment is chosen. Default is 00:00 UTC.
         * @param {Array<string>} [groupId] [Optional] List all &lt;code&gt;ErrorGroupStats&lt;/code&gt; with these IDs.
         * @param {'GROUP_ORDER_UNSPECIFIED' | 'COUNT_DESC' | 'LAST_SEEN_DESC' | 'CREATED_DESC' | 'AFFECTED_USERS_DESC'} [order] [Optional] The sort order in which the results are returned. Default is &#x60;COUNT_DESC&#x60;.
         * @param {number} [pageSize] [Optional] The maximum number of results to return per response. Default is 20.
         * @param {string} [pageToken] [Optional] A &#x60;next_page_token&#x60; provided by a previous response. To view additional results, pass this token along with the identical query parameters as the first request.
         * @param {string} [serviceFilter_resourceType] [Optional] The exact value to match against [&#x60;ServiceContext.resource_type&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.resource_type).
         * @param {string} [serviceFilter_service] [Optional] The exact value to match against [&#x60;ServiceContext.service&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.service).
         * @param {string} [serviceFilter_version] [Optional] The exact value to match against [&#x60;ServiceContext.version&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.version).
         * @param {'PERIOD_UNSPECIFIED' | 'PERIOD_1_HOUR' | 'PERIOD_6_HOURS' | 'PERIOD_1_DAY' | 'PERIOD_1_WEEK' | 'PERIOD_30_DAYS'} [timeRange_period] Restricts the query to the specified time range.
         * @param {string} [timedCountDuration] [Optional] The preferred duration for a single returned &#x60;TimedCount&#x60;. If not set, no timed counts are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsGroupStatsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, alignment, alignmentTime, groupId, order, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, timedCountDuration, options) {
            const localVarFetchArgs = exports.ProjectsApiFetchParamCreator(configuration).clouderrorreportingProjectsGroupStatsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, alignment, alignmentTime, groupId, order, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, timedCountDuration, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    throw response;
                });
            };
        },
        /**
         * Get the specified group.
         * @param {string} packName [Required] The group resource name. Written as &lt;code&gt;projects/&lt;var&gt;projectID&lt;/var&gt;/groups/&lt;var&gt;group_name&lt;/var&gt;&lt;/code&gt;. Call &lt;a href&#x3D;\&quot;/error-reporting/reference/rest/v1beta1/projects.groupStats/list\&quot;&gt; &lt;code&gt;groupStats.list&lt;/code&gt;&lt;/a&gt; to return a list of groups belonging to this project.  Example: &lt;code&gt;projects/my-project-123/groups/my-group&lt;/code&gt;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsGroupsGet(packName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            const localVarFetchArgs = exports.ProjectsApiFetchParamCreator(configuration).clouderrorreportingProjectsGroupsGet(packName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    throw response;
                });
            };
        },
        /**
         * Replace the data for the specified group. Fails if the group does not exist.
         * @param {string} name The group resource name. Example: &lt;code&gt;projects/my-project-123/groups/my-groupid&lt;/code&gt;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {ErrorGroup} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsGroupsUpdate(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            const localVarFetchArgs = exports.ProjectsApiFetchParamCreator(configuration).clouderrorreportingProjectsGroupsUpdate(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    throw response;
                });
            };
        }
    };
};
exports.ProjectsApiFp = ProjectsApiFp;
/**
 * ProjectsApi - factory interface
 * @export
 */
const ProjectsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Deletes all error events of a given project.
         * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &#x60;projects/&#x60; plus the [Google Cloud Platform project ID](https://support.google.com/cloud/answer/6158840). Example: &#x60;projects/my-project-123&#x60;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsDeleteEvents(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            return exports.ProjectsApiFp(configuration).clouderrorreportingProjectsDeleteEvents(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(fetch, basePath);
        },
        /**
         * Lists the specified events.
         * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &#x60;projects/&#x60; plus the [Google Cloud Platform project ID](https://support.google.com/cloud/answer/6158840). Example: &#x60;projects/my-project-123&#x60;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {string} [groupId] [Required] The group for which events shall be returned.
         * @param {number} [pageSize] [Optional] The maximum number of results to return per response.
         * @param {string} [pageToken] [Optional] A &#x60;next_page_token&#x60; provided by a previous response.
         * @param {string} [serviceFilter_resourceType] [Optional] The exact value to match against [&#x60;ServiceContext.resource_type&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.resource_type).
         * @param {string} [serviceFilter_service] [Optional] The exact value to match against [&#x60;ServiceContext.service&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.service).
         * @param {string} [serviceFilter_version] [Optional] The exact value to match against [&#x60;ServiceContext.version&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.version).
         * @param {'PERIOD_UNSPECIFIED' | 'PERIOD_1_HOUR' | 'PERIOD_6_HOURS' | 'PERIOD_1_DAY' | 'PERIOD_1_WEEK' | 'PERIOD_30_DAYS'} [timeRange_period] Restricts the query to the specified time range.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsEventsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, groupId, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, options) {
            return exports.ProjectsApiFp(configuration).clouderrorreportingProjectsEventsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, groupId, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, options)(fetch, basePath);
        },
        /**
         * Report an individual error event.  This endpoint accepts **either** an OAuth token, **or** an [API key](https://support.google.com/cloud/answer/6158862) for authentication. To use an API key, append it to the URL as the value of a `key` parameter. For example:  `POST https://clouderrorreporting.googleapis.com/v1beta1/projects/example-project/events:report?key=123ABC456`
         * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &#x60;projects/&#x60; plus the [Google Cloud Platform project ID](https://support.google.com/cloud/answer/6158840). Example: &#x60;projects/my-project-123&#x60;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {ReportedErrorEvent} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsEventsReport(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            return exports.ProjectsApiFp(configuration).clouderrorreportingProjectsEventsReport(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(fetch, basePath);
        },
        /**
         * Lists the specified groups.
         * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &lt;code&gt;projects/&lt;/code&gt; plus the &lt;a href&#x3D;\&quot;https://support.google.com/cloud/answer/6158840\&quot;&gt;Google Cloud Platform project ID&lt;/a&gt;.  Example: &lt;code&gt;projects/my-project-123&lt;/code&gt;.
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {'ERROR_COUNT_ALIGNMENT_UNSPECIFIED' | 'ALIGNMENT_EQUAL_ROUNDED' | 'ALIGNMENT_EQUAL_AT_END'} [alignment] [Optional] The alignment of the timed counts to be returned. Default is &#x60;ALIGNMENT_EQUAL_AT_END&#x60;.
         * @param {string} [alignmentTime] [Optional] Time where the timed counts shall be aligned if rounded alignment is chosen. Default is 00:00 UTC.
         * @param {Array<string>} [groupId] [Optional] List all &lt;code&gt;ErrorGroupStats&lt;/code&gt; with these IDs.
         * @param {'GROUP_ORDER_UNSPECIFIED' | 'COUNT_DESC' | 'LAST_SEEN_DESC' | 'CREATED_DESC' | 'AFFECTED_USERS_DESC'} [order] [Optional] The sort order in which the results are returned. Default is &#x60;COUNT_DESC&#x60;.
         * @param {number} [pageSize] [Optional] The maximum number of results to return per response. Default is 20.
         * @param {string} [pageToken] [Optional] A &#x60;next_page_token&#x60; provided by a previous response. To view additional results, pass this token along with the identical query parameters as the first request.
         * @param {string} [serviceFilter_resourceType] [Optional] The exact value to match against [&#x60;ServiceContext.resource_type&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.resource_type).
         * @param {string} [serviceFilter_service] [Optional] The exact value to match against [&#x60;ServiceContext.service&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.service).
         * @param {string} [serviceFilter_version] [Optional] The exact value to match against [&#x60;ServiceContext.version&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.version).
         * @param {'PERIOD_UNSPECIFIED' | 'PERIOD_1_HOUR' | 'PERIOD_6_HOURS' | 'PERIOD_1_DAY' | 'PERIOD_1_WEEK' | 'PERIOD_30_DAYS'} [timeRange_period] Restricts the query to the specified time range.
         * @param {string} [timedCountDuration] [Optional] The preferred duration for a single returned &#x60;TimedCount&#x60;. If not set, no timed counts are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsGroupStatsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, alignment, alignmentTime, groupId, order, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, timedCountDuration, options) {
            return exports.ProjectsApiFp(configuration).clouderrorreportingProjectsGroupStatsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, alignment, alignmentTime, groupId, order, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, timedCountDuration, options)(fetch, basePath);
        },
        /**
         * Get the specified group.
         * @param {string} packName [Required] The group resource name. Written as &lt;code&gt;projects/&lt;var&gt;projectID&lt;/var&gt;/groups/&lt;var&gt;group_name&lt;/var&gt;&lt;/code&gt;. Call &lt;a href&#x3D;\&quot;/error-reporting/reference/rest/v1beta1/projects.groupStats/list\&quot;&gt; &lt;code&gt;groupStats.list&lt;/code&gt;&lt;/a&gt; to return a list of groups belonging to this project.  Example: &lt;code&gt;projects/my-project-123/groups/my-group&lt;/code&gt;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsGroupsGet(packName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
            return exports.ProjectsApiFp(configuration).clouderrorreportingProjectsGroupsGet(packName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(fetch, basePath);
        },
        /**
         * Replace the data for the specified group. Fails if the group does not exist.
         * @param {string} name The group resource name. Example: &lt;code&gt;projects/my-project-123/groups/my-groupid&lt;/code&gt;
         * @param {'1' | '2'} [_xgafv] V1 error format.
         * @param {string} [access_token] OAuth access token.
         * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
         * @param {string} [callback] JSONP
         * @param {string} [fields] Selector specifying which fields to include in a partial response.
         * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         * @param {string} [oauth_token] OAuth 2.0 token for the current user.
         * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
         * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
         * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
         * @param {ErrorGroup} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clouderrorreportingProjectsGroupsUpdate(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
            return exports.ProjectsApiFp(configuration).clouderrorreportingProjectsGroupsUpdate(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(fetch, basePath);
        }
    };
};
exports.ProjectsApiFactory = ProjectsApiFactory;
/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
class ProjectsApi extends BaseAPI {
    /**
     * Deletes all error events of a given project.
     * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &#x60;projects/&#x60; plus the [Google Cloud Platform project ID](https://support.google.com/cloud/answer/6158840). Example: &#x60;projects/my-project-123&#x60;.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    clouderrorreportingProjectsDeleteEvents(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
        return exports.ProjectsApiFp(this.configuration).clouderrorreportingProjectsDeleteEvents(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(this.fetch, this.basePath);
    }
    /**
     * Lists the specified events.
     * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &#x60;projects/&#x60; plus the [Google Cloud Platform project ID](https://support.google.com/cloud/answer/6158840). Example: &#x60;projects/my-project-123&#x60;.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {string} [groupId] [Required] The group for which events shall be returned.
     * @param {number} [pageSize] [Optional] The maximum number of results to return per response.
     * @param {string} [pageToken] [Optional] A &#x60;next_page_token&#x60; provided by a previous response.
     * @param {string} [serviceFilter_resourceType] [Optional] The exact value to match against [&#x60;ServiceContext.resource_type&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.resource_type).
     * @param {string} [serviceFilter_service] [Optional] The exact value to match against [&#x60;ServiceContext.service&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.service).
     * @param {string} [serviceFilter_version] [Optional] The exact value to match against [&#x60;ServiceContext.version&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.version).
     * @param {'PERIOD_UNSPECIFIED' | 'PERIOD_1_HOUR' | 'PERIOD_6_HOURS' | 'PERIOD_1_DAY' | 'PERIOD_1_WEEK' | 'PERIOD_30_DAYS'} [timeRange_period] Restricts the query to the specified time range.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    clouderrorreportingProjectsEventsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, groupId, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, options) {
        return exports.ProjectsApiFp(this.configuration).clouderrorreportingProjectsEventsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, groupId, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, options)(this.fetch, this.basePath);
    }
    /**
     * Report an individual error event.  This endpoint accepts **either** an OAuth token, **or** an [API key](https://support.google.com/cloud/answer/6158862) for authentication. To use an API key, append it to the URL as the value of a `key` parameter. For example:  `POST https://clouderrorreporting.googleapis.com/v1beta1/projects/example-project/events:report?key=123ABC456`
     * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &#x60;projects/&#x60; plus the [Google Cloud Platform project ID](https://support.google.com/cloud/answer/6158840). Example: &#x60;projects/my-project-123&#x60;.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {ReportedErrorEvent} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    clouderrorreportingProjectsEventsReport(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
        return exports.ProjectsApiFp(this.configuration).clouderrorreportingProjectsEventsReport(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(this.fetch, this.basePath);
    }
    /**
     * Lists the specified groups.
     * @param {string} projectName [Required] The resource name of the Google Cloud Platform project. Written as &lt;code&gt;projects/&lt;/code&gt; plus the &lt;a href&#x3D;\&quot;https://support.google.com/cloud/answer/6158840\&quot;&gt;Google Cloud Platform project ID&lt;/a&gt;.  Example: &lt;code&gt;projects/my-project-123&lt;/code&gt;.
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {'ERROR_COUNT_ALIGNMENT_UNSPECIFIED' | 'ALIGNMENT_EQUAL_ROUNDED' | 'ALIGNMENT_EQUAL_AT_END'} [alignment] [Optional] The alignment of the timed counts to be returned. Default is &#x60;ALIGNMENT_EQUAL_AT_END&#x60;.
     * @param {string} [alignmentTime] [Optional] Time where the timed counts shall be aligned if rounded alignment is chosen. Default is 00:00 UTC.
     * @param {Array<string>} [groupId] [Optional] List all &lt;code&gt;ErrorGroupStats&lt;/code&gt; with these IDs.
     * @param {'GROUP_ORDER_UNSPECIFIED' | 'COUNT_DESC' | 'LAST_SEEN_DESC' | 'CREATED_DESC' | 'AFFECTED_USERS_DESC'} [order] [Optional] The sort order in which the results are returned. Default is &#x60;COUNT_DESC&#x60;.
     * @param {number} [pageSize] [Optional] The maximum number of results to return per response. Default is 20.
     * @param {string} [pageToken] [Optional] A &#x60;next_page_token&#x60; provided by a previous response. To view additional results, pass this token along with the identical query parameters as the first request.
     * @param {string} [serviceFilter_resourceType] [Optional] The exact value to match against [&#x60;ServiceContext.resource_type&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.resource_type).
     * @param {string} [serviceFilter_service] [Optional] The exact value to match against [&#x60;ServiceContext.service&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.service).
     * @param {string} [serviceFilter_version] [Optional] The exact value to match against [&#x60;ServiceContext.version&#x60;](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.version).
     * @param {'PERIOD_UNSPECIFIED' | 'PERIOD_1_HOUR' | 'PERIOD_6_HOURS' | 'PERIOD_1_DAY' | 'PERIOD_1_WEEK' | 'PERIOD_30_DAYS'} [timeRange_period] Restricts the query to the specified time range.
     * @param {string} [timedCountDuration] [Optional] The preferred duration for a single returned &#x60;TimedCount&#x60;. If not set, no timed counts are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    clouderrorreportingProjectsGroupStatsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, alignment, alignmentTime, groupId, order, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, timedCountDuration, options) {
        return exports.ProjectsApiFp(this.configuration).clouderrorreportingProjectsGroupStatsList(projectName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, alignment, alignmentTime, groupId, order, pageSize, pageToken, serviceFilter_resourceType, serviceFilter_service, serviceFilter_version, timeRange_period, timedCountDuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get the specified group.
     * @param {string} packName [Required] The group resource name. Written as &lt;code&gt;projects/&lt;var&gt;projectID&lt;/var&gt;/groups/&lt;var&gt;group_name&lt;/var&gt;&lt;/code&gt;. Call &lt;a href&#x3D;\&quot;/error-reporting/reference/rest/v1beta1/projects.groupStats/list\&quot;&gt; &lt;code&gt;groupStats.list&lt;/code&gt;&lt;/a&gt; to return a list of groups belonging to this project.  Example: &lt;code&gt;projects/my-project-123/groups/my-group&lt;/code&gt;
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    clouderrorreportingProjectsGroupsGet(packName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options) {
        return exports.ProjectsApiFp(this.configuration).clouderrorreportingProjectsGroupsGet(packName, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, options)(this.fetch, this.basePath);
    }
    /**
     * Replace the data for the specified group. Fails if the group does not exist.
     * @param {string} name The group resource name. Example: &lt;code&gt;projects/my-project-123/groups/my-groupid&lt;/code&gt;
     * @param {'1' | '2'} [_xgafv] V1 error format.
     * @param {string} [access_token] OAuth access token.
     * @param {'json' | 'media' | 'proto'} [alt] Data format for response.
     * @param {string} [callback] JSONP
     * @param {string} [fields] Selector specifying which fields to include in a partial response.
     * @param {string} [key] API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
     * @param {string} [oauth_token] OAuth 2.0 token for the current user.
     * @param {boolean} [prettyPrint] Returns response with indentations and line breaks.
     * @param {string} [quotaUser] Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
     * @param {string} [uploadType] Legacy upload protocol for media (e.g. \&quot;media\&quot;, \&quot;multipart\&quot;).
     * @param {string} [upload_protocol] Upload protocol for media (e.g. \&quot;raw\&quot;, \&quot;multipart\&quot;).
     * @param {ErrorGroup} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    clouderrorreportingProjectsGroupsUpdate(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options) {
        return exports.ProjectsApiFp(this.configuration).clouderrorreportingProjectsGroupsUpdate(name, _xgafv, access_token, alt, callback, fields, key, oauth_token, prettyPrint, quotaUser, uploadType, upload_protocol, body, options)(this.fetch, this.basePath);
    }
}
exports.ProjectsApi = ProjectsApi;
//# sourceMappingURL=api.js.map

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable
/**
 * Stackdriver Error Reporting
 * Groups and counts similar errors from cloud services and applications, reports new errors, and provides access to error groups and their associated errors.
 *
 * OpenAPI spec version: v1beta1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Configuration = void 0;
class Configuration {
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
    }
}
exports.Configuration = Configuration;
//# sourceMappingURL=configuration.js.map

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(226);

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var RetryOperation = __webpack_require__(227);

exports.operation = function(options) {
  var timeouts = exports.timeouts(options);
  return new RetryOperation(timeouts, {
      forever: options && options.forever,
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
  });
};

exports.timeouts = function(options) {
  if (options instanceof Array) {
    return [].concat(options);
  }

  var opts = {
    retries: 10,
    factor: 2,
    minTimeout: 1 * 1000,
    maxTimeout: Infinity,
    randomize: false
  };
  for (var key in options) {
    opts[key] = options[key];
  }

  if (opts.minTimeout > opts.maxTimeout) {
    throw new Error('minTimeout is greater than maxTimeout');
  }

  var timeouts = [];
  for (var i = 0; i < opts.retries; i++) {
    timeouts.push(this.createTimeout(i, opts));
  }

  if (options && options.forever && !timeouts.length) {
    timeouts.push(this.createTimeout(i, opts));
  }

  // sort the array numerically ascending
  timeouts.sort(function(a,b) {
    return a - b;
  });

  return timeouts;
};

exports.createTimeout = function(attempt, opts) {
  var random = (opts.randomize)
    ? (Math.random() + 1)
    : 1;

  var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
  timeout = Math.min(timeout, opts.maxTimeout);

  return timeout;
};

exports.wrap = function(obj, options, methods) {
  if (options instanceof Array) {
    methods = options;
    options = null;
  }

  if (!methods) {
    methods = [];
    for (var key in obj) {
      if (typeof obj[key] === 'function') {
        methods.push(key);
      }
    }
  }

  for (var i = 0; i < methods.length; i++) {
    var method   = methods[i];
    var original = obj[method];

    obj[method] = function retryWrapper(original) {
      var op       = exports.operation(options);
      var args     = Array.prototype.slice.call(arguments, 1);
      var callback = args.pop();

      args.push(function(err) {
        if (op.retry(err)) {
          return;
        }
        if (err) {
          arguments[0] = op.mainError();
        }
        callback.apply(this, arguments);
      });

      op.attempt(function() {
        original.apply(obj, args);
      });
    }.bind(obj, original);
    obj[method].options = options;
  }
};


/***/ }),
/* 227 */
/***/ (function(module, exports) {

function RetryOperation(timeouts, options) {
  // Compatibility for the old (timeouts, retryForever) signature
  if (typeof options === 'boolean') {
    options = { forever: options };
  }

  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
  this._timeouts = timeouts;
  this._options = options || {};
  this._maxRetryTime = options && options.maxRetryTime || Infinity;
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;
  this._operationStart = null;

  if (this._options.forever) {
    this._cachedTimeouts = this._timeouts.slice(0);
  }
}
module.exports = RetryOperation;

RetryOperation.prototype.reset = function() {
  this._attempts = 1;
  this._timeouts = this._originalTimeouts;
}

RetryOperation.prototype.stop = function() {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }

  this._timeouts       = [];
  this._cachedTimeouts = null;
};

RetryOperation.prototype.retry = function(err) {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }

  if (!err) {
    return false;
  }
  var currentTime = new Date().getTime();
  if (err && currentTime - this._operationStart >= this._maxRetryTime) {
    this._errors.unshift(new Error('RetryOperation timeout occurred'));
    return false;
  }

  this._errors.push(err);

  var timeout = this._timeouts.shift();
  if (timeout === undefined) {
    if (this._cachedTimeouts) {
      // retry forever, only keep last error
      this._errors.splice(this._errors.length - 1, this._errors.length);
      this._timeouts = this._cachedTimeouts.slice(0);
      timeout = this._timeouts.shift();
    } else {
      return false;
    }
  }

  var self = this;
  var timer = setTimeout(function() {
    self._attempts++;

    if (self._operationTimeoutCb) {
      self._timeout = setTimeout(function() {
        self._operationTimeoutCb(self._attempts);
      }, self._operationTimeout);

      if (self._options.unref) {
          self._timeout.unref();
      }
    }

    self._fn(self._attempts);
  }, timeout);

  if (this._options.unref) {
      timer.unref();
  }

  return true;
};

RetryOperation.prototype.attempt = function(fn, timeoutOps) {
  this._fn = fn;

  if (timeoutOps) {
    if (timeoutOps.timeout) {
      this._operationTimeout = timeoutOps.timeout;
    }
    if (timeoutOps.cb) {
      this._operationTimeoutCb = timeoutOps.cb;
    }
  }

  var self = this;
  if (this._operationTimeoutCb) {
    this._timeout = setTimeout(function() {
      self._operationTimeoutCb();
    }, self._operationTimeout);
  }

  this._operationStart = new Date().getTime();

  this._fn(this._attempts);
};

RetryOperation.prototype.try = function(fn) {
  console.log('Using RetryOperation.try() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = function(fn) {
  console.log('Using RetryOperation.start() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = RetryOperation.prototype.try;

RetryOperation.prototype.errors = function() {
  return this._errors;
};

RetryOperation.prototype.attempts = function() {
  return this._attempts;
};

RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0) {
    return null;
  }

  var counts = {};
  var mainError = null;
  var mainErrorCount = 0;

  for (var i = 0; i < this._errors.length; i++) {
    var error = this._errors[i];
    var message = error.message;
    var count = (counts[message] || 0) + 1;

    counts[message] = count;

    if (count >= mainErrorCount) {
      mainError = error;
      mainErrorCount = count;
    }
  }

  return mainError;
};


/***/ }),
/* 228 */
/***/ (function(module) {

module.exports = {"name":"@iopa-edge/host-cloudflare","version":"3.0.0","description":"Avoid cloud provider lockin with IOPA adapter for Cloudflare Workers","main":"dist/index.js","ts:main":"src/index.ts","types":"src/index.ts","author":"iopa <build@iopa.io>","bin":{"edge-host":"./bin/dev"},"engines":{"node":"14"},"homepage":"https://iopa.io","eslintConfig":{"globals":{"blob":true,"encoding":true}},"keywords":["iopa","edge","cloudflare","workers","functions","lambda","azure function","google cloud function","node","bot","conversational agent"],"license":"Apache-2.0","repository":{"type":"git","url":"https://github.com/iopa-io/@iopa-edge/host-cloudflare.git"},"scripts":{"build":"tsc","format":"prettier --ignore-path ../../.gitignore --write '**/*.{js,jsx,ts,tsx,json,md}'"},"dependencies":{"@iopa-edge-contrib/stackdriver":"^3.0.0","@iopa-edge/store-kv":"^1.0.0","@iopa-edge/types":"^3.0.0","iopa":"^3.0.0","iopa-types":"^3.0.0","types-cloudflare-worker":"^1.2.0","url":"^0.11.0","url-search-params-polyfill":"^7.0.1"},"devDependencies":{},"peerDependencies":{}};

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Microsoft Bot Connector API - v3.0
 * The Bot Connector REST API allows your bot to send and receive messages to channels configured in the  [Bot Framework Developer Portal](https://dev.botframework.com). The Connector service uses industry-standard REST  and JSON over HTTPS.    Client libraries for this REST API are available. See below for a list.    Many bots will use both the Bot Connector REST API and the associated [Bot State REST API](/en-us/restapi/state). The  Bot State REST API allows a bot to store and retrieve state associated with users and conversations.    Authentication for both the Bot Connector and Bot State REST APIs is accomplished with JWT Bearer tokens, and is  described in detail in the [Connector Authentication](/en-us/restapi/authentication) document.    # Client Libraries for the Bot Connector REST API    * [Bot Builder for C#](/en-us/csharp/builder/sdkreference/)  * [Bot Builder for Node.js](/en-us/node/builder/overview/)  * Generate your own from the [Connector API Swagger file](https://raw.githubusercontent.com/Microsoft/BotBuilder/master/CSharp/Library/Microsoft.Bot.Connector.Shared/Swagger/ConnectorAPI.json)    Â© 2016 Microsoft
 *
 * OpenAPI spec version: v3
 * Contact: botframework@microsoft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationsApi = exports.ConversationsApiFactory = exports.ConversationsApiFp = exports.ConversationsApiFetchParamCreator = exports.AttachmentsApi = exports.AttachmentsApiFactory = exports.AttachmentsApiFp = exports.AttachmentsApiFetchParamCreator = exports.TextFormatTypes = exports.SemanticActionStates = exports.RoleTypes = exports.MessageReactionTypes = exports.InstallationUpdateActionTypes = exports.InputHints = exports.EndOfConversationCodes = exports.DeliveryModes = exports.ContactRelationUpdateActionTypes = exports.AttachmentLayoutTypes = exports.ActivityTypes = exports.ActivityImportance = exports.ActionTypes = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = void 0;
const url = __webpack_require__(12);
const portableFetch = __webpack_require__(41);
const BASE_PATH = 'https://api.botframework.com'.replace(/\/+$/, '');
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|',
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, fetch = portableFetch) {
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
exports.RequiredError = RequiredError;
/**
 * Defines action types for clickable buttons.
 * @export
 * @enum {string}
 */
var ActionTypes;
(function (ActionTypes) {
    ActionTypes[ActionTypes["OpenUrl"] = 'openUrl'] = "OpenUrl";
    ActionTypes[ActionTypes["ImBack"] = 'imBack'] = "ImBack";
    ActionTypes[ActionTypes["PostBack"] = 'postBack'] = "PostBack";
    ActionTypes[ActionTypes["PlayAudio"] = 'playAudio'] = "PlayAudio";
    ActionTypes[ActionTypes["PlayVideo"] = 'playVideo'] = "PlayVideo";
    ActionTypes[ActionTypes["ShowImage"] = 'showImage'] = "ShowImage";
    ActionTypes[ActionTypes["DownloadFile"] = 'downloadFile'] = "DownloadFile";
    ActionTypes[ActionTypes["Signin"] = 'signin'] = "Signin";
    ActionTypes[ActionTypes["Call"] = 'call'] = "Call";
    ActionTypes[ActionTypes["Payment"] = 'payment'] = "Payment";
    ActionTypes[ActionTypes["MessageBack"] = 'messageBack'] = "MessageBack";
})(ActionTypes = exports.ActionTypes || (exports.ActionTypes = {}));
/**
 * Defines the importance of an Activity
 * @export
 * @enum {string}
 */
var ActivityImportance;
(function (ActivityImportance) {
    ActivityImportance[ActivityImportance["Low"] = 'low'] = "Low";
    ActivityImportance[ActivityImportance["Normal"] = 'normal'] = "Normal";
    ActivityImportance[ActivityImportance["High"] = 'high'] = "High";
})(ActivityImportance = exports.ActivityImportance || (exports.ActivityImportance = {}));
/**
 * Types of Activities
 * @export
 * @enum {string}
 */
var ActivityTypes;
(function (ActivityTypes) {
    ActivityTypes[ActivityTypes["Message"] = 'message'] = "Message";
    ActivityTypes[ActivityTypes["ContactRelationUpdate"] = 'contactRelationUpdate'] = "ContactRelationUpdate";
    ActivityTypes[ActivityTypes["ConversationUpdate"] = 'conversationUpdate'] = "ConversationUpdate";
    ActivityTypes[ActivityTypes["Typing"] = 'typing'] = "Typing";
    ActivityTypes[ActivityTypes["EndOfConversation"] = 'endOfConversation'] = "EndOfConversation";
    ActivityTypes[ActivityTypes["Event"] = 'event'] = "Event";
    ActivityTypes[ActivityTypes["Invoke"] = 'invoke'] = "Invoke";
    ActivityTypes[ActivityTypes["DeleteUserData"] = 'deleteUserData'] = "DeleteUserData";
    ActivityTypes[ActivityTypes["MessageUpdate"] = 'messageUpdate'] = "MessageUpdate";
    ActivityTypes[ActivityTypes["MessageDelete"] = 'messageDelete'] = "MessageDelete";
    ActivityTypes[ActivityTypes["InstallationUpdate"] = 'installationUpdate'] = "InstallationUpdate";
    ActivityTypes[ActivityTypes["MessageReaction"] = 'messageReaction'] = "MessageReaction";
    ActivityTypes[ActivityTypes["Suggestion"] = 'suggestion'] = "Suggestion";
    ActivityTypes[ActivityTypes["Trace"] = 'trace'] = "Trace";
    ActivityTypes[ActivityTypes["Handoff"] = 'handoff'] = "Handoff";
    // additions
    ActivityTypes[ActivityTypes["Call"] = 'call'] = "Call";
    ActivityTypes[ActivityTypes["MessageStatus"] = 'messageStatus'] = "MessageStatus";
    ActivityTypes[ActivityTypes["CallStatus"] = 'callStatus'] = "CallStatus";
})(ActivityTypes = exports.ActivityTypes || (exports.ActivityTypes = {}));
/**
 * Attachment layout types
 * @export
 * @enum {string}
 */
var AttachmentLayoutTypes;
(function (AttachmentLayoutTypes) {
    AttachmentLayoutTypes[AttachmentLayoutTypes["List"] = 'list'] = "List";
    AttachmentLayoutTypes[AttachmentLayoutTypes["Carousel"] = 'carousel'] = "Carousel";
})(AttachmentLayoutTypes = exports.AttachmentLayoutTypes || (exports.AttachmentLayoutTypes = {}));
/**
 * Action types valid for ContactRelationUpdate activities
 * @export
 * @enum {string}
 */
var ContactRelationUpdateActionTypes;
(function (ContactRelationUpdateActionTypes) {
    ContactRelationUpdateActionTypes[ContactRelationUpdateActionTypes["Add"] = 'add'] = "Add";
    ContactRelationUpdateActionTypes[ContactRelationUpdateActionTypes["Remove"] = 'remove'] = "Remove";
})(ContactRelationUpdateActionTypes = exports.ContactRelationUpdateActionTypes || (exports.ContactRelationUpdateActionTypes = {}));
/**
 * Values for deliveryMode field
 * @export
 * @enum {string}
 */
var DeliveryModes;
(function (DeliveryModes) {
    DeliveryModes[DeliveryModes["Normal"] = 'normal'] = "Normal";
    DeliveryModes[DeliveryModes["Notification"] = 'notification'] = "Notification";
})(DeliveryModes = exports.DeliveryModes || (exports.DeliveryModes = {}));
/**
 * Codes indicating why a conversation has ended
 * @export
 * @enum {string}
 */
var EndOfConversationCodes;
(function (EndOfConversationCodes) {
    EndOfConversationCodes[EndOfConversationCodes["Unknown"] = 'unknown'] = "Unknown";
    EndOfConversationCodes[EndOfConversationCodes["CompletedSuccessfully"] = 'completedSuccessfully'] = "CompletedSuccessfully";
    EndOfConversationCodes[EndOfConversationCodes["UserCancelled"] = 'userCancelled'] = "UserCancelled";
    EndOfConversationCodes[EndOfConversationCodes["BotTimedOut"] = 'botTimedOut'] = "BotTimedOut";
    EndOfConversationCodes[EndOfConversationCodes["BotIssuedInvalidMessage"] = 'botIssuedInvalidMessage'] = "BotIssuedInvalidMessage";
    EndOfConversationCodes[EndOfConversationCodes["ChannelFailed"] = 'channelFailed'] = "ChannelFailed";
})(EndOfConversationCodes = exports.EndOfConversationCodes || (exports.EndOfConversationCodes = {}));
/**
 * Indicates whether the bot is accepting, expecting, or ignoring input
 * @export
 * @enum {string}
 */
var InputHints;
(function (InputHints) {
    InputHints[InputHints["AcceptingInput"] = 'acceptingInput'] = "AcceptingInput";
    InputHints[InputHints["IgnoringInput"] = 'ignoringInput'] = "IgnoringInput";
    InputHints[InputHints["ExpectingInput"] = 'expectingInput'] = "ExpectingInput";
})(InputHints = exports.InputHints || (exports.InputHints = {}));
/**
 * Action types valid for InstallationUpdate activities
 * @export
 * @enum {string}
 */
var InstallationUpdateActionTypes;
(function (InstallationUpdateActionTypes) {
    InstallationUpdateActionTypes[InstallationUpdateActionTypes["Add"] = 'add'] = "Add";
    InstallationUpdateActionTypes[InstallationUpdateActionTypes["Remove"] = 'remove'] = "Remove";
})(InstallationUpdateActionTypes = exports.InstallationUpdateActionTypes || (exports.InstallationUpdateActionTypes = {}));
/**
 * Message reaction types
 * @export
 * @enum {string}
 */
var MessageReactionTypes;
(function (MessageReactionTypes) {
    MessageReactionTypes[MessageReactionTypes["Like"] = 'like'] = "Like";
    MessageReactionTypes[MessageReactionTypes["PlusOne"] = 'plusOne'] = "PlusOne";
})(MessageReactionTypes = exports.MessageReactionTypes || (exports.MessageReactionTypes = {}));
/**
 * Role of the entity behind the account (Example: User, Bot, etc.)
 * @export
 * @enum {string}
 */
var RoleTypes;
(function (RoleTypes) {
    RoleTypes[RoleTypes["User"] = 'user'] = "User";
    RoleTypes[RoleTypes["Bot"] = 'bot'] = "Bot";
})(RoleTypes = exports.RoleTypes || (exports.RoleTypes = {}));
/**
 * Indicates whether the semantic action is starting, continuing, or done
 * @export
 * @enum {string}
 */
var SemanticActionStates;
(function (SemanticActionStates) {
    SemanticActionStates[SemanticActionStates["Start"] = 'start'] = "Start";
    SemanticActionStates[SemanticActionStates["Continue"] = 'continue'] = "Continue";
    SemanticActionStates[SemanticActionStates["Done"] = 'done'] = "Done";
})(SemanticActionStates = exports.SemanticActionStates || (exports.SemanticActionStates = {}));
/**
 * Text format types
 * @export
 * @enum {string}
 */
var TextFormatTypes;
(function (TextFormatTypes) {
    TextFormatTypes[TextFormatTypes["Markdown"] = 'markdown'] = "Markdown";
    TextFormatTypes[TextFormatTypes["Plain"] = 'plain'] = "Plain";
    TextFormatTypes[TextFormatTypes["Xml"] = 'xml'] = "Xml";
})(TextFormatTypes = exports.TextFormatTypes || (exports.TextFormatTypes = {}));
/**
 * AttachmentsApi - fetch parameter creator
 * @export
 */
const AttachmentsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get the named view as binary content
         * @summary GetAttachment
         * @param {string} attachmentId attachment id
         * @param {string} viewId View id from attachmentInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentsGetAttachment(attachmentId, viewId, options = {}) {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId', 'Required parameter attachmentId was null or undefined when calling attachmentsGetAttachment.');
            }
            // verify required parameter 'viewId' is not null or undefined
            if (viewId === null || viewId === undefined) {
                throw new RequiredError('viewId', 'Required parameter viewId was null or undefined when calling attachmentsGetAttachment.');
            }
            const localVarPath = `/v3/attachments/{attachmentId}/views/{viewId}`
                .replace(`{${'attachmentId'}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${'viewId'}}`, encodeURIComponent(String(viewId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get AttachmentInfo structure describing the attachment views
         * @summary GetAttachmentInfo
         * @param {string} attachmentId attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentsGetAttachmentInfo(attachmentId, options = {}) {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId', 'Required parameter attachmentId was null or undefined when calling attachmentsGetAttachmentInfo.');
            }
            const localVarPath = `/v3/attachments/{attachmentId}`.replace(`{${'attachmentId'}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AttachmentsApiFetchParamCreator = AttachmentsApiFetchParamCreator;
/**
 * AttachmentsApi - functional programming interface
 * @export
 */
const AttachmentsApiFp = function (configuration) {
    return {
        /**
         * Get the named view as binary content
         * @summary GetAttachment
         * @param {string} attachmentId attachment id
         * @param {string} viewId View id from attachmentInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentsGetAttachment(attachmentId, viewId, options) {
            const localVarFetchArgs = exports.AttachmentsApiFetchParamCreator(configuration).attachmentsGetAttachment(attachmentId, viewId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get AttachmentInfo structure describing the attachment views
         * @summary GetAttachmentInfo
         * @param {string} attachmentId attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentsGetAttachmentInfo(attachmentId, options) {
            const localVarFetchArgs = exports.AttachmentsApiFetchParamCreator(configuration).attachmentsGetAttachmentInfo(attachmentId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.AttachmentsApiFp = AttachmentsApiFp;
/**
 * AttachmentsApi - factory interface
 * @export
 */
const AttachmentsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get the named view as binary content
         * @summary GetAttachment
         * @param {string} attachmentId attachment id
         * @param {string} viewId View id from attachmentInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentsGetAttachment(attachmentId, viewId, options) {
            return exports.AttachmentsApiFp(configuration).attachmentsGetAttachment(attachmentId, viewId, options)(fetch, basePath);
        },
        /**
         * Get AttachmentInfo structure describing the attachment views
         * @summary GetAttachmentInfo
         * @param {string} attachmentId attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentsGetAttachmentInfo(attachmentId, options) {
            return exports.AttachmentsApiFp(configuration).attachmentsGetAttachmentInfo(attachmentId, options)(fetch, basePath);
        },
    };
};
exports.AttachmentsApiFactory = AttachmentsApiFactory;
/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
class AttachmentsApi extends BaseAPI {
    /**
     * Get the named view as binary content
     * @summary GetAttachment
     * @param {string} attachmentId attachment id
     * @param {string} viewId View id from attachmentInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    attachmentsGetAttachment(attachmentId, viewId, options) {
        return exports.AttachmentsApiFp(this.configuration).attachmentsGetAttachment(attachmentId, viewId, options)(this.fetch, this.basePath);
    }
    /**
     * Get AttachmentInfo structure describing the attachment views
     * @summary GetAttachmentInfo
     * @param {string} attachmentId attachment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    attachmentsGetAttachmentInfo(attachmentId, options) {
        return exports.AttachmentsApiFp(this.configuration).attachmentsGetAttachmentInfo(attachmentId, options)(this.fetch, this.basePath);
    }
}
exports.AttachmentsApi = AttachmentsApi;
/**
 * ConversationsApi - fetch parameter creator
 * @export
 */
const ConversationsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Create a new Conversation.    POST to this method with a  * Bot being the bot creating the conversation  * IsGroup set to true if this is not a direct message (default is false)  * Array containing the members to include in the conversation    The return value is a ResourceResponse which contains a conversation id which is suitable for use  in the message payload and REST API uris.    Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:    ```  var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(\"user1\") } );  await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;    ```
         * @summary CreateConversation
         * @param {ConversationParameters} parameters Parameters to create the conversation from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsCreateConversation(parameters, options = {}) {
            // verify required parameter 'parameters' is not null or undefined
            if (parameters === null || parameters === undefined) {
                throw new RequiredError('parameters', 'Required parameter parameters was null or undefined when calling conversationsCreateConversation.');
            }
            const localVarPath = `/v3/conversations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(parameters || {})
                : parameters || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing activity.    Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
         * @summary DeleteActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsDeleteActivity(conversationId, activityId, options = {}) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling conversationsDeleteActivity.');
            }
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError('activityId', 'Required parameter activityId was null or undefined when calling conversationsDeleteActivity.');
            }
            const localVarPath = `/v3/conversations/{conversationId}/activities/{activityId}`
                .replace(`{${'conversationId'}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${'activityId'}}`, encodeURIComponent(String(activityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a member from a conversation.     This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member  of the conversation, the conversation will also be deleted.
         * @summary DeleteConversationMember
         * @param {string} conversationId Conversation ID
         * @param {string} memberId ID of the member to delete from this conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsDeleteConversationMember(conversationId, memberId, options = {}) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling conversationsDeleteConversationMember.');
            }
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId', 'Required parameter memberId was null or undefined when calling conversationsDeleteConversationMember.');
            }
            const localVarPath = `/v3/conversations/{conversationId}/members/{memberId}`
                .replace(`{${'conversationId'}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${'memberId'}}`, encodeURIComponent(String(memberId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enumerate the members of an activity.     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
         * @summary GetActivityMembers
         * @param {string} conversationId Conversation ID
         * @param {string} activityId Activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetActivityMembers(conversationId, activityId, options = {}) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling conversationsGetActivityMembers.');
            }
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError('activityId', 'Required parameter activityId was null or undefined when calling conversationsGetActivityMembers.');
            }
            const localVarPath = `/v3/conversations/{conversationId}/activities/{activityId}/members`
                .replace(`{${'conversationId'}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${'activityId'}}`, encodeURIComponent(String(activityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enumerate the members of a conversation.     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
         * @summary GetConversationMembers
         * @param {string} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversationMembers(conversationId, options = {}) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling conversationsGetConversationMembers.');
            }
            const localVarPath = `/v3/conversations/{conversationId}/members`.replace(`{${'conversationId'}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enumerate the members of a conversation one page at a time.    This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array  of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.    One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as   a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.    A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
         * @summary GetConversationPagedMembers
         * @param {string} conversationId Conversation ID
         * @param {number} [pageSize] Suggested page size
         * @param {string} [continuationToken] Continuation Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversationPagedMembers(conversationId, pageSize, continuationToken, options = {}) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling conversationsGetConversationPagedMembers.');
            }
            const localVarPath = `/v3/conversations/{conversationId}/pagedmembers`.replace(`{${'conversationId'}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (continuationToken !== undefined) {
                localVarQueryParameter['continuationToken'] = continuationToken;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Conversations in which this bot has participated.    GET from this method with a skip token    The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then   there are further values to be returned. Call this method again with the returned token to get more values.    Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
         * @summary GetConversations
         * @param {string} [continuationToken] skip or continuation token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversations(continuationToken, options = {}) {
            const localVarPath = `/v3/conversations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (continuationToken !== undefined) {
                localVarQueryParameter['continuationToken'] = continuationToken;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method allows you to reply to an activity.    This is slightly different from SendToConversation().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
         * @summary ReplyToActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId the reply is to (OPTIONAL)
         * @param {Activity} activity Activity to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsReplyToActivity(conversationId, activityId, activity, options = {}) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling conversationsReplyToActivity.');
            }
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError('activityId', 'Required parameter activityId was null or undefined when calling conversationsReplyToActivity.');
            }
            // verify required parameter 'activity' is not null or undefined
            if (activity === null || activity === undefined) {
                throw new RequiredError('activity', 'Required parameter activity was null or undefined when calling conversationsReplyToActivity.');
            }
            const localVarPath = `/v3/conversations/{conversationId}/activities/{activityId}`
                .replace(`{${'conversationId'}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${'activityId'}}`, encodeURIComponent(String(activityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(activity || {})
                : activity || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method allows you to upload the historic activities to the conversation.    Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
         * @summary SendConversationHistory
         * @param {string} conversationId Conversation ID
         * @param {Transcript} history Historic activities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsSendConversationHistory(conversationId, history, options = {}) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling conversationsSendConversationHistory.');
            }
            // verify required parameter 'history' is not null or undefined
            if (history === null || history === undefined) {
                throw new RequiredError('history', 'Required parameter history was null or undefined when calling conversationsSendConversationHistory.');
            }
            const localVarPath = `/v3/conversations/{conversationId}/activities/history`.replace(`{${'conversationId'}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(history || {})
                : history || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method allows you to send an activity to the end of a conversation.    This is slightly different from ReplyToActivity().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
         * @summary SendToConversation
         * @param {string} conversationId Conversation ID
         * @param {Activity} activity Activity to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsSendToConversation(conversationId, activity, options = {}) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling conversationsSendToConversation.');
            }
            // verify required parameter 'activity' is not null or undefined
            if (activity === null || activity === undefined) {
                throw new RequiredError('activity', 'Required parameter activity was null or undefined when calling conversationsSendToConversation.');
            }
            const localVarPath = `/v3/conversations/{conversationId}/activities`.replace(`{${'conversationId'}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(activity || {})
                : activity || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an existing activity.    Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    For example, you can remove buttons after someone has clicked \"Approve\" button.
         * @summary UpdateActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId to update
         * @param {Activity} activity replacement Activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsUpdateActivity(conversationId, activityId, activity, options = {}) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling conversationsUpdateActivity.');
            }
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError('activityId', 'Required parameter activityId was null or undefined when calling conversationsUpdateActivity.');
            }
            // verify required parameter 'activity' is not null or undefined
            if (activity === null || activity === undefined) {
                throw new RequiredError('activity', 'Required parameter activity was null or undefined when calling conversationsUpdateActivity.');
            }
            const localVarPath = `/v3/conversations/{conversationId}/activities/{activityId}`
                .replace(`{${'conversationId'}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${'activityId'}}`, encodeURIComponent(String(activityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(activity || {})
                : activity || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload an attachment directly into a channel's blob storage.    This is useful because it allows you to store data in a compliant store when dealing with enterprises.    The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
         * @summary UploadAttachment
         * @param {string} conversationId Conversation ID
         * @param {AttachmentData} attachmentUpload Attachment data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsUploadAttachment(conversationId, attachmentUpload, options = {}) {
            // verify required parameter 'conversationId' is not null or undefined
            if (conversationId === null || conversationId === undefined) {
                throw new RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling conversationsUploadAttachment.');
            }
            // verify required parameter 'attachmentUpload' is not null or undefined
            if (attachmentUpload === null || attachmentUpload === undefined) {
                throw new RequiredError('attachmentUpload', 'Required parameter attachmentUpload was null or undefined when calling conversationsUploadAttachment.');
            }
            const localVarPath = `/v3/conversations/{conversationId}/attachments`.replace(`{${'conversationId'}}`, encodeURIComponent(String(conversationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(attachmentUpload || {})
                : attachmentUpload || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ConversationsApiFetchParamCreator = ConversationsApiFetchParamCreator;
/**
 * ConversationsApi - functional programming interface
 * @export
 */
const ConversationsApiFp = function (configuration) {
    return {
        /**
         * Create a new Conversation.    POST to this method with a  * Bot being the bot creating the conversation  * IsGroup set to true if this is not a direct message (default is false)  * Array containing the members to include in the conversation    The return value is a ResourceResponse which contains a conversation id which is suitable for use  in the message payload and REST API uris.    Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:    ```  var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(\"user1\") } );  await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;    ```
         * @summary CreateConversation
         * @param {ConversationParameters} parameters Parameters to create the conversation from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsCreateConversation(parameters, options) {
            const localVarFetchArgs = exports.ConversationsApiFetchParamCreator(configuration).conversationsCreateConversation(parameters, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an existing activity.    Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
         * @summary DeleteActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsDeleteActivity(conversationId, activityId, options) {
            const localVarFetchArgs = exports.ConversationsApiFetchParamCreator(configuration).conversationsDeleteActivity(conversationId, activityId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a member from a conversation.     This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member  of the conversation, the conversation will also be deleted.
         * @summary DeleteConversationMember
         * @param {string} conversationId Conversation ID
         * @param {string} memberId ID of the member to delete from this conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsDeleteConversationMember(conversationId, memberId, options) {
            const localVarFetchArgs = exports.ConversationsApiFetchParamCreator(configuration).conversationsDeleteConversationMember(conversationId, memberId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enumerate the members of an activity.     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
         * @summary GetActivityMembers
         * @param {string} conversationId Conversation ID
         * @param {string} activityId Activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetActivityMembers(conversationId, activityId, options) {
            const localVarFetchArgs = exports.ConversationsApiFetchParamCreator(configuration).conversationsGetActivityMembers(conversationId, activityId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enumerate the members of a conversation.     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
         * @summary GetConversationMembers
         * @param {string} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversationMembers(conversationId, options) {
            const localVarFetchArgs = exports.ConversationsApiFetchParamCreator(configuration).conversationsGetConversationMembers(conversationId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enumerate the members of a conversation one page at a time.    This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array  of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.    One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as   a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.    A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
         * @summary GetConversationPagedMembers
         * @param {string} conversationId Conversation ID
         * @param {number} [pageSize] Suggested page size
         * @param {string} [continuationToken] Continuation Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversationPagedMembers(conversationId, pageSize, continuationToken, options) {
            const localVarFetchArgs = exports.ConversationsApiFetchParamCreator(configuration).conversationsGetConversationPagedMembers(conversationId, pageSize, continuationToken, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List the Conversations in which this bot has participated.    GET from this method with a skip token    The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then   there are further values to be returned. Call this method again with the returned token to get more values.    Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
         * @summary GetConversations
         * @param {string} [continuationToken] skip or continuation token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversations(continuationToken, options) {
            const localVarFetchArgs = exports.ConversationsApiFetchParamCreator(configuration).conversationsGetConversations(continuationToken, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This method allows you to reply to an activity.    This is slightly different from SendToConversation().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
         * @summary ReplyToActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId the reply is to (OPTIONAL)
         * @param {Activity} activity Activity to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsReplyToActivity(conversationId, activityId, activity, options) {
            const localVarFetchArgs = exports.ConversationsApiFetchParamCreator(configuration).conversationsReplyToActivity(conversationId, activityId, activity, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This method allows you to upload the historic activities to the conversation.    Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
         * @summary SendConversationHistory
         * @param {string} conversationId Conversation ID
         * @param {Transcript} history Historic activities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsSendConversationHistory(conversationId, history, options) {
            const localVarFetchArgs = exports.ConversationsApiFetchParamCreator(configuration).conversationsSendConversationHistory(conversationId, history, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This method allows you to send an activity to the end of a conversation.    This is slightly different from ReplyToActivity().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
         * @summary SendToConversation
         * @param {string} conversationId Conversation ID
         * @param {Activity} activity Activity to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsSendToConversation(conversationId, activity, options) {
            const localVarFetchArgs = exports.ConversationsApiFetchParamCreator(configuration).conversationsSendToConversation(conversationId, activity, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Edit an existing activity.    Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    For example, you can remove buttons after someone has clicked \"Approve\" button.
         * @summary UpdateActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId to update
         * @param {Activity} activity replacement Activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsUpdateActivity(conversationId, activityId, activity, options) {
            const localVarFetchArgs = exports.ConversationsApiFetchParamCreator(configuration).conversationsUpdateActivity(conversationId, activityId, activity, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Upload an attachment directly into a channel's blob storage.    This is useful because it allows you to store data in a compliant store when dealing with enterprises.    The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
         * @summary UploadAttachment
         * @param {string} conversationId Conversation ID
         * @param {AttachmentData} attachmentUpload Attachment data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsUploadAttachment(conversationId, attachmentUpload, options) {
            const localVarFetchArgs = exports.ConversationsApiFetchParamCreator(configuration).conversationsUploadAttachment(conversationId, attachmentUpload, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.ConversationsApiFp = ConversationsApiFp;
/**
 * ConversationsApi - factory interface
 * @export
 */
const ConversationsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Create a new Conversation.    POST to this method with a  * Bot being the bot creating the conversation  * IsGroup set to true if this is not a direct message (default is false)  * Array containing the members to include in the conversation    The return value is a ResourceResponse which contains a conversation id which is suitable for use  in the message payload and REST API uris.    Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:    ```  var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(\"user1\") } );  await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;    ```
         * @summary CreateConversation
         * @param {ConversationParameters} parameters Parameters to create the conversation from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsCreateConversation(parameters, options) {
            return exports.ConversationsApiFp(configuration).conversationsCreateConversation(parameters, options)(fetch, basePath);
        },
        /**
         * Delete an existing activity.    Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
         * @summary DeleteActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsDeleteActivity(conversationId, activityId, options) {
            return exports.ConversationsApiFp(configuration).conversationsDeleteActivity(conversationId, activityId, options)(fetch, basePath);
        },
        /**
         * Deletes a member from a conversation.     This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member  of the conversation, the conversation will also be deleted.
         * @summary DeleteConversationMember
         * @param {string} conversationId Conversation ID
         * @param {string} memberId ID of the member to delete from this conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsDeleteConversationMember(conversationId, memberId, options) {
            return exports.ConversationsApiFp(configuration).conversationsDeleteConversationMember(conversationId, memberId, options)(fetch, basePath);
        },
        /**
         * Enumerate the members of an activity.     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
         * @summary GetActivityMembers
         * @param {string} conversationId Conversation ID
         * @param {string} activityId Activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetActivityMembers(conversationId, activityId, options) {
            return exports.ConversationsApiFp(configuration).conversationsGetActivityMembers(conversationId, activityId, options)(fetch, basePath);
        },
        /**
         * Enumerate the members of a conversation.     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
         * @summary GetConversationMembers
         * @param {string} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversationMembers(conversationId, options) {
            return exports.ConversationsApiFp(configuration).conversationsGetConversationMembers(conversationId, options)(fetch, basePath);
        },
        /**
         * Enumerate the members of a conversation one page at a time.    This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array  of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.    One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as   a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.    A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
         * @summary GetConversationPagedMembers
         * @param {string} conversationId Conversation ID
         * @param {number} [pageSize] Suggested page size
         * @param {string} [continuationToken] Continuation Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversationPagedMembers(conversationId, pageSize, continuationToken, options) {
            return exports.ConversationsApiFp(configuration).conversationsGetConversationPagedMembers(conversationId, pageSize, continuationToken, options)(fetch, basePath);
        },
        /**
         * List the Conversations in which this bot has participated.    GET from this method with a skip token    The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then   there are further values to be returned. Call this method again with the returned token to get more values.    Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
         * @summary GetConversations
         * @param {string} [continuationToken] skip or continuation token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsGetConversations(continuationToken, options) {
            return exports.ConversationsApiFp(configuration).conversationsGetConversations(continuationToken, options)(fetch, basePath);
        },
        /**
         * This method allows you to reply to an activity.    This is slightly different from SendToConversation().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
         * @summary ReplyToActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId the reply is to (OPTIONAL)
         * @param {Activity} activity Activity to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsReplyToActivity(conversationId, activityId, activity, options) {
            return exports.ConversationsApiFp(configuration).conversationsReplyToActivity(conversationId, activityId, activity, options)(fetch, basePath);
        },
        /**
         * This method allows you to upload the historic activities to the conversation.    Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
         * @summary SendConversationHistory
         * @param {string} conversationId Conversation ID
         * @param {Transcript} history Historic activities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsSendConversationHistory(conversationId, history, options) {
            return exports.ConversationsApiFp(configuration).conversationsSendConversationHistory(conversationId, history, options)(fetch, basePath);
        },
        /**
         * This method allows you to send an activity to the end of a conversation.    This is slightly different from ReplyToActivity().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
         * @summary SendToConversation
         * @param {string} conversationId Conversation ID
         * @param {Activity} activity Activity to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsSendToConversation(conversationId, activity, options) {
            return exports.ConversationsApiFp(configuration).conversationsSendToConversation(conversationId, activity, options)(fetch, basePath);
        },
        /**
         * Edit an existing activity.    Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    For example, you can remove buttons after someone has clicked \"Approve\" button.
         * @summary UpdateActivity
         * @param {string} conversationId Conversation ID
         * @param {string} activityId activityId to update
         * @param {Activity} activity replacement Activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsUpdateActivity(conversationId, activityId, activity, options) {
            return exports.ConversationsApiFp(configuration).conversationsUpdateActivity(conversationId, activityId, activity, options)(fetch, basePath);
        },
        /**
         * Upload an attachment directly into a channel's blob storage.    This is useful because it allows you to store data in a compliant store when dealing with enterprises.    The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
         * @summary UploadAttachment
         * @param {string} conversationId Conversation ID
         * @param {AttachmentData} attachmentUpload Attachment data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsUploadAttachment(conversationId, attachmentUpload, options) {
            return exports.ConversationsApiFp(configuration).conversationsUploadAttachment(conversationId, attachmentUpload, options)(fetch, basePath);
        },
    };
};
exports.ConversationsApiFactory = ConversationsApiFactory;
/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
class ConversationsApi extends BaseAPI {
    /**
     * Create a new Conversation.    POST to this method with a  * Bot being the bot creating the conversation  * IsGroup set to true if this is not a direct message (default is false)  * Array containing the members to include in the conversation    The return value is a ResourceResponse which contains a conversation id which is suitable for use  in the message payload and REST API uris.    Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:    ```  var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount(\"user1\") } );  await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;    ```
     * @summary CreateConversation
     * @param {ConversationParameters} parameters Parameters to create the conversation from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsCreateConversation(parameters, options) {
        return exports.ConversationsApiFp(this.configuration).conversationsCreateConversation(parameters, options)(this.fetch, this.basePath);
    }
    /**
     * Delete an existing activity.    Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
     * @summary DeleteActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsDeleteActivity(conversationId, activityId, options) {
        return exports.ConversationsApiFp(this.configuration).conversationsDeleteActivity(conversationId, activityId, options)(this.fetch, this.basePath);
    }
    /**
     * Deletes a member from a conversation.     This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member  of the conversation, the conversation will also be deleted.
     * @summary DeleteConversationMember
     * @param {string} conversationId Conversation ID
     * @param {string} memberId ID of the member to delete from this conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsDeleteConversationMember(conversationId, memberId, options) {
        return exports.ConversationsApiFp(this.configuration).conversationsDeleteConversationMember(conversationId, memberId, options)(this.fetch, this.basePath);
    }
    /**
     * Enumerate the members of an activity.     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     * @summary GetActivityMembers
     * @param {string} conversationId Conversation ID
     * @param {string} activityId Activity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsGetActivityMembers(conversationId, activityId, options) {
        return exports.ConversationsApiFp(this.configuration).conversationsGetActivityMembers(conversationId, activityId, options)(this.fetch, this.basePath);
    }
    /**
     * Enumerate the members of a conversation.     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
     * @summary GetConversationMembers
     * @param {string} conversationId Conversation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsGetConversationMembers(conversationId, options) {
        return exports.ConversationsApiFp(this.configuration).conversationsGetConversationMembers(conversationId, options)(this.fetch, this.basePath);
    }
    /**
     * Enumerate the members of a conversation one page at a time.    This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array  of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.    One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as   a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.    A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
     * @summary GetConversationPagedMembers
     * @param {string} conversationId Conversation ID
     * @param {number} [pageSize] Suggested page size
     * @param {string} [continuationToken] Continuation Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsGetConversationPagedMembers(conversationId, pageSize, continuationToken, options) {
        return exports.ConversationsApiFp(this.configuration).conversationsGetConversationPagedMembers(conversationId, pageSize, continuationToken, options)(this.fetch, this.basePath);
    }
    /**
     * List the Conversations in which this bot has participated.    GET from this method with a skip token    The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then   there are further values to be returned. Call this method again with the returned token to get more values.    Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
     * @summary GetConversations
     * @param {string} [continuationToken] skip or continuation token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsGetConversations(continuationToken, options) {
        return exports.ConversationsApiFp(this.configuration).conversationsGetConversations(continuationToken, options)(this.fetch, this.basePath);
    }
    /**
     * This method allows you to reply to an activity.    This is slightly different from SendToConversation().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary ReplyToActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId the reply is to (OPTIONAL)
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsReplyToActivity(conversationId, activityId, activity, options) {
        return exports.ConversationsApiFp(this.configuration).conversationsReplyToActivity(conversationId, activityId, activity, options)(this.fetch, this.basePath);
    }
    /**
     * This method allows you to upload the historic activities to the conversation.    Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
     * @summary SendConversationHistory
     * @param {string} conversationId Conversation ID
     * @param {Transcript} history Historic activities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsSendConversationHistory(conversationId, history, options) {
        return exports.ConversationsApiFp(this.configuration).conversationsSendConversationHistory(conversationId, history, options)(this.fetch, this.basePath);
    }
    /**
     * This method allows you to send an activity to the end of a conversation.    This is slightly different from ReplyToActivity().  * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    Use ReplyToActivity when replying to a specific activity in the conversation.    Use SendToConversation in all other cases.
     * @summary SendToConversation
     * @param {string} conversationId Conversation ID
     * @param {Activity} activity Activity to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsSendToConversation(conversationId, activity, options) {
        return exports.ConversationsApiFp(this.configuration).conversationsSendToConversation(conversationId, activity, options)(this.fetch, this.basePath);
    }
    /**
     * Edit an existing activity.    Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    For example, you can remove buttons after someone has clicked \"Approve\" button.
     * @summary UpdateActivity
     * @param {string} conversationId Conversation ID
     * @param {string} activityId activityId to update
     * @param {Activity} activity replacement Activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsUpdateActivity(conversationId, activityId, activity, options) {
        return exports.ConversationsApiFp(this.configuration).conversationsUpdateActivity(conversationId, activityId, activity, options)(this.fetch, this.basePath);
    }
    /**
     * Upload an attachment directly into a channel's blob storage.    This is useful because it allows you to store data in a compliant store when dealing with enterprises.    The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
     * @summary UploadAttachment
     * @param {string} conversationId Conversation ID
     * @param {AttachmentData} attachmentUpload Attachment data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    conversationsUploadAttachment(conversationId, attachmentUpload, options) {
        return exports.ConversationsApiFp(this.configuration).conversationsUploadAttachment(conversationId, attachmentUpload, options)(this.fetch, this.basePath);
    }
}
exports.ConversationsApi = ConversationsApi;
//# sourceMappingURL=api.js.map

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable
/**
 * Microsoft Bot Connector API - v3.0
 * The Bot Connector REST API allows your bot to send and receive messages to channels configured in the  [Bot Framework Developer Portal](https://dev.botframework.com). The Connector service uses industry-standard REST  and JSON over HTTPS.    Client libraries for this REST API are available. See below for a list.    Many bots will use both the Bot Connector REST API and the associated [Bot State REST API](/en-us/restapi/state). The  Bot State REST API allows a bot to store and retrieve state associated with users and conversations.    Authentication for both the Bot Connector and Bot State REST APIs is accomplished with JWT Bearer tokens, and is  described in detail in the [Connector Authentication](/en-us/restapi/authentication) document.    # Client Libraries for the Bot Connector REST API    * [Bot Builder for C#](/en-us/csharp/builder/sdkreference/)  * [Bot Builder for Node.js](/en-us/node/builder/overview/)  * Generate your own from the [Connector API Swagger file](https://raw.githubusercontent.com/Microsoft/BotBuilder/master/CSharp/Library/Microsoft.Bot.Connector.Shared/Swagger/ConnectorAPI.json)    Â© 2016 Microsoft
 *
 * OpenAPI spec version: v3
 * Contact: botframework@microsoft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Configuration = void 0;
class Configuration {
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
    }
}
exports.Configuration = Configuration;
//# sourceMappingURL=configuration.js.map

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

/*global module*/
var Buffer = __webpack_require__(57).Buffer;
var DataStream = __webpack_require__(137);
var jwa = __webpack_require__(142);
var Stream = __webpack_require__(67);
var toString = __webpack_require__(191);
var util = __webpack_require__(69);

function base64url(string, encoding) {
  return Buffer
    .from(string, encoding)
    .toString('base64')
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');
}

function jwsSecuredInput(header, payload, encoding) {
  encoding = encoding || 'utf8';
  var encodedHeader = base64url(toString(header), 'binary');
  var encodedPayload = base64url(toString(payload), encoding);
  return util.format('%s.%s', encodedHeader, encodedPayload);
}

function jwsSign(opts) {
  var header = opts.header;
  var payload = opts.payload;
  var secretOrKey = opts.secret || opts.privateKey;
  var encoding = opts.encoding;
  var algo = jwa(header.alg);
  var securedInput = jwsSecuredInput(header, payload, encoding);
  var signature = algo.sign(securedInput, secretOrKey);
  return util.format('%s.%s', securedInput, signature);
}

function SignStream(opts) {
  var secret = opts.secret||opts.privateKey||opts.key;
  var secretStream = new DataStream(secret);
  this.readable = true;
  this.header = opts.header;
  this.encoding = opts.encoding;
  this.secret = this.privateKey = this.key = secretStream;
  this.payload = new DataStream(opts.payload);
  this.secret.once('close', function () {
    if (!this.payload.writable && this.readable)
      this.sign();
  }.bind(this));

  this.payload.once('close', function () {
    if (!this.secret.writable && this.readable)
      this.sign();
  }.bind(this));
}
util.inherits(SignStream, Stream);

SignStream.prototype.sign = function sign() {
  try {
    var signature = jwsSign({
      header: this.header,
      payload: this.payload.buffer,
      secret: this.secret.buffer,
      encoding: this.encoding
    });
    this.emit('done', signature);
    this.emit('data', signature);
    this.emit('end');
    this.readable = false;
    return signature;
  } catch (e) {
    this.readable = false;
    this.emit('error', e);
    this.emit('close');
  }
};

SignStream.sign = jwsSign;

module.exports = SignStream;


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 233 */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 234 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(6).Buffer;
var util = __webpack_require__(236);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),
/* 236 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(238);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16)))

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6â8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16), __webpack_require__(10)))

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(141);

/*<replacement>*/
var util = Object.create(__webpack_require__(58));
util.inherits = __webpack_require__(3);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(89);


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(38);


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(88).Transform


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(88).PassThrough


/***/ }),
/* 244 */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),
/* 245 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*jshint node:true */

var Buffer = __webpack_require__(9).Buffer; // browserify
var SlowBuffer = __webpack_require__(9).SlowBuffer;

module.exports = bufferEq;

function bufferEq(a, b) {

  // shortcutting on type is necessary for correctness
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    return false;
  }

  // buffer sizes should be well-known information, so despite this
  // shortcutting, it doesn't leak any information about the *contents* of the
  // buffers.
  if (a.length !== b.length) {
    return false;
  }

  var c = 0;
  for (var i = 0; i < a.length; i++) {
    /*jshint bitwise:false */
    c |= a[i] ^ b[i]; // XOR
  }
  return c === 0;
}

bufferEq.install = function() {
  Buffer.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
    return bufferEq(this, that);
  };
};

var origBufEqual = Buffer.prototype.equal;
var origSlowBufEqual = SlowBuffer.prototype.equal;
bufferEq.restore = function() {
  Buffer.prototype.equal = origBufEqual;
  SlowBuffer.prototype.equal = origSlowBufEqual;
};


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(42)
exports.createHash = exports.Hash = __webpack_require__(59)
exports.createHmac = exports.Hmac = __webpack_require__(152)

var algos = __webpack_require__(262)
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = __webpack_require__(155)
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = __webpack_require__(264)

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = __webpack_require__(279)

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = __webpack_require__(286)

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = __webpack_require__(327)

var publicEncrypt = __webpack_require__(330)

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = __webpack_require__(334)

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(9)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(144);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(148);
exports.Duplex = __webpack_require__(44);
exports.Transform = __webpack_require__(149);
exports.PassThrough = __webpack_require__(255);
exports.finished = __webpack_require__(92);
exports.pipeline = __webpack_require__(256);


/***/ }),
/* 250 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(9),
    Buffer = _require.Buffer;

var _require2 = __webpack_require__(252),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

/***/ }),
/* 252 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = __webpack_require__(92);

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 254 */
/***/ (function(module, exports) {

module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(149);

__webpack_require__(3)(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).


var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = __webpack_require__(43).codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(92);
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(3)
var Hash = __webpack_require__(45)
var Buffer = __webpack_require__(6).Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(3)
var Hash = __webpack_require__(45)
var Buffer = __webpack_require__(6).Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(3)
var Sha256 = __webpack_require__(150)
var Hash = __webpack_require__(45)
var Buffer = __webpack_require__(6).Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(3)
var SHA512 = __webpack_require__(151)
var Hash = __webpack_require__(45)
var Buffer = __webpack_require__(6).Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(3)
var Buffer = __webpack_require__(6).Buffer

var Base = __webpack_require__(35)

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(154)


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {var Buffer = __webpack_require__(6).Buffer

var checkParameters = __webpack_require__(156)
var defaultEncoding = __webpack_require__(157)
var sync = __webpack_require__(158)
var toBuffer = __webpack_require__(159)

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  sha: 'SHA-1',
  'sha-1': 'SHA-1',
  sha1: 'SHA-1',
  sha256: 'SHA-256',
  'sha-256': 'SHA-256',
  sha384: 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  sha512: 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}

function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, { name: 'PBKDF2' }, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    process.nextTick(function () {
      callback(null, out)
    })
  }, function (e) {
    process.nextTick(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof global.Promise !== 'function') {
    return process.nextTick(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
  }

  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16), __webpack_require__(10)))

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var DES = __webpack_require__(265)
var aes = __webpack_require__(96)
var aesModes = __webpack_require__(97)
var desModes = __webpack_require__(278)
var ebtk = __webpack_require__(71)

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

var CipherBase = __webpack_require__(35)
var des = __webpack_require__(266)
var inherits = __webpack_require__(3)
var Buffer = __webpack_require__(6).Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.utils = __webpack_require__(160);
exports.Cipher = __webpack_require__(95);
exports.DES = __webpack_require__(161);
exports.CBC = __webpack_require__(267);
exports.EDE = __webpack_require__(268);


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(23);
var inherits = __webpack_require__(3);

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(23);
var inherits = __webpack_require__(3);

var Cipher = __webpack_require__(95);
var DES = __webpack_require__(161);

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

var MODES = __webpack_require__(97)
var AuthCipher = __webpack_require__(165)
var Buffer = __webpack_require__(6).Buffer
var StreamCipher = __webpack_require__(166)
var Transform = __webpack_require__(35)
var aes = __webpack_require__(70)
var ebtk = __webpack_require__(71)
var inherits = __webpack_require__(3)

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher


/***/ }),
/* 270 */
/***/ (function(module, exports) {

exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(60)

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(6).Buffer
var xor = __webpack_require__(60)

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(6).Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(6).Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(60)

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(6).Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho VÃ¤hÃ¤-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

var AuthCipher = __webpack_require__(165)
var Buffer = __webpack_require__(6).Buffer
var MODES = __webpack_require__(97)
var StreamCipher = __webpack_require__(166)
var Transform = __webpack_require__(35)
var aes = __webpack_require__(70)
var ebtk = __webpack_require__(71)
var inherits = __webpack_require__(3)

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv


/***/ }),
/* 278 */
/***/ (function(module, exports) {

exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var generatePrime = __webpack_require__(167)
var primes = __webpack_require__(284)

var DH = __webpack_require__(285)

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 280 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(282).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)(module)))

/***/ }),
/* 282 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 283 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 284 */
/***/ (function(module) {

module.exports = {"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}};

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(168);
var MillerRabin = __webpack_require__(169);
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = __webpack_require__(167);
var randomBytes = __webpack_require__(42);
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(99).Buffer
var createHash = __webpack_require__(59)
var stream = __webpack_require__(287)
var inherits = __webpack_require__(3)
var sign = __webpack_require__(295)
var verify = __webpack_require__(326)

var algorithms = __webpack_require__(154)
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = Buffer.from(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = Buffer.from(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(170);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(174);
exports.Duplex = __webpack_require__(47);
exports.Transform = __webpack_require__(175);
exports.PassThrough = __webpack_require__(293);
exports.finished = __webpack_require__(100);
exports.pipeline = __webpack_require__(294);


/***/ }),
/* 288 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(9),
    Buffer = _require.Buffer;

var _require2 = __webpack_require__(290),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

/***/ }),
/* 290 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = __webpack_require__(100);

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 292 */
/***/ (function(module, exports) {

module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(175);

__webpack_require__(3)(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).


var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = __webpack_require__(46).codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(100);
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = __webpack_require__(99).Buffer
var createHmac = __webpack_require__(152)
var crt = __webpack_require__(101)
var EC = __webpack_require__(103).ec
var BN = __webpack_require__(102)
var parseKeys = __webpack_require__(73)
var curves = __webpack_require__(187)

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [0, 1]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return Buffer.from(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [0].concat(r)
  if (s[0] & 0x80) s = [0].concat(s)

  var total = r.length + s.length + 4
  var res = [0x30, total, 0x02, r.length]
  res = res.concat(r, [0x02, s.length], s)
  return Buffer.from(res)
}

function getKey (x, q, hash, algo) {
  x = Buffer.from(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - x.length)
    x = Buffer.concat([zeros, x])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = Buffer.alloc(hlen)
  v.fill(1)
  var k = Buffer.alloc(hlen)
  k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = Buffer.from(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - out.length)
    out = Buffer.concat([zeros, out])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = Buffer.alloc(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([t, kv.v])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey


/***/ }),
/* 296 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 297 */
/***/ (function(module) {

module.exports = {"_from":"elliptic@^6.5.3","_id":"elliptic@6.5.4","_inBundle":false,"_integrity":"sha512-iLhC6ULemrljPZb+QutR5TQGB+pdW6KGD5RSegS+8sorOZT+rdQFbsQFJgvN3eRqNALqJer4oQ16YvJHlU8hzQ==","_location":"/elliptic","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"elliptic@^6.5.3","name":"elliptic","escapedName":"elliptic","rawSpec":"^6.5.3","saveSpec":null,"fetchSpec":"^6.5.3"},"_requiredBy":["/browserify-sign","/create-ecdh"],"_resolved":"https://registry.npmjs.org/elliptic/-/elliptic-6.5.4.tgz","_shasum":"da37cebd31e79a1367e941b592ed1fbebd58abbb","_spec":"elliptic@^6.5.3","_where":"/Users/guy/Library/Caches/.wrangler/wranglerjs-1.13.0/node_modules/browserify-sign","author":{"name":"Fedor Indutny","email":"fedor@indutny.com"},"bugs":{"url":"https://github.com/indutny/elliptic/issues"},"bundleDependencies":false,"dependencies":{"bn.js":"^4.11.9","brorand":"^1.1.0","hash.js":"^1.0.0","hmac-drbg":"^1.0.1","inherits":"^2.0.4","minimalistic-assert":"^1.0.1","minimalistic-crypto-utils":"^1.0.1"},"deprecated":false,"description":"EC cryptography","devDependencies":{"brfs":"^2.0.2","coveralls":"^3.1.0","eslint":"^7.6.0","grunt":"^1.2.1","grunt-browserify":"^5.3.0","grunt-cli":"^1.3.2","grunt-contrib-connect":"^3.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^5.0.0","grunt-mocha-istanbul":"^5.0.2","grunt-saucelabs":"^9.0.1","istanbul":"^0.4.5","mocha":"^8.0.1"},"files":["lib"],"homepage":"https://github.com/indutny/elliptic","keywords":["EC","Elliptic","curve","Cryptography"],"license":"MIT","main":"lib/elliptic.js","name":"elliptic","repository":{"type":"git","url":"git+ssh://git@github.com/indutny/elliptic.git"},"scripts":{"lint":"eslint lib test","lint:fix":"npm run lint -- --fix","test":"npm run lint && npm run unit","unit":"istanbul test _mocha --reporter=spec test/index.js","version":"grunt dist && git add dist/"},"version":"6.5.4"};

/***/ }),
/* 298 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(24);
var BN = __webpack_require__(30);
var inherits = __webpack_require__(3);
var Base = __webpack_require__(72);

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(30);
var inherits = __webpack_require__(3);
var Base = __webpack_require__(72);

var utils = __webpack_require__(24);

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(24);
var BN = __webpack_require__(30);
var inherits = __webpack_require__(3);
var Base = __webpack_require__(72);

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.sha1 = __webpack_require__(303);
exports.sha224 = __webpack_require__(304);
exports.sha256 = __webpack_require__(179);
exports.sha384 = __webpack_require__(305);
exports.sha512 = __webpack_require__(180);


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(27);
var common = __webpack_require__(61);
var shaCommon = __webpack_require__(178);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(27);
var SHA256 = __webpack_require__(179);

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(27);

var SHA512 = __webpack_require__(180);

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(27);
var common = __webpack_require__(61);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(27);
var assert = __webpack_require__(23);

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),
/* 308 */
/***/ (function(module, exports) {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(30);
var HmacDRBG = __webpack_require__(310);
var utils = __webpack_require__(24);
var curves = __webpack_require__(104);
var rand = __webpack_require__(98);
var assert = utils.assert;

var KeyPair = __webpack_require__(311);
var Signature = __webpack_require__(312);

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(105);
var utils = __webpack_require__(176);
var assert = __webpack_require__(23);

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(30);
var utils = __webpack_require__(24);
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(30);

var utils = __webpack_require__(24);
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(105);
var curves = __webpack_require__(104);
var utils = __webpack_require__(24);
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(314);
var Signature = __webpack_require__(315);

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(24);
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(30);
var utils = __webpack_require__(24);
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.


var asn1 = __webpack_require__(181)

exports.certificate = __webpack_require__(323)

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})


/***/ }),
/* 317 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const encoders = __webpack_require__(183);
const decoders = __webpack_require__(185);
const inherits = __webpack_require__(3);

const api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
}

Entity.prototype._createNamed = function createNamed(Base) {
  const name = this.name;

  function Generated(entity) {
    this._initNamed(entity, name);
  }
  inherits(Generated, Base);
  Generated.prototype._initNamed = function _initNamed(entity, name) {
    Base.call(this, entity, name);
  };

  return new Generated(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const inherits = __webpack_require__(3);

const DEREncoder = __webpack_require__(184);

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
}
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  const buf = DEREncoder.prototype.encode.call(this, data);

  const p = buf.toString('base64');
  const out = [ '-----BEGIN ' + options.label + '-----' ];
  for (let i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const inherits = __webpack_require__(3);
const Buffer = __webpack_require__(106).Buffer;

const DERDecoder = __webpack_require__(186);

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
}
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  const lines = data.toString().split(/[\r\n]+/g);

  const label = options.label.toUpperCase();

  const re = /^-----(BEGIN|END) ([^-]+)-----$/;
  let start = -1;
  let end = -1;
  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  const base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9+/=]+/gi, '');

  const input = Buffer.from(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const base = exports;

base.Reporter = __webpack_require__(108).Reporter;
base.DecoderBuffer = __webpack_require__(62).DecoderBuffer;
base.EncoderBuffer = __webpack_require__(62).EncoderBuffer;
base.Node = __webpack_require__(107);


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const constants = exports;

// Helper
constants._reverse = function reverse(map) {
  const res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    const value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = __webpack_require__(109);


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen



var asn = __webpack_require__(181)

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional(),
    this.key('curve').objid().optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int().optional(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate


/***/ }),
/* 324 */
/***/ (function(module) {

module.exports = {"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"};

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m
var evp = __webpack_require__(71)
var ciphers = __webpack_require__(96)
var Buffer = __webpack_require__(6).Buffer
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = Buffer.from(match[2], 'hex')
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = __webpack_require__(99).Buffer
var BN = __webpack_require__(102)
var EC = __webpack_require__(103).ec
var parseKeys = __webpack_require__(73)
var curves = __webpack_require__(187)

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [1]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = Buffer.from(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = Buffer.from(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify


/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var elliptic = __webpack_require__(103)
var BN = __webpack_require__(328)

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(329).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)(module)))

/***/ }),
/* 329 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

exports.publicEncrypt = __webpack_require__(331)
exports.privateDecrypt = __webpack_require__(333)

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(73)
var randomBytes = __webpack_require__(42)
var createHash = __webpack_require__(59)
var mgf = __webpack_require__(188)
var xor = __webpack_require__(189)
var BN = __webpack_require__(110)
var withPublic = __webpack_require__(190)
var crt = __webpack_require__(101)
var Buffer = __webpack_require__(6).Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}


/***/ }),
/* 332 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(73)
var mgf = __webpack_require__(188)
var xor = __webpack_require__(189)
var BN = __webpack_require__(110)
var crt = __webpack_require__(101)
var createHash = __webpack_require__(59)
var withPublic = __webpack_require__(190)
var Buffer = __webpack_require__(6).Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = __webpack_require__(6)
var randombytes = __webpack_require__(42)
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = global.crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16), __webpack_require__(10)))

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Buffer = __webpack_require__(57).Buffer;

var getParamBytesForAlg = __webpack_require__(336);

var MAX_OCTET = 0x80,
	CLASS_UNIVERSAL = 0,
	PRIMITIVE_BIT = 0x20,
	TAG_SEQ = 0x10,
	TAG_INT = 0x02,
	ENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),
	ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);

function base64Url(base64) {
	return base64
		.replace(/=/g, '')
		.replace(/\+/g, '-')
		.replace(/\//g, '_');
}

function signatureAsBuffer(signature) {
	if (Buffer.isBuffer(signature)) {
		return signature;
	} else if ('string' === typeof signature) {
		return Buffer.from(signature, 'base64');
	}

	throw new TypeError('ECDSA signature must be a Base64 string or a Buffer');
}

function derToJose(signature, alg) {
	signature = signatureAsBuffer(signature);
	var paramBytes = getParamBytesForAlg(alg);

	// the DER encoded param should at most be the param size, plus a padding
	// zero, since due to being a signed integer
	var maxEncodedParamLength = paramBytes + 1;

	var inputLength = signature.length;

	var offset = 0;
	if (signature[offset++] !== ENCODED_TAG_SEQ) {
		throw new Error('Could not find expected "seq"');
	}

	var seqLength = signature[offset++];
	if (seqLength === (MAX_OCTET | 1)) {
		seqLength = signature[offset++];
	}

	if (inputLength - offset < seqLength) {
		throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
	}

	if (signature[offset++] !== ENCODED_TAG_INT) {
		throw new Error('Could not find expected "int" for "r"');
	}

	var rLength = signature[offset++];

	if (inputLength - offset - 2 < rLength) {
		throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
	}

	if (maxEncodedParamLength < rLength) {
		throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
	}

	var rOffset = offset;
	offset += rLength;

	if (signature[offset++] !== ENCODED_TAG_INT) {
		throw new Error('Could not find expected "int" for "s"');
	}

	var sLength = signature[offset++];

	if (inputLength - offset !== sLength) {
		throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
	}

	if (maxEncodedParamLength < sLength) {
		throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
	}

	var sOffset = offset;
	offset += sLength;

	if (offset !== inputLength) {
		throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
	}

	var rPadding = paramBytes - rLength,
		sPadding = paramBytes - sLength;

	var dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);

	for (offset = 0; offset < rPadding; ++offset) {
		dst[offset] = 0;
	}
	signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);

	offset = paramBytes;

	for (var o = offset; offset < o + sPadding; ++offset) {
		dst[offset] = 0;
	}
	signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);

	dst = dst.toString('base64');
	dst = base64Url(dst);

	return dst;
}

function countPadding(buf, start, stop) {
	var padding = 0;
	while (start + padding < stop && buf[start + padding] === 0) {
		++padding;
	}

	var needsSign = buf[start + padding] >= MAX_OCTET;
	if (needsSign) {
		--padding;
	}

	return padding;
}

function joseToDer(signature, alg) {
	signature = signatureAsBuffer(signature);
	var paramBytes = getParamBytesForAlg(alg);

	var signatureBytes = signature.length;
	if (signatureBytes !== paramBytes * 2) {
		throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
	}

	var rPadding = countPadding(signature, 0, paramBytes);
	var sPadding = countPadding(signature, paramBytes, signature.length);
	var rLength = paramBytes - rPadding;
	var sLength = paramBytes - sPadding;

	var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;

	var shortLength = rsBytes < MAX_OCTET;

	var dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);

	var offset = 0;
	dst[offset++] = ENCODED_TAG_SEQ;
	if (shortLength) {
		// Bit 8 has value "0"
		// bits 7-1 give the length.
		dst[offset++] = rsBytes;
	} else {
		// Bit 8 of first octet has value "1"
		// bits 7-1 give the number of additional length octets.
		dst[offset++] = MAX_OCTET	| 1;
		// length, base 256
		dst[offset++] = rsBytes & 0xff;
	}
	dst[offset++] = ENCODED_TAG_INT;
	dst[offset++] = rLength;
	if (rPadding < 0) {
		dst[offset++] = 0;
		offset += signature.copy(dst, offset, 0, paramBytes);
	} else {
		offset += signature.copy(dst, offset, rPadding, paramBytes);
	}
	dst[offset++] = ENCODED_TAG_INT;
	dst[offset++] = sLength;
	if (sPadding < 0) {
		dst[offset++] = 0;
		signature.copy(dst, offset, paramBytes);
	} else {
		signature.copy(dst, offset, paramBytes + sPadding);
	}

	return dst;
}

module.exports = {
	derToJose: derToJose,
	joseToDer: joseToDer
};


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getParamSize(keySize) {
	var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
	return result;
}

var paramBytesForAlg = {
	ES256: getParamSize(256),
	ES384: getParamSize(384),
	ES512: getParamSize(521)
};

function getParamBytesForAlg(alg) {
	var paramBytes = paramBytesForAlg[alg];
	if (paramBytes) {
		return paramBytes;
	}

	throw new Error('Unknown algorithm "' + alg + '"');
}

module.exports = getParamBytesForAlg;


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

/*global module*/
var Buffer = __webpack_require__(57).Buffer;
var DataStream = __webpack_require__(137);
var jwa = __webpack_require__(142);
var Stream = __webpack_require__(67);
var toString = __webpack_require__(191);
var util = __webpack_require__(69);
var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;

function isObject(thing) {
  return Object.prototype.toString.call(thing) === '[object Object]';
}

function safeJsonParse(thing) {
  if (isObject(thing))
    return thing;
  try { return JSON.parse(thing); }
  catch (e) { return undefined; }
}

function headerFromJWS(jwsSig) {
  var encodedHeader = jwsSig.split('.', 1)[0];
  return safeJsonParse(Buffer.from(encodedHeader, 'base64').toString('binary'));
}

function securedInputFromJWS(jwsSig) {
  return jwsSig.split('.', 2).join('.');
}

function signatureFromJWS(jwsSig) {
  return jwsSig.split('.')[2];
}

function payloadFromJWS(jwsSig, encoding) {
  encoding = encoding || 'utf8';
  var payload = jwsSig.split('.')[1];
  return Buffer.from(payload, 'base64').toString(encoding);
}

function isValidJws(string) {
  return JWS_REGEX.test(string) && !!headerFromJWS(string);
}

function jwsVerify(jwsSig, algorithm, secretOrKey) {
  if (!algorithm) {
    var err = new Error("Missing algorithm parameter for jws.verify");
    err.code = "MISSING_ALGORITHM";
    throw err;
  }
  jwsSig = toString(jwsSig);
  var signature = signatureFromJWS(jwsSig);
  var securedInput = securedInputFromJWS(jwsSig);
  var algo = jwa(algorithm);
  return algo.verify(securedInput, signature, secretOrKey);
}

function jwsDecode(jwsSig, opts) {
  opts = opts || {};
  jwsSig = toString(jwsSig);

  if (!isValidJws(jwsSig))
    return null;

  var header = headerFromJWS(jwsSig);

  if (!header)
    return null;

  var payload = payloadFromJWS(jwsSig);
  if (header.typ === 'JWT' || opts.json)
    payload = JSON.parse(payload, opts.encoding);

  return {
    header: header,
    payload: payload,
    signature: signatureFromJWS(jwsSig)
  };
}

function VerifyStream(opts) {
  opts = opts || {};
  var secretOrKey = opts.secret||opts.publicKey||opts.key;
  var secretStream = new DataStream(secretOrKey);
  this.readable = true;
  this.algorithm = opts.algorithm;
  this.encoding = opts.encoding;
  this.secret = this.publicKey = this.key = secretStream;
  this.signature = new DataStream(opts.signature);
  this.secret.once('close', function () {
    if (!this.signature.writable && this.readable)
      this.verify();
  }.bind(this));

  this.signature.once('close', function () {
    if (!this.secret.writable && this.readable)
      this.verify();
  }.bind(this));
}
util.inherits(VerifyStream, Stream);
VerifyStream.prototype.verify = function verify() {
  try {
    var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
    var obj = jwsDecode(this.signature.buffer, this.encoding);
    this.emit('done', valid, obj);
    this.emit('data', valid);
    this.emit('end');
    this.readable = false;
    return valid;
  } catch (e) {
    this.readable = false;
    this.emit('error', e);
    this.emit('close');
  }
};

VerifyStream.decode = jwsDecode;
VerifyStream.isValid = isValidJws;
VerifyStream.verify = jwsVerify;

module.exports = VerifyStream;


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

var JsonWebTokenError = __webpack_require__(74);
var NotBeforeError    = __webpack_require__(192);
var TokenExpiredError = __webpack_require__(193);
var decode            = __webpack_require__(135);
var timespan          = __webpack_require__(194);
var PS_SUPPORTED      = __webpack_require__(195);
var jws               = __webpack_require__(87);

var PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512'];
var RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
var HS_ALGS = ['HS256', 'HS384', 'HS512'];

if (PS_SUPPORTED) {
  PUB_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
  RSA_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
}

module.exports = function (jwtString, secretOrPublicKey, options, callback) {
  if ((typeof options === 'function') && !callback) {
    callback = options;
    options = {};
  }

  if (!options) {
    options = {};
  }

  //clone this object since we are going to mutate it.
  options = Object.assign({}, options);

  var done;

  if (callback) {
    done = callback;
  } else {
    done = function(err, data) {
      if (err) throw err;
      return data;
    };
  }

  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {
    return done(new JsonWebTokenError('clockTimestamp must be a number'));
  }

  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {
    return done(new JsonWebTokenError('nonce must be a non-empty string'));
  }

  var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);

  if (!jwtString){
    return done(new JsonWebTokenError('jwt must be provided'));
  }

  if (typeof jwtString !== 'string') {
    return done(new JsonWebTokenError('jwt must be a string'));
  }

  var parts = jwtString.split('.');

  if (parts.length !== 3){
    return done(new JsonWebTokenError('jwt malformed'));
  }

  var decodedToken;

  try {
    decodedToken = decode(jwtString, { complete: true });
  } catch(err) {
    return done(err);
  }

  if (!decodedToken) {
    return done(new JsonWebTokenError('invalid token'));
  }

  var header = decodedToken.header;
  var getSecret;

  if(typeof secretOrPublicKey === 'function') {
    if(!callback) {
      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));
    }

    getSecret = secretOrPublicKey;
  }
  else {
    getSecret = function(header, secretCallback) {
      return secretCallback(null, secretOrPublicKey);
    };
  }

  return getSecret(header, function(err, secretOrPublicKey) {
    if(err) {
      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));
    }

    var hasSignature = parts[2].trim() !== '';

    if (!hasSignature && secretOrPublicKey){
      return done(new JsonWebTokenError('jwt signature is required'));
    }

    if (hasSignature && !secretOrPublicKey) {
      return done(new JsonWebTokenError('secret or public key must be provided'));
    }

    if (!hasSignature && !options.algorithms) {
      options.algorithms = ['none'];
    }

    if (!options.algorithms) {
      options.algorithms = ~secretOrPublicKey.toString().indexOf('BEGIN CERTIFICATE') ||
        ~secretOrPublicKey.toString().indexOf('BEGIN PUBLIC KEY') ? PUB_KEY_ALGS :
        ~secretOrPublicKey.toString().indexOf('BEGIN RSA PUBLIC KEY') ? RSA_KEY_ALGS : HS_ALGS;

    }

    if (!~options.algorithms.indexOf(decodedToken.header.alg)) {
      return done(new JsonWebTokenError('invalid algorithm'));
    }

    var valid;

    try {
      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);
    } catch (e) {
      return done(e);
    }

    if (!valid) {
      return done(new JsonWebTokenError('invalid signature'));
    }

    var payload = decodedToken.payload;

    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {
      if (typeof payload.nbf !== 'number') {
        return done(new JsonWebTokenError('invalid nbf value'));
      }
      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));
      }
    }

    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {
      if (typeof payload.exp !== 'number') {
        return done(new JsonWebTokenError('invalid exp value'));
      }
      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));
      }
    }

    if (options.audience) {
      var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
      var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];

      var match = target.some(function (targetAudience) {
        return audiences.some(function (audience) {
          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
        });
      });

      if (!match) {
        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));
      }
    }

    if (options.issuer) {
      var invalid_issuer =
              (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||
              (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);

      if (invalid_issuer) {
        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));
      }
    }

    if (options.subject) {
      if (payload.sub !== options.subject) {
        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));
      }
    }

    if (options.jwtid) {
      if (payload.jti !== options.jwtid) {
        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));
      }
    }

    if (options.nonce) {
      if (payload.nonce !== options.nonce) {
        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));
      }
    }

    if (options.maxAge) {
      if (typeof payload.iat !== 'number') {
        return done(new JsonWebTokenError('iat required when maxAge is specified'));
      }

      var maxAgeTimestamp = timespan(options.maxAge, payload.iat);
      if (typeof maxAgeTimestamp === 'undefined') {
        return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));
      }
    }

    if (options.complete === true) {
      var signature = decodedToken.signature;

      return done(null, {
        header: header,
        payload: payload,
        signature: signature
      });
    }

    return done(null, payload);
  });
};


/***/ }),
/* 339 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var timespan = __webpack_require__(194);
var PS_SUPPORTED = __webpack_require__(195);
var jws = __webpack_require__(87);
var includes = __webpack_require__(342);
var isBoolean = __webpack_require__(343);
var isInteger = __webpack_require__(344);
var isNumber = __webpack_require__(345);
var isPlainObject = __webpack_require__(346);
var isString = __webpack_require__(347);
var once = __webpack_require__(348);

var SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none']
if (PS_SUPPORTED) {
  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
}

var sign_options_schema = {
  expiresIn: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
  notBefore: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
  audience: { isValid: function(value) { return isString(value) || Array.isArray(value); }, message: '"audience" must be a string or array' },
  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
  header: { isValid: isPlainObject, message: '"header" must be an object' },
  encoding: { isValid: isString, message: '"encoding" must be a string' },
  issuer: { isValid: isString, message: '"issuer" must be a string' },
  subject: { isValid: isString, message: '"subject" must be a string' },
  jwtid: { isValid: isString, message: '"jwtid" must be a string' },
  noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
  keyid: { isValid: isString, message: '"keyid" must be a string' },
  mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' }
};

var registered_claims_schema = {
  iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
  exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
  nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
};

function validate(schema, allowUnknown, object, parameterName) {
  if (!isPlainObject(object)) {
    throw new Error('Expected "' + parameterName + '" to be a plain object.');
  }
  Object.keys(object)
    .forEach(function(key) {
      var validator = schema[key];
      if (!validator) {
        if (!allowUnknown) {
          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
        }
        return;
      }
      if (!validator.isValid(object[key])) {
        throw new Error(validator.message);
      }
    });
}

function validateOptions(options) {
  return validate(sign_options_schema, false, options, 'options');
}

function validatePayload(payload) {
  return validate(registered_claims_schema, true, payload, 'payload');
}

var options_to_payload = {
  'audience': 'aud',
  'issuer': 'iss',
  'subject': 'sub',
  'jwtid': 'jti'
};

var options_for_objects = [
  'expiresIn',
  'notBefore',
  'noTimestamp',
  'audience',
  'issuer',
  'subject',
  'jwtid',
];

module.exports = function (payload, secretOrPrivateKey, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  } else {
    options = options || {};
  }

  var isObjectPayload = typeof payload === 'object' &&
                        !Buffer.isBuffer(payload);

  var header = Object.assign({
    alg: options.algorithm || 'HS256',
    typ: isObjectPayload ? 'JWT' : undefined,
    kid: options.keyid
  }, options.header);

  function failure(err) {
    if (callback) {
      return callback(err);
    }
    throw err;
  }

  if (!secretOrPrivateKey && options.algorithm !== 'none') {
    return failure(new Error('secretOrPrivateKey must have a value'));
  }

  if (typeof payload === 'undefined') {
    return failure(new Error('payload is required'));
  } else if (isObjectPayload) {
    try {
      validatePayload(payload);
    }
    catch (error) {
      return failure(error);
    }
    if (!options.mutatePayload) {
      payload = Object.assign({},payload);
    }
  } else {
    var invalid_options = options_for_objects.filter(function (opt) {
      return typeof options[opt] !== 'undefined';
    });

    if (invalid_options.length > 0) {
      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));
    }
  }

  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {
    return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  }

  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {
    return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  }

  try {
    validateOptions(options);
  }
  catch (error) {
    return failure(error);
  }

  var timestamp = payload.iat || Math.floor(Date.now() / 1000);

  if (options.noTimestamp) {
    delete payload.iat;
  } else if (isObjectPayload) {
    payload.iat = timestamp;
  }

  if (typeof options.notBefore !== 'undefined') {
    try {
      payload.nbf = timespan(options.notBefore, timestamp);
    }
    catch (err) {
      return failure(err);
    }
    if (typeof payload.nbf === 'undefined') {
      return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }

  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {
    try {
      payload.exp = timespan(options.expiresIn, timestamp);
    }
    catch (err) {
      return failure(err);
    }
    if (typeof payload.exp === 'undefined') {
      return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }

  Object.keys(options_to_payload).forEach(function (key) {
    var claim = options_to_payload[key];
    if (typeof options[key] !== 'undefined') {
      if (typeof payload[claim] !== 'undefined') {
        return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
      }
      payload[claim] = options[key];
    }
  });

  var encoding = options.encoding || 'utf8';

  if (typeof callback === 'function') {
    callback = callback && once(callback);

    jws.createSign({
      header: header,
      privateKey: secretOrPrivateKey,
      payload: payload,
      encoding: encoding
    }).once('error', callback)
      .once('done', function (signature) {
        callback(null, signature);
      });
  } else {
    return jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 342 */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object ? baseValues(object, keys(object)) : [];
}

module.exports = includes;


/***/ }),
/* 343 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var boolTag = '[object Boolean]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean(value) {
  return value === true || value === false ||
    (isObjectLike(value) && objectToString.call(value) == boolTag);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isBoolean;


/***/ }),
/* 344 */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is an integer.
 *
 * **Note:** This method is based on
 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
 * @example
 *
 * _.isInteger(3);
 * // => true
 *
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isInteger(Infinity);
 * // => false
 *
 * _.isInteger('3');
 * // => false
 */
function isInteger(value) {
  return typeof value == 'number' && value == toInteger(value);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = isInteger;


/***/ }),
/* 345 */
/***/ (function(module, exports) {

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
 * as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && objectToString.call(value) == numberTag);
}

module.exports = isNumber;


/***/ }),
/* 346 */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) ||
      objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

module.exports = isPlainObject;


/***/ }),
/* 347 */
/***/ (function(module, exports) {

/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
}

module.exports = isString;


/***/ }),
/* 348 */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function once(func) {
  return before(2, func);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = once;


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = rsaPublicKeyPem;

//http://stackoverflow.com/questions/18835132/xml-to-pem-in-node-js
function rsaPublicKeyPem(modulus_b64, exponent_b64) {
 
    var modulus = new Buffer(modulus_b64, 'base64');
    var exponent = new Buffer(exponent_b64, 'base64');
 
    var modulus_hex = modulus.toString('hex')
    var exponent_hex = exponent.toString('hex')
 
    modulus_hex = prepadSigned(modulus_hex)
    exponent_hex = prepadSigned(exponent_hex)
 
    var modlen = modulus_hex.length/2
    var explen = exponent_hex.length/2
 
    var encoded_modlen = encodeLengthHex(modlen)
    var encoded_explen = encodeLengthHex(explen)
    var encoded_pubkey = '30' + 
        encodeLengthHex(
            modlen + 
            explen + 
            encoded_modlen.length/2 + 
            encoded_explen.length/2 + 2
        ) + 
        '02' + encoded_modlen + modulus_hex +
        '02' + encoded_explen + exponent_hex;

    var der_b64 = new Buffer(encoded_pubkey, 'hex').toString('base64');

    var pem = '-----BEGIN RSA PUBLIC KEY-----\n' 
        + der_b64.match(/.{1,64}/g).join('\n') 
        + '\n-----END RSA PUBLIC KEY-----\n';
 
    return pem
}

function prepadSigned(hexStr) {
    var msb = hexStr[0]
    if (msb < '0' || msb > '7') {
        return '00'+hexStr;
    } else {
        return hexStr;
    }
}

function toHex(number) {
    var nstr = number.toString(16);
    if (nstr.length%2) return '0'+nstr;
    return nstr;
}

// encode ASN.1 DER length field
// if <=127, short form
// if >=128, long form
function encodeLengthHex(n) {
    if (n<=127) return toHex(n)
    else {
        var n_hex = toHex(n)
        var length_of_length_byte = 128 + n_hex.length/2 // 0x80+numbytes
        return toHex(length_of_length_byte)+n_hex
    }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(351).default;
module.exports.default = module.exports;


/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
Object.defineProperty(exports, "__esModule", { value: true });
var pad_string_1 = __webpack_require__(352);
function encode(input, encoding) {
    if (encoding === void 0) { encoding = "utf8"; }
    if (Buffer.isBuffer(input)) {
        return fromBase64(input.toString("base64"));
    }
    return fromBase64(Buffer.from(input, encoding).toString("base64"));
}
;
function decode(base64url, encoding) {
    if (encoding === void 0) { encoding = "utf8"; }
    return Buffer.from(toBase64(base64url), "base64").toString(encoding);
}
function toBase64(base64url) {
    base64url = base64url.toString();
    return pad_string_1.default(base64url)
        .replace(/\-/g, "+")
        .replace(/_/g, "/");
}
function fromBase64(base64) {
    return base64
        .replace(/=/g, "")
        .replace(/\+/g, "-")
        .replace(/\//g, "_");
}
function toBuffer(base64url) {
    return Buffer.from(toBase64(base64url), "base64");
}
var base64url = encode;
base64url.encode = encode;
base64url.decode = decode;
base64url.toBase64 = toBase64;
base64url.fromBase64 = fromBase64;
base64url.toBuffer = toBuffer;
exports.default = base64url;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
Object.defineProperty(exports, "__esModule", { value: true });
function padString(input) {
    var segmentLength = 4;
    var stringLength = input.length;
    var diff = stringLength % segmentLength;
    if (!diff) {
        return input;
    }
    var position = stringLength;
    var padLength = segmentLength - diff;
    var paddedStringLength = stringLength + padLength;
    var buffer = Buffer.alloc(paddedStringLength);
    buffer.write(input);
    while (padLength--) {
        buffer.write("=", position++);
    }
    return buffer.toString();
}
exports.default = padString;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

//
// TEAMS API AS IF IT WAS CODE GENERATED BUT ACTUALLY CODED BY HAND
//
// DO NOT DELETE
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsApi = exports.TeamsApiFp = exports.TeamsApiFetchParamCreator = void 0;
const iopa_botadapter_schema_1 = __webpack_require__(5);
const url = __webpack_require__(12);
const portableFetch = __webpack_require__(41);
const BASE_PATH = 'https://api.botframework.com'.replace(/\/+$/, '');
/** TeamsApi - fetch parameter creator */
const TeamsApiFetchParamCreator = function (configuration) {
    return {
        /** Fetches channel list for a given team */
        fetchChannelList(teamId, options = {}) {
            // verify required parameter 'parameters' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new iopa_botadapter_schema_1.RequiredError('parameters', 'Required parameter parameters was null or undefined when calling conversationsCreateConversation.');
            }
            const localVarPath = `v3/teams/${encodeURIComponent(String(teamId))}/conversations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /** Fetch details for a team */
        fetchTeamDetails(teamId, options = {}) {
            // verify required parameter 'parameters' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new iopa_botadapter_schema_1.RequiredError('parameters', 'Required parameter parameters was null or undefined when calling conversationsCreateConversation.');
            }
            const localVarPath = `v3/teams/${encodeURIComponent(String(teamId))}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TeamsApiFetchParamCreator = TeamsApiFetchParamCreator;
/** TeamsApi - functional programming interface */
const TeamsApiFp = function (configuration) {
    return {
        /** Fetches channel list for a given team */
        fetchChannelList(teamId, options) {
            const localVarFetchArgs = exports.TeamsApiFetchParamCreator(configuration).fetchChannelList(teamId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /** Fetch details for a team */
        fetchTeamDetails(teamId, options) {
            const localVarFetchArgs = exports.TeamsApiFetchParamCreator(configuration).fetchTeamDetails(teamId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.TeamsApiFp = TeamsApiFp;
/** TeamsApi - object-oriented interface */
class TeamsApi extends iopa_botadapter_schema_1.BaseAPI {
    /** Fetches channel list for a given team */
    teamsFetchChannelList(teamId, options) {
        return exports.TeamsApiFp(this.configuration).fetchChannelList(teamId, options)(this.fetch, this.basePath);
    }
    /** Fetch details for a team */
    teamsFetchTeamDetails(teamId, options) {
        return exports.TeamsApiFp(this.configuration).fetchTeamDetails(teamId, options)(this.fetch, this.basePath);
    }
}
exports.TeamsApi = TeamsApi;
//# sourceMappingURL=api.js.map

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Microsoft Bot Token API - V3.1
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: token
 * Contact: botframework@microsoft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserTokenApi = exports.UserTokenApiFactory = exports.UserTokenApiFp = exports.UserTokenApiFetchParamCreator = exports.BotSignInApi = exports.BotSignInApiFactory = exports.BotSignInApiFp = exports.BotSignInApiFetchParamCreator = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = void 0;
const url = __webpack_require__(12);
const portableFetch = __webpack_require__(41);
const BASE_PATH = 'https://token.botframework.com'.replace(/\/+$/, '');
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|',
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, fetch = portableFetch) {
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
exports.RequiredError = RequiredError;
/**
 * BotSignInApi - fetch parameter creator
 * @export
 */
const BotSignInApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} state
         * @param {string} [codeChallenge]
         * @param {string} [emulatorUrl]
         * @param {string} [finalRedirect]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botSignInGetSignInUrl(state, codeChallenge, emulatorUrl, finalRedirect, options = {}) {
            // verify required parameter 'state' is not null or undefined
            if (state === null || state === undefined) {
                throw new RequiredError('state', 'Required parameter state was null or undefined when calling botSignInGetSignInUrl.');
            }
            const localVarPath = `/api/botsignin/GetSignInUrl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }
            if (codeChallenge !== undefined) {
                localVarQueryParameter['code_challenge'] = codeChallenge;
            }
            if (emulatorUrl !== undefined) {
                localVarQueryParameter['emulatorUrl'] = emulatorUrl;
            }
            if (finalRedirect !== undefined) {
                localVarQueryParameter['finalRedirect'] = finalRedirect;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.BotSignInApiFetchParamCreator = BotSignInApiFetchParamCreator;
/**
 * BotSignInApi - functional programming interface
 * @export
 */
const BotSignInApiFp = function (configuration) {
    return {
        /**
         *
         * @param {string} state
         * @param {string} [codeChallenge]
         * @param {string} [emulatorUrl]
         * @param {string} [finalRedirect]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botSignInGetSignInUrl(state, codeChallenge, emulatorUrl, finalRedirect, options) {
            const localVarFetchArgs = exports.BotSignInApiFetchParamCreator(configuration).botSignInGetSignInUrl(state, codeChallenge, emulatorUrl, finalRedirect, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.BotSignInApiFp = BotSignInApiFp;
/**
 * BotSignInApi - factory interface
 * @export
 */
const BotSignInApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @param {string} state
         * @param {string} [codeChallenge]
         * @param {string} [emulatorUrl]
         * @param {string} [finalRedirect]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botSignInGetSignInUrl(state, codeChallenge, emulatorUrl, finalRedirect, options) {
            return exports.BotSignInApiFp(configuration).botSignInGetSignInUrl(state, codeChallenge, emulatorUrl, finalRedirect, options)(fetch, basePath);
        },
    };
};
exports.BotSignInApiFactory = BotSignInApiFactory;
/**
 * BotSignInApi - object-oriented interface
 * @export
 * @class BotSignInApi
 * @extends {BaseAPI}
 */
class BotSignInApi extends BaseAPI {
    /**
     *
     * @param {string} state
     * @param {string} [codeChallenge]
     * @param {string} [emulatorUrl]
     * @param {string} [finalRedirect]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotSignInApi
     */
    botSignInGetSignInUrl(state, codeChallenge, emulatorUrl, finalRedirect, options) {
        return exports.BotSignInApiFp(this.configuration).botSignInGetSignInUrl(state, codeChallenge, emulatorUrl, finalRedirect, options)(this.fetch, this.basePath);
    }
}
exports.BotSignInApi = BotSignInApi;
/**
 * UserTokenApi - fetch parameter creator
 * @export
 */
const UserTokenApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} userId
         * @param {string} connectionName
         * @param {AadResourceUrls} aadResourceUrls
         * @param {string} [channelId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetAadTokens(userId, connectionName, aadResourceUrls, channelId, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling userTokenGetAadTokens.');
            }
            // verify required parameter 'connectionName' is not null or undefined
            if (connectionName === null || connectionName === undefined) {
                throw new RequiredError('connectionName', 'Required parameter connectionName was null or undefined when calling userTokenGetAadTokens.');
            }
            // verify required parameter 'aadResourceUrls' is not null or undefined
            if (aadResourceUrls === null || aadResourceUrls === undefined) {
                throw new RequiredError('aadResourceUrls', 'Required parameter aadResourceUrls was null or undefined when calling userTokenGetAadTokens.');
            }
            const localVarPath = `/api/usertoken/GetAadTokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (connectionName !== undefined) {
                localVarQueryParameter['connectionName'] = connectionName;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization =  true ||
                false;
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(aadResourceUrls || {})
                : aadResourceUrls || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} userId
         * @param {string} connectionName
         * @param {string} [channelId]
         * @param {string} [code]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetToken(userId, connectionName, channelId, code, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling userTokenGetToken.');
            }
            // verify required parameter 'connectionName' is not null or undefined
            if (connectionName === null || connectionName === undefined) {
                throw new RequiredError('connectionName', 'Required parameter connectionName was null or undefined when calling userTokenGetToken.');
            }
            const localVarPath = `/api/usertoken/GetToken`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (connectionName !== undefined) {
                localVarQueryParameter['connectionName'] = connectionName;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }
            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} userId
         * @param {string} [channelId]
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetTokenStatus(userId, channelId, include, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling userTokenGetTokenStatus.');
            }
            const localVarPath = `/api/usertoken/GetTokenStatus`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} userId
         * @param {string} [connectionName]
         * @param {string} [channelId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenSignOut(userId, connectionName, channelId, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling userTokenSignOut.');
            }
            const localVarPath = `/api/usertoken/SignOut`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (connectionName !== undefined) {
                localVarQueryParameter['connectionName'] = connectionName;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.UserTokenApiFetchParamCreator = UserTokenApiFetchParamCreator;
/**
 * UserTokenApi - functional programming interface
 * @export
 */
const UserTokenApiFp = function (configuration) {
    return {
        /**
         *
         * @param {string} userId
         * @param {string} connectionName
         * @param {AadResourceUrls} aadResourceUrls
         * @param {string} [channelId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetAadTokens(userId, connectionName, aadResourceUrls, channelId, options) {
            const localVarFetchArgs = exports.UserTokenApiFetchParamCreator(configuration).userTokenGetAadTokens(userId, connectionName, aadResourceUrls, channelId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} userId
         * @param {string} connectionName
         * @param {string} [channelId]
         * @param {string} [code]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetToken(userId, connectionName, channelId, code, options) {
            const localVarFetchArgs = exports.UserTokenApiFetchParamCreator(configuration).userTokenGetToken(userId, connectionName, channelId, code, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} userId
         * @param {string} [channelId]
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetTokenStatus(userId, channelId, include, options) {
            const localVarFetchArgs = exports.UserTokenApiFetchParamCreator(configuration).userTokenGetTokenStatus(userId, channelId, include, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} userId
         * @param {string} [connectionName]
         * @param {string} [channelId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenSignOut(userId, connectionName, channelId, options) {
            const localVarFetchArgs = exports.UserTokenApiFetchParamCreator(configuration).userTokenSignOut(userId, connectionName, channelId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.UserTokenApiFp = UserTokenApiFp;
/**
 * UserTokenApi - factory interface
 * @export
 */
const UserTokenApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @param {string} userId
         * @param {string} connectionName
         * @param {AadResourceUrls} aadResourceUrls
         * @param {string} [channelId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetAadTokens(userId, connectionName, aadResourceUrls, channelId, options) {
            return exports.UserTokenApiFp(configuration).userTokenGetAadTokens(userId, connectionName, aadResourceUrls, channelId, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} userId
         * @param {string} connectionName
         * @param {string} [channelId]
         * @param {string} [code]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetToken(userId, connectionName, channelId, code, options) {
            return exports.UserTokenApiFp(configuration).userTokenGetToken(userId, connectionName, channelId, code, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} userId
         * @param {string} [channelId]
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenGetTokenStatus(userId, channelId, include, options) {
            return exports.UserTokenApiFp(configuration).userTokenGetTokenStatus(userId, channelId, include, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} userId
         * @param {string} [connectionName]
         * @param {string} [channelId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenSignOut(userId, connectionName, channelId, options) {
            return exports.UserTokenApiFp(configuration).userTokenSignOut(userId, connectionName, channelId, options)(fetch, basePath);
        },
    };
};
exports.UserTokenApiFactory = UserTokenApiFactory;
/**
 * UserTokenApi - object-oriented interface
 * @export
 * @class UserTokenApi
 * @extends {BaseAPI}
 */
class UserTokenApi extends BaseAPI {
    /**
     *
     * @param {string} userId
     * @param {string} connectionName
     * @param {AadResourceUrls} aadResourceUrls
     * @param {string} [channelId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokenApi
     */
    userTokenGetAadTokens(userId, connectionName, aadResourceUrls, channelId, options) {
        return exports.UserTokenApiFp(this.configuration).userTokenGetAadTokens(userId, connectionName, aadResourceUrls, channelId, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param {string} userId
     * @param {string} connectionName
     * @param {string} [channelId]
     * @param {string} [code]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokenApi
     */
    userTokenGetToken(userId, connectionName, channelId, code, options) {
        return exports.UserTokenApiFp(this.configuration).userTokenGetToken(userId, connectionName, channelId, code, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param {string} userId
     * @param {string} [channelId]
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokenApi
     */
    userTokenGetTokenStatus(userId, channelId, include, options) {
        return exports.UserTokenApiFp(this.configuration).userTokenGetTokenStatus(userId, channelId, include, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param {string} userId
     * @param {string} [connectionName]
     * @param {string} [channelId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokenApi
     */
    userTokenSignOut(userId, connectionName, channelId, options) {
        return exports.UserTokenApiFp(this.configuration).userTokenSignOut(userId, connectionName, channelId, options)(this.fetch, this.basePath);
    }
}
exports.UserTokenApi = UserTokenApi;
//# sourceMappingURL=api.js.map

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable
/**
 * Microsoft Bot Token API - V3.1
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: token
 * Contact: botframework@microsoft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Configuration = void 0;
class Configuration {
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
    }
}
exports.Configuration = Configuration;
//# sourceMappingURL=configuration.js.map

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable
/**
 * Twilio
 * Enabling phones, VoIP, and messaging to be embedded into web, desktop, and mobile software.
 *
 * OpenAPI spec version: 2010-04-01
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(197), exports);
__exportStar(__webpack_require__(358), exports);
//# sourceMappingURL=index.js.map

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable
/**
 * Twilio
 * Enabling phones, VoIP, and messaging to be embedded into web, desktop, and mobile software.
 *
 * OpenAPI spec version: 2010-04-01
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Configuration = void 0;
class Configuration {
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
    }
}
exports.Configuration = Configuration;
//# sourceMappingURL=configuration.js.map

/***/ }),
/* 359 */
/***/ (function(module) {

module.exports = {"name":"@sync247/worker","version":"1.0.0","description":"Cloudflare worker for Sync247","main":"index.js","author":"Guy Barnard","contributors":["Guy Barnard","Sync Labs","Sync247 contributors"],"license":"Apache-2.0","publishConfig":{"access":"public"},"repository":{"type":"git","url":"https://github.com/asynca/sync247.git"},"scripts":{"start":"env-cmd -r ./.config/.env-secrets.json -e development envkey-cmd edge-host","build-dev":"npm run toml-dev && NODE_ENV=development env-cmd -r ./.config/.env-secrets.json -e development envkey-cmd wrangler build","deploy-dev":"npm run toml-dev && NODE_ENV=development env-cmd -r ./.config/.env-secrets.json -e development envkey-cmd wrangler publish","deploy-staging":"run toml-staging && NODE_ENV=staging env-cmd -r ./.config/.env-secrets.json -e staging envkey-cmd wrangler publish && rm -rf wrangler.toml","deploy-prod":"npm run toml-prod && NODE_ENV=production env-cmd -r ./.config/.env-secrets.json -e production envkey-cmd wrangler publish && rm -rf wrangler.toml","deploy-staging-ci":"run toml-staging-ci && NODE_ENV=staging envkey-cmd wrangler publish && rm -rf wrangler.toml","deploy-prod-ci":"npm run toml-prod-ci && NODE_ENV=production envkey-cmd wrangler publish && rm -rf wrangler.toml","dev":"edgedev open npm run edgedev ngrok","format":"prettier --ignore-path ../../.gitignore --write '**/*.{js,jsx,ts,tsx,json,md}'","postinstall":"npm link webpack","edgedev":"edgedev","emulator":"npm run build && firebase emulators:start --only functions","tail":"npm run toml-prod && wrangler tail && rm -rf wrangler.toml","test":"jest ","toml-dev":"env-cmd -r ./.config/.env-secrets.json -e development envkey-cmd envsub wrangler.template.toml wrangler.toml","toml-staging":"env-cmd -r ./.config/.env-secrets.json -e staging envkey-cmd envsub wrangler.template.toml wrangler.toml","toml-prod":"env-cmd -r ./.config/.env-secrets.json -e production envkey-cmd envsub wrangler.template.toml wrangler.toml","toml-staging-ci":"envkey-cmd envsub wrangler.template.toml wrangler.toml","toml-prod-ci":"envkey-cmd envsub wrangler.template.toml wrangler.toml"},"dependencies":{"iopa-types":"3.0.0","iopa":"3.0.0","@iopa-edge/host-cloudflare":"^3.0.0","@iopa-edge/jsonwebtoken":"^3.0.0","@iopa-edge-contrib/firebase":"^1.0.0","@iopa-edge/types":"^3.0.0","iopa-router":"^3.0.0","max-concurrency":"^1.5.7"},"devDependencies":{"@iopa-edge/cli":"^3.0.0","@iopa-edge/host-cloudflare":"^3.0.0","@dollarshaveclub/cloudworker":"^0.1.2","@sucrase/webpack-loader":"^2.0.0","envkey-cmd":"^10.1.6","env-cmd":"^10.1.0","envsub":"^4.0.7","typescript":"4.1.5"}};

/***/ }),
/* 360 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-edge/packages/iopa-edge-host-cloudflare/src/index.ts
var src = __webpack_require__(203);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-botcommander/src/index.ts + 1 modules
var iopa_botcommander_src = __webpack_require__(84);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-botadapter/packages/iopa-botadapter/src/index.ts
var iopa_botadapter_src = __webpack_require__(4);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa-carrier/packages/iopa-carrier/src/index.ts
var iopa_carrier_src = __webpack_require__(82);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/iopa/src/index.ts + 7 modules
var iopa_src = __webpack_require__(20);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-router/src/pattern.ts
/*
 * Copyright (c) 2016-2020 Internet Open Protocol Alliance (IOPA)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function decode(str) {
    try {
        return decodeURIComponent(str)
    } catch (err) {
        return str
    }
}

function pattern_pattern(pattern) {
    if (typeof pattern !== 'string') {
        return (url) => {
            return url.match(pattern)
        }
    }

    const keys = []

    pattern = pattern.replace(/:(\w+)/g, '{$1}').replace('{*}', '*')
    pattern = pattern.replace(
        /(\/)?(\.)?\{([^}]+)\}(?:\(([^)]*)\))?(\?)?/g,
        (match, slash, dot, key, capture, opt, offset) => {
            const incl = (pattern[match.length + offset] || '/') === '/'

            keys.push(key)

            return `${
                (incl ? '(?:' : '') +
                (slash || '') +
                (incl ? '' : '(?:') +
                (dot || '')
            }(${capture || '[^/]+'}))${opt || ''}`
        }
    )
    pattern = pattern.replace(/([/.])/g, '\\$1').replace(/\*/g, '(.+)')
    pattern = new RegExp(`^${pattern}[\\/]?$`, 'i')

    return function matchRoutePattern(str) {
        const match = str.match(pattern)

        if (!match) {
            return match
        }

        const map = {}

        match.slice(1).forEach((param, i) => {
            // eslint-disable-next-line no-multi-assign
            const k = (keys[i] = keys[i] || 'wildcard')

            param = param && decode(param)
            map[k] = map[k] ? [].concat(map[k]).concat(param) : param
        })

        if (map.wildcard) {
            map['*'] = map.wildcard
        }

        return map
    }
}

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/iopa-router/src/index.ts




















const METHODS = ['when', 'get', 'post', 'put', 'patch', 'delete']
const APP_METHODS = [
    'urn:io.iopa:data',
    'GET',
    'POST',
    'PUT',
    'PATCH',
    'DELETE',
]

class src_Router {
     __init() {this.methods = {}}

     __init2() {this.traps = {}}

    

    constructor(app) {;src_Router.prototype.__init.call(this);src_Router.prototype.__init2.call(this);src_Router.prototype.__init3.call(this);
        this.app = app

        APP_METHODS.forEach((method) => {
            this.methods[method] = []
        })

        METHODS.forEach((method, i) => {
            app[method] = (pattern, fn) => {
                if (Array.isArray(pattern)) {
                    pattern.forEach((item) => {
                        app[method](item, fn)
                    })
                    return app
                }

                if (!fn && !pattern) {
                    return app
                }
                if (!fn) {
                    return app[method](null, pattern)
                }

                if (!pattern) {
                    this.traps[APP_METHODS[i]] = fn
                    return app
                }

                this.methods[APP_METHODS[i]].push({
                    pattern: pattern_pattern(pattern),
                    fn,
                })

                return app
            }
        })

        app.all = (pattern, fn) => {
            METHODS.forEach((method) => {
                app[method](pattern, fn)
            })
            return app
        }

        app.route = this.route
    }

    /**
     * @method invoke
     * @this Router
     * @param context IOPA context dictionary
     * @param next   IOPA application delegate for the remainder of the pipeline
     */
     invoke(context, next) {
        return this.route(context.get('iopa.Path'), context, next)
    }

     __init3() {this.route = (
        path,
        context,
        next
    ) => {
        const method = context.get('iopa.Method')
        const methodRoute = this.methods[method]
        const trap = this.traps[method]
        let url = path
        if (url === '') {
            url = '/'
        }
        let i = 0

        if (!methodRoute) {
            return next ? next() : Promise.resolve()
        }

        while (i < methodRoute.length) {
            const route = methodRoute[i]

            i++
            const _model = route.pattern(url)

            if (!_model) {
                continue
            }

            if (context.get('iopa.QueryString')) {
                _parseQueryString(_model, context.get('iopa.QueryString'))
            }

            context['iopa.Params'] = _model

            return route.fn.call(undefined, context, () => {
                return next ? next() : Promise.resolve()
            }) 
        }

        delete context['iopa.Params']

        if (!trap) {
            return next ? next() : Promise.resolve()
        }

        return trap.call(this.app, context, next) 
    }}
}

function _parseQueryString(urlParams, query) {
    let match
    const pl = /\+/g
    const search = /([^&=]+)=?([^&]*)/g
    const decode = (s) => {
        return decodeURIComponent(s.replace(pl, ' '))
    }

    // eslint-disable-next-line no-cond-assign
    while ((match = search.exec(query))) {
        urlParams[decode(match[1])] = decode(match[2])
    }
}

// EXTERNAL MODULE: ../capability-sync247-store/src/types.ts
var types = __webpack_require__(76);

// CONCATENATED MODULE: ../capability-sync247-store/src/index.ts





class Sync247StoreCapability  {
  

  constructor(app) {
    this.db = app.db
    app.store = this
  }

  async registerSpecialist({
    userGlobalId,
    ...user
  }) {
    await this.db
      .collection('specialists')
      .doc(userGlobalId)
      .set(user, { merge: true })
  }

  async getSpecialist({
    userGlobalId
  }) {
    return (
      await this.db.collection('specialists').doc(userGlobalId).get()
    ).data() 
  }

  async registerOrUpdateTeam({
    teamId,
    ...team
  }) {
    await this.db.collection('teams').doc(teamId).set(team, { merge: true })
  }

  async getTeam({ teamId }) {
    return (
      await this.db.collection('teams').doc(teamId).get()
    ).data() 
  }

  async registerOrUpdateVirtualNumberTeam({
    virtualNumber,
    ...team
  }) {
    await this.db
      .collection('virtualnumbers')
      .doc(virtualNumber)
      .set(team, { merge: true })
  }

  async getVirtualNumberTeam({
    virtualNumber
  }) {
    return (
      await this.db.collection('virtualnumbers').doc(virtualNumber).get()
    ).data() 
  }

  async deleteTeam({
    virtualNumber,
    teamId,
    userGlobalId
  }) {
    try {
      await this.db.collection('virtualnumbers').doc(virtualNumber).delete()
    } catch (ex) {
      console.log(ex)
    }

    try {
      await this.db.collection('teams').doc(teamId).delete()
    } catch (ex) {
      console.log(ex)
    }

    try {
      const specialist = (
        await this.db.collection('specialists').doc(userGlobalId).get()
      ).data() 

      if (specialist.virtualNumber === virtualNumber) {
        delete specialist.virtualNumber

        await this.db
          .collection('specialists')
          .doc(userGlobalId)
          .set(specialist, { merge: false })
      }
    } catch (ex) {
      console.log(ex)
    }
  }

  async registerProviderSpecialist({
    'bot.Provider': botProvider,
    userLocalId,
    userGlobalId
  }) {
    await this.db
      .collection('providers')
      .doc(botProvider)
      .collection('specialists')
      .doc(userLocalId)
      .set(
        {
          userGlobalId
        },
        { merge: true }
      )
  }

  async getProviderSpecialist({
    'bot.Provider': botProvider,
    userLocalId
  }) {
    return (
      await this.db
        .collection('providers')
        .doc(botProvider)
        .collection('specialists')
        .doc(userLocalId)
        .get()
    ).data() 
  }
}

// CONCATENATED MODULE: ../capability-carrier/src/index.ts


class src_CarrierCapability {
  

  constructor(app) {
    this.app = app

    app.use(iopa_carrier_src["CarrierMiddleware"], 'CarrierMiddleware')

    app.carrier.onTurnError = async (context, err) => {
      console.error(err)
      void context.response.end()
    }

    app.post(app.carrier.getBaseUrlPath(), async (context, next) => {
      try {
        await app.carrier.invokeActivity(context, next)
      } catch (ex) {
        console.error(ex)
      }
    })
  }
}

// EXTERNAL MODULE: ../capability-teams/src/store/types.ts
var store_types = __webpack_require__(111);

// CONCATENATED MODULE: ../capability-teams/src/store/msteams-event-handlers.ts










class TeamsEventHandlers {
  // TO DO SWITCH TO EVENT HANDLERS, NOT BOT COMMANDS

  constructor(app) {
    app.botadapter.onTeamsChannelRenamedEvent(
      async (
        context,
        channelInfo,
        teamInfo,
        next
      ) => {
        await app.bot.invoke('urn:com.sync247:ChannelRenamed', context, {
          channelInfo,
          teamInfo
        })
        return next()
      }
    )

    app.botadapter.onTeamsChannelCreatedEvent(
      async (
        context,
        channelInfo,
        teamInfo,
        next
      ) => {
        await app.bot.invoke('urn:com.sync247:ChannelCreated', context, {
          channelInfo,
          teamInfo
        })
        return next()
      }
    )

    app.botadapter.onTeamsChannelDeletedEvent(
      async (
        context,
        channelInfo,
        teamInfo,
        next
      ) => {
        await app.bot.invoke('urn:com.sync247:ChannelDeleted', context, {
          channelInfo,
          teamInfo
        })
        return next()
      }
    )

    app.botadapter.onTeamsTeamRenamedEvent(
      async (
        context,
        teamInfo,
        next
      ) => {
        await app.bot.invoke('urn:com.sync247:TeamRenamed', context, {
          teamInfo
        })
        return next()
      }
    )

    app.botadapter.onTeamsMembersAddedEvent(
      async (
        context,
        membersAdded,
        teamInfo,
        next
      ) => {
        if (
          membersAdded[0].id === context['bot.Capability'].activity.recipient.id
        ) {
          await app.bot.invoke('urn:com.sync247:TeamAdded', context, {
            bot: membersAdded[0],
            teamInfo: {
              id: teamInfo.id,
              name: teamInfo.name,
              global_id: teamInfo.aadGroupId
            }
          })

          membersAdded.shift()
        }

        if (membersAdded.length > 0) {
          await app.bot.invoke('urn:com.sync247:TeamMembersAdded', context, {
            members: membersAdded,
            teamInfo,
            'bot.Provider': context['bot.Provider']
          })
        }

        return next()
      }
    )

    app.botadapter.onTeamsMembersRemovedEvent(
      async (
        context,
        membersAdded,
        teamInfo,
        next
      ) => {
        await app.bot.invoke('urn:com.sync247:TeamMembersRemoved', context, {
          members: membersAdded,
          teamInfo
        })
        return next()
      }
    )
  }
}

/* harmony default export */ var msteams_event_handlers = (TeamsEventHandlers);

// CONCATENATED MODULE: ../capability-teams/src/store/msteams-capability.ts











class msteams_capability_MsTeamsCapability  {
  




  constructor(
    app



  ) {
    this.app = app
    this.app.teams = this
    app.use(TeamsEventHandlers, 'TeamsEventHandlers')
  }

  async sendToExistingOrNewTeamsChannel(
    {
      provider,
      groupId,
      botId,
      channelName,
      channelDescriptor,
      serviceUrl,
      activity
    }







,
    logic
  ) {
    let channel

    try {
      if (provider !== 'msteams') {
        throw new Error(
          `invalid provider, only "msteams" support currently: ${provider}`
        )
      }

      let channels
      if (channelDescriptor) {
        channels = await this.app.msgraph.getChannelByDescription({
          groupid: groupId,
          description: channelDescriptor
        })
      } else {
        channels = await this.app.msgraph.getChannelGeneral({
          groupid: groupId
        })
      }

      if (channels.length > 0) {
        // eslint-disable-next-line prefer-destructuring
        channel = channels[0]
      } else {
        if (!channelDescriptor) {
          throw new Error(`cannot find general channel on team ${groupId} `)
        }
        channel = await this.app.msgraph.createChannel({
          groupid: groupId,
          displayName: channelName,
          description: channelDescriptor
        })
        console.log('channel created')
      }
    } catch (ex) {
      console.error(ex)
    }

    if (!channel) {
      console.log('Could not find channel')
      return
    }
    console.log('Found channel')

    try {
      const conversationParameters = {
        bot: { id: botId },
        isGroup: true,
        channelData: {
          channel: { id: channel.id, name: channel.displayName },
          tenantId: "fbe59500-b0cc-491b-aa3e-ffaf2699aec9"
        },
        members: [],
        tenantId: "fbe59500-b0cc-491b-aa3e-ffaf2699aec9",
        serviceUrl
      } 

      await this.app.botadapter.createProactiveChannelConversation(
        conversationParameters,
        activity,
        logic
      )
    } catch (ex) {
      console.error(ex)
    }
  }
}

/* harmony default export */ var msteams_capability = (msteams_capability_MsTeamsCapability);

// CONCATENATED MODULE: ../capability-teams/src/store/index.ts





// Microsoft Teams specific provider middleware
// Depends on `iopa-botadapter` and `@sync247/capability-msgraph




class store_TeamsStoreMsTeams {
  constructor(
    app



  ) {
    app.teams = new msteams_capability_MsTeamsCapability(app)
  }
}

// CONCATENATED MODULE: ../capability-teams/src/index.ts









class src_CapabilityMicrosoftTeams {
  







  constructor(
    app






  ) {
    this.app = app

    app.use(iopa_botadapter_src["BotAdapterMiddleware"], 'BotAdapterMiddleware')

    app.botadapter.onTurnError = async (context, error) => {
      console.error(error)
    }

    app.use(store_TeamsStoreMsTeams, 'TeamsStoreMsTeams')

    app.post('/client/v1.0.0/msbot/api/messages', async (context, next) => {
      try {
        await app.botadapter.invokeActivity(context, next)
      } catch (ex) {
        console.error(ex)
      }
    })
  }
}

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/content/BatchRequestContent.js
var BatchRequestContent = __webpack_require__(199);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/content/BatchResponseContent.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @class
 * Class that handles BatchResponseContent
 */
class BatchResponseContent {
    /**
     * @public
     * @constructor
     * Creates the BatchResponseContent instance
     * @param {BatchResponseBody} response - The response body returned for batch request from server
     * @returns An instance of a BatchResponseContent
     */
    constructor(response) {
        this.responses = new Map();
        this.update(response);
    }
    /**
     * @private
     * Creates native Response object from the json representation of it.
     * @param {KeyValuePairObject} responseJSON - The response json value
     * @returns The Response Object instance
     */
    createResponseObject(responseJSON) {
        const body = responseJSON.body;
        const options = {};
        options.status = responseJSON.status;
        if (responseJSON.statusText !== undefined) {
            options.statusText = responseJSON.statusText;
        }
        options.headers = responseJSON.headers;
        if (options.headers !== undefined && options.headers["Content-Type"] !== undefined) {
            if (options.headers["Content-Type"].split(";")[0] === "application/json") {
                const bodyString = JSON.stringify(body);
                return new Response(bodyString, options);
            }
        }
        return new Response(body, options);
    }
    /**
     * @public
     * Updates the Batch response content instance with given responses.
     * @param {BatchResponseBody} response - The response json representing batch response message
     * @returns Nothing
     */
    update(response) {
        this.nextLink = response["@odata.nextLink"];
        const responses = response.responses;
        for (let i = 0, l = responses.length; i < l; i++) {
            this.responses.set(responses[i].id, this.createResponseObject(responses[i]));
        }
    }
    /**
     * @public
     * To get the response of a request for a given request id
     * @param {string} requestId - The request id value
     * @returns The Response object instance for the particular request
     */
    getResponseById(requestId) {
        return this.responses.get(requestId);
    }
    /**
     * @public
     * To get all the responses of the batch request
     * @returns The Map of id and Response objects
     */
    getResponses() {
        return this.responses;
    }
    /**
     * @public
     * To get the iterator for the responses
     * @returns The Iterable generator for the response objects
     */
    *getResponsesIterator() {
        const iterator = this.responses.entries();
        let cur = iterator.next();
        while (!cur.done) {
            yield cur.value;
            cur = iterator.next();
        }
    }
}
//# sourceMappingURL=BatchResponseContent.js.map
// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/AuthenticationHandler.js
var AuthenticationHandler = __webpack_require__(48);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/HTTPMessageHandler.js
var HTTPMessageHandler = __webpack_require__(49);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/RetryHandler.js
var RetryHandler = __webpack_require__(50);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/RedirectHandler.js
var RedirectHandler = __webpack_require__(51);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/TelemetryHandler.js + 1 modules
var TelemetryHandler = __webpack_require__(52);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/MiddlewareFactory.js
var MiddlewareFactory = __webpack_require__(200);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/options/AuthenticationHandlerOptions.js
var AuthenticationHandlerOptions = __webpack_require__(79);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/options/RetryHandlerOptions.js
var RetryHandlerOptions = __webpack_require__(31);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/options/RedirectHandlerOptions.js
var RedirectHandlerOptions = __webpack_require__(28);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/options/TelemetryHandlerOptions.js
var TelemetryHandlerOptions = __webpack_require__(21);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/options/ChaosStrategy.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @module ChaosStrategy
 */
/**
 * Strategy used for Testing Handler
 * @enum
 */
var ChaosStrategy;
(function (ChaosStrategy) {
    ChaosStrategy[ChaosStrategy["MANUAL"] = 0] = "MANUAL";
    ChaosStrategy[ChaosStrategy["RANDOM"] = 1] = "RANDOM";
})(ChaosStrategy || (ChaosStrategy = {}));
//# sourceMappingURL=ChaosStrategy.js.map
// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/options/ChaosHandlerOptions.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @module ChaosHandlerOptions
 */

/**
 * Class representing ChaosHandlerOptions
 * @class
 * Class
 * @implements MiddlewareOptions
 */
class ChaosHandlerOptions_ChaosHandlerOptions {
    /**
     * @public
     * @constructor
     * To create an instance of Testing Handler Options
     * @param {ChaosStrategy} ChaosStrategy - Specifies the startegy used for the Testing Handler -> RAMDOM/MANUAL
     * @param {string} statusMessage - The Message to be returned in the response
     * @param {number?} statusCode - The statusCode to be returned in the response
     * @param {number?} chaosPercentage - The percentage of randomness/chaos in the handler
     * @param {any?} responseBody - The response body to be returned in the response
     * @returns An instance of ChaosHandlerOptions
     */
    constructor(chaosStrategy = ChaosStrategy.RANDOM, statusMessage = "Some error Happened", statusCode, chaosPercentage, responseBody) {
        this.chaosStrategy = chaosStrategy;
        this.statusCode = statusCode;
        this.statusMessage = statusMessage;
        this.chaosPercentage = chaosPercentage !== undefined ? chaosPercentage : 10;
        this.responseBody = responseBody;
        if (this.chaosPercentage > 100) {
            throw new Error("Error Pecentage can not be more than 100");
        }
    }
}
//# sourceMappingURL=ChaosHandlerOptions.js.map
// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(2);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/MiddlewareControl.js
var MiddlewareControl = __webpack_require__(17);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/MiddlewareUtil.js
var MiddlewareUtil = __webpack_require__(19);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/options/ChaosHandlerData.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @module ChaosHandlerData
 */
/**
 * Contains RequestMethod to corresponding array of possible status codes, used for Random mode
 */
const methodStatusCode = {
    GET: [429, 500, 502, 503, 504],
    POST: [429, 500, 502, 503, 504, 507],
    PUT: [429, 500, 502, 503, 504, 507],
    PATCH: [429, 500, 502, 503, 504],
    DELETE: [429, 500, 502, 503, 504, 507],
};
/**
 * Contains statusCode to statusMessage map
 */
const httpStatusCode = {
    100: "Continue",
    101: "Switching Protocols",
    102: "Processing",
    103: "Early Hints",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    207: "Multi-Status",
    208: "Already Reported",
    226: "IM Used",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    308: "Permanent Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Payload Too Large",
    414: "URI Too Long",
    415: "Unsupported Media Type",
    416: "Range Not Satisfiable",
    417: "Expectation Failed",
    421: "Misdirected Request",
    422: "Unprocessable Entity",
    423: "Locked",
    424: "Failed Dependency",
    425: "Too Early",
    426: "Upgrade Required",
    428: "Precondition Required",
    429: "Too Many Requests",
    431: "Request Header Fields Too Large",
    451: "Unavailable For Legal Reasons",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout",
    505: "HTTP Version Not Supported",
    506: "Variant Also Negotiates",
    507: "Insufficient Storage",
    508: "Loop Detected",
    510: "Not Extended",
    511: "Network Authentication Required",
};
//# sourceMappingURL=ChaosHandlerData.js.map
// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/middleware/ChaosHandler.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */






/**
 * Class representing ChaosHandler
 * @class
 * Class
 * @implements Middleware
 */
class ChaosHandler_ChaosHandler {
    /**
     * @public
     * @constructor
     * To create an instance of Testing Handler
     * @param {ChaosHandlerOptions} [options = new ChaosHandlerOptions()] - The testing handler options instance
     * @param manualMap - The Map passed by user containing url-statusCode info
     * @returns An instance of Testing Handler
     */
    constructor(options = new ChaosHandlerOptions_ChaosHandlerOptions(), manualMap) {
        this.options = options;
        this.manualMap = manualMap;
    }
    /**
     * Generates responseHeader
     * @private
     * @param {number} statusCode - the status code to be returned for the request
     * @param {string} requestID - request id
     * @param {string} requestDate - date of the request
     * @returns response Header
     */
    createResponseHeaders(statusCode, requestID, requestDate) {
        const responseHeader = new Headers();
        responseHeader.append("Cache-Control", "no-store");
        responseHeader.append("request-id", requestID);
        responseHeader.append("client-request-id", requestID);
        responseHeader.append("x-ms-ags-diagnostic", "");
        responseHeader.append("Date", requestDate);
        responseHeader.append("Strict-Transport-Security", "");
        if (statusCode === 429) {
            // throttling case has to have a timeout scenario
            responseHeader.append("retry-after", "300");
        }
        return responseHeader;
    }
    /**
     * Generates responseBody
     * @private
     * @param {number} statusCode - the status code to be returned for the request
     * @param {string} statusMessage - the status message to be returned for the request
     * @param {string} requestID - request id
     * @param {string} requestDate - date of the request
     * @param {any?} requestBody - the request body to be returned for the request
     * @returns response body
     */
    createResponseBody(statusCode, statusMessage, requestID, requestDate, responseBody) {
        if (responseBody) {
            return responseBody;
        }
        let body;
        if (statusCode >= 400) {
            const codeMessage = httpStatusCode[statusCode];
            const errMessage = statusMessage;
            body = {
                error: {
                    code: codeMessage,
                    message: errMessage,
                    innerError: {
                        "request-id": requestID,
                        date: requestDate,
                    },
                },
            };
        }
        else {
            body = {};
        }
        return body;
    }
    /**
     * creates a response
     * @private
     * @param {ChaosHandlerOptions} ChaosHandlerOptions - The ChaosHandlerOptions object
     * @param {Context} context - Contains the context of the request
     */
    createResponse(chaosHandlerOptions, context) {
        try {
            let responseBody;
            let responseHeader;
            let requestID;
            let requestDate;
            const requestURL = context.request;
            requestID = Object(MiddlewareUtil["c" /* generateUUID */])();
            requestDate = new Date();
            responseHeader = this.createResponseHeaders(chaosHandlerOptions.statusCode, requestID, requestDate.toString());
            responseBody = this.createResponseBody(chaosHandlerOptions.statusCode, chaosHandlerOptions.statusMessage, requestID, requestDate.toString(), chaosHandlerOptions.responseBody);
            const init = { url: requestURL, status: chaosHandlerOptions.statusCode, statusText: chaosHandlerOptions.statusMessage, headers: responseHeader };
            context.response = new Response(responseBody, init);
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * Decides whether to send the request to the graph or not
     * @private
     * @param {ChaosHandlerOptions} chaosHandlerOptions - A ChaosHandlerOptions object
     * @param {Context} context - Contains the context of the request
     * @returns nothing
     */
    sendRequest(chaosHandlerOptions, context) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                this.setStatusCode(chaosHandlerOptions, context.request, context.options.method);
                if (!chaosHandlerOptions.statusCode) {
                    yield this.nextMiddleware.execute(context);
                }
                else {
                    this.createResponse(chaosHandlerOptions, context);
                }
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * Fetches a random status code for the RANDOM mode from the predefined array
     * @private
     * @param {string} requestMethod - the API method for the request
     * @returns a random status code from a given set of status codes
     */
    getRandomStatusCode(requestMethod) {
        try {
            const statusCodeArray = methodStatusCode[requestMethod];
            return statusCodeArray[Math.floor(Math.random() * statusCodeArray.length)];
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * To fetch the relative URL out of the complete URL using a predefined regex pattern
     * @private
     * @param {string} urlMethod - the complete URL
     * @returns the string as relative URL
     */
    getRelativeURL(urlMethod) {
        const pattern = /https?:\/\/graph\.microsoft\.com\/[^/]+(.+?)(\?|$)/;
        let relativeURL;
        if (pattern.exec(urlMethod) !== null) {
            relativeURL = pattern.exec(urlMethod)[1];
        }
        return relativeURL;
    }
    /**
     * To fetch the status code from the map(if needed), then returns response by calling createResponse
     * @private
     * @param {ChaosHandlerOptions} ChaosHandlerOptions - The ChaosHandlerOptions object
     * @param {string} requestURL - the URL for the request
     * @param {string} requestMethod - the API method for the request
     */
    setStatusCode(chaosHandlerOptions, requestURL, requestMethod) {
        try {
            if (chaosHandlerOptions.chaosStrategy === ChaosStrategy.MANUAL) {
                if (chaosHandlerOptions.statusCode === undefined) {
                    // manual mode with no status code, can be a global level or request level without statusCode
                    const relativeURL = this.getRelativeURL(requestURL);
                    if (this.manualMap.get(relativeURL) !== undefined) {
                        // checking Manual Map for exact match
                        if (this.manualMap.get(relativeURL).get(requestMethod) !== undefined) {
                            chaosHandlerOptions.statusCode = this.manualMap.get(relativeURL).get(requestMethod);
                        }
                        // else statusCode would be undefined
                    }
                    else {
                        // checking for regex match if exact match doesn't work
                        this.manualMap.forEach((value, key) => {
                            const regexURL = new RegExp(key + "$");
                            if (regexURL.test(relativeURL)) {
                                if (this.manualMap.get(key).get(requestMethod) !== undefined) {
                                    chaosHandlerOptions.statusCode = this.manualMap.get(key).get(requestMethod);
                                }
                                // else statusCode would be undefined
                            }
                        });
                    }
                    // Case of redirection or request url not in map ---> statusCode would be undefined
                }
            }
            else {
                // Handling the case of Random here
                if (Math.floor(Math.random() * 100) < chaosHandlerOptions.chaosPercentage) {
                    chaosHandlerOptions.statusCode = this.getRandomStatusCode(requestMethod);
                }
                // else statusCode would be undefined
            }
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * To get the options for execution of the middleware
     * @private
     * @param {Context} context - The context object
     * @returns options for middleware execution
     */
    getOptions(context) {
        let options;
        if (context.middlewareControl instanceof MiddlewareControl["a" /* MiddlewareControl */]) {
            options = context.middlewareControl.getMiddlewareOptions(ChaosHandlerOptions_ChaosHandlerOptions);
        }
        if (typeof options === "undefined") {
            options = Object.assign(new ChaosHandlerOptions_ChaosHandlerOptions(), this.options);
        }
        return options;
    }
    /**
     * To execute the current middleware
     * @public
     * @async
     * @param {Context} context - The context object of the request
     * @returns A Promise that resolves to nothing
     */
    execute(context) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                const chaosHandlerOptions = this.getOptions(context);
                return yield this.sendRequest(chaosHandlerOptions, context);
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * To set the next middleware in the chain
     * @param {Middleware} next - The middleware instance
     * @returns Nothing
     */
    setNext(next) {
        this.nextMiddleware = next;
    }
}
//# sourceMappingURL=ChaosHandler.js.map
// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/tasks/LargeFileUploadTask.js + 1 modules
var LargeFileUploadTask = __webpack_require__(80);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/tasks/OneDriveLargeFileUploadTask.js
var OneDriveLargeFileUploadTask = __webpack_require__(201);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/tasks/PageIterator.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */

/**
 * @class
 * Class for PageIterator
 */
class PageIterator_PageIterator {
    /**
     * @public
     * @constructor
     * Creates new instance for PageIterator
     * @param {Client} client - The graph client instance
     * @param {PageCollection} pageCollection - The page collection object
     * @param {PageIteratorCallback} callBack - The callback function
     * @param {GraphRequestOptions} requestOptions - The request options
     * @returns An instance of a PageIterator
     */
    constructor(client, pageCollection, callback, requestOptions) {
        this.client = client;
        this.collection = pageCollection.value;
        this.nextLink = pageCollection["@odata.nextLink"];
        this.deltaLink = pageCollection["@odata.deltaLink"];
        this.callback = callback;
        this.complete = false;
        this.requestOptions = requestOptions;
    }
    /**
     * @private
     * Iterates over a collection by enqueuing entries one by one and kicking the callback with the enqueued entry
     * @returns A boolean indicating the continue flag to process next page
     */
    iterationHelper() {
        if (this.collection === undefined) {
            return false;
        }
        let advance = true;
        while (advance && this.collection.length !== 0) {
            const item = this.collection.shift();
            advance = this.callback(item);
        }
        return advance;
    }
    /**
     * @private
     * @async
     * Helper to make a get request to fetch next page with nextLink url and update the page iterator instance with the returned response
     * @returns A promise that resolves to a response data with next page collection
     */
    fetchAndUpdateNextPageData() {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                let graphRequest = this.client.api(this.nextLink);
                if (this.requestOptions) {
                    if (this.requestOptions.headers) {
                        graphRequest = graphRequest.headers(this.requestOptions.headers);
                    }
                    if (this.requestOptions.middlewareOptions) {
                        graphRequest = graphRequest.middlewareOptions(this.requestOptions.middlewareOptions);
                    }
                    if (this.requestOptions.options) {
                        graphRequest = graphRequest.options(this.requestOptions.options);
                    }
                }
                const response = yield graphRequest.get();
                this.collection = response.value;
                this.nextLink = response["@odata.nextLink"];
                this.deltaLink = response["@odata.deltaLink"];
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * Getter to get the deltaLink in the current response
     * @returns A deltaLink which is being used to make delta requests in future
     */
    getDeltaLink() {
        return this.deltaLink;
    }
    /**
     * @public
     * @async
     * Iterates over the collection and kicks callback for each item on iteration. Fetches next set of data through nextLink and iterates over again
     * This happens until the nextLink is drained out or the user responds with a red flag to continue from callback
     * @returns A Promise that resolves to nothing on completion and throws error incase of any discrepancy.
     */
    iterate() {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                let advance = this.iterationHelper();
                while (advance) {
                    if (this.nextLink !== undefined) {
                        yield this.fetchAndUpdateNextPageData();
                        advance = this.iterationHelper();
                    }
                    else {
                        advance = false;
                    }
                }
                if (this.nextLink === undefined && this.collection.length === 0) {
                    this.complete = true;
                }
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * @async
     * To resume the iteration
     * Note: This internally calls the iterate method, It's just for more readability.
     * @returns A Promise that resolves to nothing on completion and throws error incase of any discrepancy
     */
    resume() {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                return this.iterate();
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * To get the completeness status of the iterator
     * @returns Boolean indicating the completeness
     */
    isComplete() {
        return this.complete;
    }
}
//# sourceMappingURL=PageIterator.js.map
// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/Constants.js
var Constants = __webpack_require__(56);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/CustomAuthenticationProvider.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */

/**
 * @class
 * Class representing CustomAuthenticationProvider
 * @extends AuthenticationProvider
 */
class CustomAuthenticationProvider_CustomAuthenticationProvider {
    /**
     * @public
     * @constructor
     * Creates an instance of CustomAuthenticationProvider
     * @param {AuthProviderCallback} provider - An authProvider function
     * @returns An instance of CustomAuthenticationProvider
     */
    constructor(provider) {
        this.provider = provider;
    }
    /**
     * @public
     * @async
     * To get the access token
     * @returns The promise that resolves to an access token
     */
    getAccessToken() {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.provider((error, accessToken) => {
                    if (accessToken) {
                        resolve(accessToken);
                    }
                    else {
                        reject(error);
                    }
                });
            });
        });
    }
}
//# sourceMappingURL=CustomAuthenticationProvider.js.map
// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/GraphError.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @module GraphError
 */
/**
 * @class
 * Class for GraphError
 * @NOTE: This is NOT what is returned from the Graph
 * GraphError is created from parsing JSON errors returned from the graph
 * Some fields are renamed ie, "request-id" => requestId so you can use dot notation
 */
class GraphError extends Error {
    /**
     * @public
     * @constructor
     * Creates an instance of GraphError
     * @param {number} [statusCode = -1] - The status code of the error
     * @returns An instance of GraphError
     */
    constructor(statusCode = -1, message, baseError) {
        super(message || (baseError && baseError.message));
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, GraphError.prototype);
        this.statusCode = statusCode;
        this.code = null;
        this.requestId = null;
        this.date = new Date();
        this.body = null;
        this.stack = baseError ? baseError.stack : this.stack;
    }
}
//# sourceMappingURL=GraphError.js.map
// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/GraphErrorHandler.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */

/**
 * @module GraphErrorHandler
 */

/**
 * @class
 * Class for GraphErrorHandler
 */
class GraphErrorHandler_GraphErrorHandler {
    /**
     * @private
     * @static
     * Populates the GraphError instance with Error instance values
     * @param {Error} error - The error returned by graph service or some native error
     * @param {number} [statusCode] - The status code of the response
     * @returns The GraphError instance
     */
    static constructError(error, statusCode) {
        const gError = new GraphError(statusCode, "", error);
        if (error.name !== undefined) {
            gError.code = error.name;
        }
        gError.body = error.toString();
        gError.date = new Date();
        return gError;
    }
    /**
     * @private
     * @static
     * @async
     * Populates the GraphError instance from the Error returned by graph service
     * @param {any} error - The error returned by graph service or some native error
     * @param {number} statusCode - The status code of the response
     * @returns A promise that resolves to GraphError instance
     *
     * Example error for https://graph.microsoft.com/v1.0/me/events?$top=3&$search=foo
     * {
     *      "error": {
     *          "code": "SearchEvents",
     *          "message": "The parameter $search is not currently supported on the Events resource.",
     *          "innerError": {
     *              "request-id": "b31c83fd-944c-4663-aa50-5d9ceb367e19",
     *              "date": "2016-11-17T18:37:45"
     *          }
     *      }
     *  }
     */
    static constructErrorFromResponse(error, statusCode) {
        error = error.error;
        const gError = new GraphError(statusCode, error.message);
        gError.code = error.code;
        if (error.innerError !== undefined) {
            gError.requestId = error.innerError["request-id"];
            gError.date = new Date(error.innerError.date);
        }
        try {
            gError.body = JSON.stringify(error);
        }
        catch (error) {
            // tslint:disable-line: no-empty
        }
        return gError;
    }
    /**
     * @public
     * @static
     * @async
     * To get the GraphError object
     * @param {any} [error = null] - The error returned by graph service or some native error
     * @param {number} [statusCode = -1] - The status code of the response
     * @param {GraphRequestCallback} [callback] - The graph request callback function
     * @returns A promise that resolves to GraphError instance
     */
    static getError(error = null, statusCode = -1, callback) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            let gError;
            if (error && error.error) {
                gError = GraphErrorHandler_GraphErrorHandler.constructErrorFromResponse(error, statusCode);
            }
            else if (typeof Error !== "undefined" && error instanceof Error) {
                gError = GraphErrorHandler_GraphErrorHandler.constructError(error, statusCode);
            }
            else {
                gError = new GraphError(statusCode);
            }
            if (typeof callback === "function") {
                callback(gError, null);
            }
            else {
                return gError;
            }
        });
    }
}
//# sourceMappingURL=GraphErrorHandler.js.map
// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/GraphRequestUtil.js
var GraphRequestUtil = __webpack_require__(36);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/ResponseType.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @enum
 * Enum for ResponseType values
 * @property {string} ARRAYBUFFER - To download response content as an [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}
 * @property {string} BLOB - To download content as a [binary/blob] {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob}
 * @property {string} DOCUMENT - This downloads content as a document or stream
 * @property {string} JSON - To download response content as a json
 * @property {string} STREAM - To download response as a [stream]{@link https://nodejs.org/api/stream.html}
 * @property {string} TEXT - For downloading response as a text
 */
var ResponseType;
(function (ResponseType) {
    ResponseType["ARRAYBUFFER"] = "arraybuffer";
    ResponseType["BLOB"] = "blob";
    ResponseType["DOCUMENT"] = "document";
    ResponseType["JSON"] = "json";
    ResponseType["RAW"] = "raw";
    ResponseType["STREAM"] = "stream";
    ResponseType["TEXT"] = "text";
})(ResponseType || (ResponseType = {}));
//# sourceMappingURL=ResponseType.js.map
// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/GraphResponseHandler.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */


/**
 * @enum
 * Enum for document types
 * @property {string} TEXT_HTML - The text/html content type
 * @property {string} TEXT_XML - The text/xml content type
 * @property {string} APPLICATION_XML - The application/xml content type
 * @property {string} APPLICATION_XHTML - The application/xhml+xml content type
 */
var DocumentType;
(function (DocumentType) {
    DocumentType["TEXT_HTML"] = "text/html";
    DocumentType["TEXT_XML"] = "text/xml";
    DocumentType["APPLICATION_XML"] = "application/xml";
    DocumentType["APPLICATION_XHTML"] = "application/xhtml+xml";
})(DocumentType || (DocumentType = {}));
/**
 * @enum
 * Enum for Content types
 * @property {string} TEXT_PLAIN - The text/plain content type
 * @property {string} APPLICATION_JSON - The application/json content type
 */
var ContentType;
(function (ContentType) {
    ContentType["TEXT_PLAIN"] = "text/plain";
    ContentType["APPLICATION_JSON"] = "application/json";
})(ContentType || (ContentType = {}));
/**
 * @enum
 * Enum for Content type regex
 * @property {string} DOCUMENT - The regex to match document content types
 * @property {string} IMAGE - The regex to match image content types
 */
var ContentTypeRegexStr;
(function (ContentTypeRegexStr) {
    ContentTypeRegexStr["DOCUMENT"] = "^(text\\/(html|xml))|(application\\/(xml|xhtml\\+xml))$";
    ContentTypeRegexStr["IMAGE"] = "^image\\/.+";
})(ContentTypeRegexStr || (ContentTypeRegexStr = {}));
/**
 * @class
 * Class for GraphResponseHandler
 */
class GraphResponseHandler_GraphResponseHandler {
    /**
     * @private
     * @static
     * To parse Document response
     * @param {Response} rawResponse - The response object
     * @param {DocumentType} type - The type to which the document needs to be parsed
     * @returns A promise that resolves to a document content
     */
    static parseDocumentResponse(rawResponse, type) {
        try {
            if (typeof DOMParser !== "undefined") {
                return new Promise((resolve, reject) => {
                    rawResponse.text().then((xmlString) => {
                        try {
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(xmlString, type);
                            resolve(xmlDoc);
                        }
                        catch (error) {
                            reject(error);
                        }
                    });
                });
            }
            else {
                return Promise.resolve(rawResponse.body);
            }
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * @private
     * @static
     * @async
     * To convert the native Response to response content
     * @param {Response} rawResponse - The response object
     * @param {ResponseType} [responseType] - The response type value
     * @returns A promise that resolves to the converted response content
     */
    static convertResponse(rawResponse, responseType) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            if (rawResponse.status === 204) {
                // NO CONTENT
                return Promise.resolve();
            }
            let responseValue;
            try {
                switch (responseType) {
                    case ResponseType.ARRAYBUFFER:
                        responseValue = yield rawResponse.arrayBuffer();
                        break;
                    case ResponseType.BLOB:
                        responseValue = yield rawResponse.blob();
                        break;
                    case ResponseType.DOCUMENT:
                        responseValue = yield GraphResponseHandler_GraphResponseHandler.parseDocumentResponse(rawResponse, DocumentType.TEXT_XML);
                        break;
                    case ResponseType.JSON:
                        responseValue = yield rawResponse.json();
                        break;
                    case ResponseType.STREAM:
                        responseValue = yield Promise.resolve(rawResponse.body);
                        break;
                    case ResponseType.TEXT:
                        responseValue = yield rawResponse.text();
                        break;
                    default:
                        const contentType = rawResponse.headers.get("Content-type");
                        if (contentType !== null) {
                            const mimeType = contentType.split(";")[0];
                            if (new RegExp(ContentTypeRegexStr.DOCUMENT).test(mimeType)) {
                                responseValue = yield GraphResponseHandler_GraphResponseHandler.parseDocumentResponse(rawResponse, mimeType);
                            }
                            else if (new RegExp(ContentTypeRegexStr.IMAGE).test(mimeType)) {
                                responseValue = rawResponse.blob();
                            }
                            else if (mimeType === ContentType.TEXT_PLAIN) {
                                responseValue = yield rawResponse.text();
                            }
                            else if (mimeType === ContentType.APPLICATION_JSON) {
                                responseValue = yield rawResponse.json();
                            }
                            else {
                                responseValue = Promise.resolve(rawResponse.body);
                            }
                        }
                        else {
                            /**
                             * RFC specification {@link https://tools.ietf.org/html/rfc7231#section-3.1.1.5} says:
                             *  A sender that generates a message containing a payload body SHOULD
                             *  generate a Content-Type header field in that message unless the
                             *  intended media type of the enclosed representation is unknown to the
                             *  sender.  If a Content-Type header field is not present, the recipient
                             *  MAY either assume a media type of "application/octet-stream"
                             *  ([RFC2046], Section 4.5.1) or examine the data to determine its type.
                             *
                             *  So assuming it as a stream type so returning the body.
                             */
                            responseValue = Promise.resolve(rawResponse.body);
                        }
                        break;
                }
            }
            catch (error) {
                throw error;
            }
            return responseValue;
        });
    }
    /**
     * @public
     * @static
     * @async
     * To get the parsed response
     * @param {Response} rawResponse - The response object
     * @param {ResponseType} [responseType] - The response type value
     * @param {GraphRequestCallback} [callback] - The graph request callback function
     * @returns The parsed response
     */
    static getResponse(rawResponse, responseType, callback) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                if (responseType === ResponseType.RAW) {
                    return Promise.resolve(rawResponse);
                }
                else {
                    const response = yield GraphResponseHandler_GraphResponseHandler.convertResponse(rawResponse, responseType);
                    if (rawResponse.ok) {
                        // Status Code 2XX
                        if (typeof callback === "function") {
                            callback(null, response);
                        }
                        else {
                            return response;
                        }
                    }
                    else {
                        // NOT OK Response
                        throw response;
                    }
                }
            }
            catch (error) {
                throw error;
            }
        });
    }
}
//# sourceMappingURL=GraphResponseHandler.js.map
// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/RequestMethod.js
var RequestMethod = __webpack_require__(15);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/GraphRequest.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */







/**
 * @class
 * A Class representing GraphRequest
 */
class GraphRequest_GraphRequest {
    /* tslint:enable: variable-name */
    /**
     * @public
     * @constructor
     * Creates an instance of GraphRequest
     * @param {HTTPClient} httpClient - The HTTPClient instance
     * @param {ClientOptions} config - The options for making request
     * @param {string} path - A path string
     */
    constructor(httpClient, config, path) {
        /**
         * @private
         * Parses the path string and creates URLComponents out of it
         * @param {string} path - The request path string
         * @returns Nothing
         */
        this.parsePath = (path) => {
            // Strips out the base of the url if they passed in
            if (path.indexOf("https://") !== -1) {
                path = path.replace("https://", "");
                // Find where the host ends
                const endOfHostStrPos = path.indexOf("/");
                if (endOfHostStrPos !== -1) {
                    // Parse out the host
                    this.urlComponents.host = "https://" + path.substring(0, endOfHostStrPos);
                    // Strip the host from path
                    path = path.substring(endOfHostStrPos + 1, path.length);
                }
                // Remove the following version
                const endOfVersionStrPos = path.indexOf("/");
                if (endOfVersionStrPos !== -1) {
                    // Parse out the version
                    this.urlComponents.version = path.substring(0, endOfVersionStrPos);
                    // Strip version from path
                    path = path.substring(endOfVersionStrPos + 1, path.length);
                }
            }
            // Strip out any leading "/"
            if (path.charAt(0) === "/") {
                path = path.substr(1);
            }
            const queryStrPos = path.indexOf("?");
            if (queryStrPos === -1) {
                // No query string
                this.urlComponents.path = path;
            }
            else {
                this.urlComponents.path = path.substr(0, queryStrPos);
                // Capture query string into oDataQueryParams and otherURLQueryParams
                const queryParams = path.substring(queryStrPos + 1, path.length).split("&");
                for (const queryParam of queryParams) {
                    this.parseQueryParameter(queryParam);
                }
            }
        };
        this.httpClient = httpClient;
        this.config = config;
        this.urlComponents = {
            host: this.config.baseUrl,
            version: this.config.defaultVersion,
            oDataQueryParams: {},
            otherURLQueryParams: {},
            otherURLQueryOptions: [],
        };
        this._headers = {};
        this._options = {};
        this._middlewareOptions = [];
        this.parsePath(path);
    }
    /**
     * @private
     * Adds the query parameter as comma separated values
     * @param {string} propertyName - The name of a property
     * @param {string|string[]} propertyValue - The vale of a property
     * @param {IArguments} additionalProperties - The additional properties
     * @returns Nothing
     */
    addCsvQueryParameter(propertyName, propertyValue, additionalProperties) {
        // If there are already $propertyName value there, append a ","
        this.urlComponents.oDataQueryParams[propertyName] = this.urlComponents.oDataQueryParams[propertyName] ? this.urlComponents.oDataQueryParams[propertyName] + "," : "";
        let allValues = [];
        if (additionalProperties.length > 1 && typeof propertyValue === "string") {
            allValues = Array.prototype.slice.call(additionalProperties);
        }
        else if (typeof propertyValue === "string") {
            allValues.push(propertyValue);
        }
        else {
            allValues = allValues.concat(propertyValue);
        }
        this.urlComponents.oDataQueryParams[propertyName] += allValues.join(",");
    }
    /**
     * @private
     * Builds the full url from the URLComponents to make a request
     * @returns The URL string that is qualified to make a request to graph endpoint
     */
    buildFullUrl() {
        const url = Object(GraphRequestUtil["d" /* urlJoin */])([this.urlComponents.host, this.urlComponents.version, this.urlComponents.path]) + this.createQueryString();
        if (this.config.debugLogging) {
            console.log(url); // tslint:disable-line: no-console
        }
        return url;
    }
    /**
     * @private
     * Builds the query string from the URLComponents
     * @returns The Constructed query string
     */
    createQueryString() {
        // Combining query params from oDataQueryParams and otherURLQueryParams
        const urlComponents = this.urlComponents;
        const query = [];
        if (Object.keys(urlComponents.oDataQueryParams).length !== 0) {
            for (const property in urlComponents.oDataQueryParams) {
                if (urlComponents.oDataQueryParams.hasOwnProperty(property)) {
                    query.push(property + "=" + urlComponents.oDataQueryParams[property]);
                }
            }
        }
        if (Object.keys(urlComponents.otherURLQueryParams).length !== 0) {
            for (const property in urlComponents.otherURLQueryParams) {
                if (urlComponents.otherURLQueryParams.hasOwnProperty(property)) {
                    query.push(property + "=" + urlComponents.otherURLQueryParams[property]);
                }
            }
        }
        if (urlComponents.otherURLQueryOptions.length !== 0) {
            for (const str of urlComponents.otherURLQueryOptions) {
                query.push(str);
            }
        }
        return query.length > 0 ? "?" + query.join("&") : "";
    }
    /**
     * @private
     * Parses the query parameters to set the urlComponents property of the GraphRequest object
     * @param {string|KeyValuePairObjectStringNumber} queryDictionaryOrString - The query parameter
     * @returns The same GraphRequest instance that is being called with
     */
    parseQueryParameter(queryDictionaryOrString) {
        if (typeof queryDictionaryOrString === "string") {
            if (queryDictionaryOrString.charAt(0) === "?") {
                queryDictionaryOrString = queryDictionaryOrString.substring(1);
            }
            if (queryDictionaryOrString.indexOf("&") !== -1) {
                const queryParams = queryDictionaryOrString.split("&");
                for (const str of queryParams) {
                    this.parseQueryParamenterString(str);
                }
            }
            else {
                this.parseQueryParamenterString(queryDictionaryOrString);
            }
        }
        else if (queryDictionaryOrString.constructor === Object) {
            for (const key in queryDictionaryOrString) {
                if (queryDictionaryOrString.hasOwnProperty(key)) {
                    this.setURLComponentsQueryParamater(key, queryDictionaryOrString[key]);
                }
            }
        }
        return this;
    }
    /**
     * @private
     * Parses the query parameter of string type to set the urlComponents property of the GraphRequest object
     * @param {string} queryParameter - the query parameters
     * returns nothing
     */
    parseQueryParamenterString(queryParameter) {
        /* The query key-value pair must be split on the first equals sign to avoid errors in parsing nested query parameters.
                 Example-> "/me?$expand=home($select=city)" */
        if (this.isValidQueryKeyValuePair(queryParameter)) {
            const indexOfFirstEquals = queryParameter.indexOf("=");
            const paramKey = queryParameter.substring(0, indexOfFirstEquals);
            const paramValue = queryParameter.substring(indexOfFirstEquals + 1);
            this.setURLComponentsQueryParamater(paramKey, paramValue);
        }
        else {
            /* Push values which are not of key-value structure.
            Example-> Handle an invalid input->.query(test), .query($select($select=name)) and let the Graph API respond with the error in the URL*/
            this.urlComponents.otherURLQueryOptions.push(queryParameter);
        }
    }
    /**
     * @private
     * Sets values into the urlComponents property of GraphRequest object.
     * @param {string} paramKey - the query parameter key
     * @param {string} paramValue - the query paramter value
     * @returns nothing
     */
    setURLComponentsQueryParamater(paramKey, paramValue) {
        if (GraphRequestUtil["b" /* oDataQueryNames */].indexOf(paramKey) !== -1) {
            const currentValue = this.urlComponents.oDataQueryParams[paramKey];
            const isValueAppendable = currentValue && (paramKey === "$expand" || paramKey === "$select" || paramKey === "$orderby");
            this.urlComponents.oDataQueryParams[paramKey] = isValueAppendable ? currentValue + "," + paramValue : paramValue;
        }
        else {
            this.urlComponents.otherURLQueryParams[paramKey] = paramValue;
        }
    }
    /**
     * @private
     * Check if the query parameter string has a valid key-value structure
     * @param {string} queryString - the query parameter string. Example -> "name=value"
     * #returns true if the query string has a valid key-value structure else false
     */
    isValidQueryKeyValuePair(queryString) {
        const indexofFirstEquals = queryString.indexOf("=");
        if (indexofFirstEquals === -1) {
            return false;
        }
        const indexofOpeningParanthesis = queryString.indexOf("(");
        if (indexofOpeningParanthesis !== -1 && queryString.indexOf("(") < indexofFirstEquals) {
            // Example -> .query($select($expand=true));
            return false;
        }
        return true;
    }
    /**
     * @private
     * Updates the custom headers and options for a request
     * @param {FetchOptions} options - The request options object
     * @returns Nothing
     */
    updateRequestOptions(options) {
        const optionsHeaders = Object.assign({}, options.headers);
        if (this.config.fetchOptions !== undefined) {
            const fetchOptions = Object.assign({}, this.config.fetchOptions);
            Object.assign(options, fetchOptions);
            if (typeof this.config.fetchOptions.headers !== undefined) {
                options.headers = Object.assign({}, this.config.fetchOptions.headers);
            }
        }
        Object.assign(options, this._options);
        if (options.headers !== undefined) {
            Object.assign(optionsHeaders, options.headers);
        }
        Object.assign(optionsHeaders, this._headers);
        options.headers = optionsHeaders;
    }
    /**
     * @private
     * @async
     * Adds the custom headers and options to the request and makes the HTTPClient send request call
     * @param {RequestInfo} request - The request url string or the Request object value
     * @param {FetchOptions} options - The options to make a request
     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
     * @returns A promise that resolves to the response content
     */
    send(request, options, callback) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            let rawResponse;
            const middlewareControl = new MiddlewareControl["a" /* MiddlewareControl */](this._middlewareOptions);
            this.updateRequestOptions(options);
            try {
                const context = yield this.httpClient.sendRequest({
                    request,
                    options,
                    middlewareControl,
                });
                rawResponse = context.response;
                const response = yield GraphResponseHandler_GraphResponseHandler.getResponse(rawResponse, this._responseType, callback);
                return response;
            }
            catch (error) {
                let statusCode;
                if (typeof rawResponse !== "undefined") {
                    statusCode = rawResponse.status;
                }
                const gError = yield GraphErrorHandler_GraphErrorHandler.getError(error, statusCode, callback);
                throw gError;
            }
        });
    }
    /**
     * @private
     * Checks if the content-type is present in the _headers property. If not present, defaults the content-type to application/json
     * @param none
     * @returns nothing
     */
    setHeaderContentType() {
        if (!this._headers) {
            this.header("Content-Type", "application/json");
            return;
        }
        const headerKeys = Object.keys(this._headers);
        for (const headerKey of headerKeys) {
            if (headerKey.toLowerCase() === "content-type") {
                return;
            }
        }
        // Default the content-type to application/json in case the content-type is not present in the header
        this.header("Content-Type", "application/json");
    }
    /**
     * @public
     * Sets the custom header for a request
     * @param {string} headerKey - A header key
     * @param {string} headerValue - A header value
     * @returns The same GraphRequest instance that is being called with
     */
    header(headerKey, headerValue) {
        this._headers[headerKey] = headerValue;
        return this;
    }
    /**
     * @public
     * Sets the custom headers for a request
     * @param {KeyValuePairObjectStringNumber | HeadersInit} headers - The request headers
     * @returns The same GraphRequest instance that is being called with
     */
    headers(headers) {
        for (const key in headers) {
            if (headers.hasOwnProperty(key)) {
                this._headers[key] = headers[key];
            }
        }
        return this;
    }
    /**
     * @public
     * Sets the option for making a request
     * @param {string} key - The key value
     * @param {any} value - The value
     * @returns The same GraphRequest instance that is being called with
     */
    option(key, value) {
        this._options[key] = value;
        return this;
    }
    /**
     * @public
     * Sets the options for making a request
     * @param {{ [key: string]: any }} options - The options key value pair
     * @returns The same GraphRequest instance that is being called with
     */
    options(options) {
        for (const key in options) {
            if (options.hasOwnProperty(key)) {
                this._options[key] = options[key];
            }
        }
        return this;
    }
    /**
     * @public
     * Sets the middleware options for a request
     * @param {MiddlewareOptions[]} options - The array of middleware options
     * @returns The same GraphRequest instance that is being called with
     */
    middlewareOptions(options) {
        this._middlewareOptions = options;
        return this;
    }
    /**
     * @public
     * Sets the api endpoint version for a request
     * @param {string} version - The version value
     * @returns The same GraphRequest instance that is being called with
     */
    version(version) {
        this.urlComponents.version = version;
        return this;
    }
    /**
     * @public
     * Sets the api endpoint version for a request
     * @param {ResponseType} responseType - The response type value
     * @returns The same GraphRequest instance that is being called with
     */
    responseType(responseType) {
        this._responseType = responseType;
        return this;
    }
    /**
     * @public
     * To add properties for select OData Query param
     * @param {string|string[]} properties - The Properties value
     * @returns The same GraphRequest instance that is being called with, after adding the properties for $select query
     */
    /*
     * Accepts .select("displayName,birthday")
     *     and .select(["displayName", "birthday"])
     *     and .select("displayName", "birthday")
     *
     */
    select(properties) {
        this.addCsvQueryParameter("$select", properties, arguments);
        return this;
    }
    /**
     * @public
     * To add properties for expand OData Query param
     * @param {string|string[]} properties - The Properties value
     * @returns The same GraphRequest instance that is being called with, after adding the properties for $expand query
     */
    expand(properties) {
        this.addCsvQueryParameter("$expand", properties, arguments);
        return this;
    }
    /**
     * @public
     * To add properties for orderby OData Query param
     * @param {string|string[]} properties - The Properties value
     * @returns The same GraphRequest instance that is being called with, after adding the properties for $orderby query
     */
    orderby(properties) {
        this.addCsvQueryParameter("$orderby", properties, arguments);
        return this;
    }
    /**
     * @public
     * To add query string for filter OData Query param. The request URL accepts only one $filter Odata Query option and its value is set to the most recently passed filter query string.
     * @param {string} filterStr - The filter query string
     * @returns The same GraphRequest instance that is being called with, after adding the $filter query
     */
    filter(filterStr) {
        this.urlComponents.oDataQueryParams.$filter = filterStr;
        return this;
    }
    /**
     * @public
     * To add criterion for search OData Query param. The request URL accepts only one $search Odata Query option and its value is set to the most recently passed search criterion string.
     * @param {string} searchStr - The search criterion string
     * @returns The same GraphRequest instance that is being called with, after adding the $search query criteria
     */
    search(searchStr) {
        this.urlComponents.oDataQueryParams.$search = searchStr;
        return this;
    }
    /**
     * @public
     * To add number for top OData Query param. The request URL accepts only one $top Odata Query option and its value is set to the most recently passed number value.
     * @param {number} n - The number value
     * @returns The same GraphRequest instance that is being called with, after adding the number for $top query
     */
    top(n) {
        this.urlComponents.oDataQueryParams.$top = n;
        return this;
    }
    /**
     * @public
     * To add number for skip OData Query param. The request URL accepts only one $skip Odata Query option and its value is set to the most recently passed number value.
     * @param {number} n - The number value
     * @returns The same GraphRequest instance that is being called with, after adding the number for the $skip query
     */
    skip(n) {
        this.urlComponents.oDataQueryParams.$skip = n;
        return this;
    }
    /**
     * @public
     * To add token string for skipToken OData Query param. The request URL accepts only one $skipToken Odata Query option and its value is set to the most recently passed token value.
     * @param {string} token - The token value
     * @returns The same GraphRequest instance that is being called with, after adding the token string for $skipToken query option
     */
    skipToken(token) {
        this.urlComponents.oDataQueryParams.$skipToken = token;
        return this;
    }
    /**
     * @public
     * To add boolean for count OData Query param. The URL accepts only one $count Odata Query option and its value is set to the most recently passed boolean value.
     * @param {boolean} isCount - The count boolean
     * @returns The same GraphRequest instance that is being called with, after adding the boolean value for the $count query option
     */
    count(isCount = false) {
        this.urlComponents.oDataQueryParams.$count = isCount.toString();
        return this;
    }
    /**
     * @public
     * Appends query string to the urlComponent
     * @param {string|KeyValuePairObjectStringNumber} queryDictionaryOrString - The query value
     * @returns The same GraphRequest instance that is being called with, after appending the query string to the url component
     */
    /*
     * Accepts .query("displayName=xyz")
     *     and .select({ name: "value" })
     */
    query(queryDictionaryOrString) {
        return this.parseQueryParameter(queryDictionaryOrString);
    }
    /**
     * @public
     * @async
     * Makes a http request with GET method
     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
     * @returns A promise that resolves to the get response
     */
    get(callback) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            const url = this.buildFullUrl();
            const options = {
                method: RequestMethod["a" /* RequestMethod */].GET,
            };
            try {
                const response = yield this.send(url, options, callback);
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * @async
     * Makes a http request with POST method
     * @param {any} content - The content that needs to be sent with the request
     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
     * @returns A promise that resolves to the post response
     */
    post(content, callback) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            const url = this.buildFullUrl();
            const options = {
                method: RequestMethod["a" /* RequestMethod */].POST,
                body: Object(GraphRequestUtil["c" /* serializeContent */])(content),
            };
            const className = content && content.constructor && content.constructor.name;
            if (className === "FormData") {
                // Content-Type headers should not be specified in case the of FormData type content
                options.headers = {};
            }
            else {
                this.setHeaderContentType();
                options.headers = this._headers;
            }
            try {
                const response = yield this.send(url, options, callback);
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * @async
     * Alias for Post request call
     * @param {any} content - The content that needs to be sent with the request
     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
     * @returns A promise that resolves to the post response
     */
    create(content, callback) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                return yield this.post(content, callback);
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * @async
     * Makes http request with PUT method
     * @param {any} content - The content that needs to be sent with the request
     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
     * @returns A promise that resolves to the put response
     */
    put(content, callback) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            const url = this.buildFullUrl();
            this.setHeaderContentType();
            const options = {
                method: RequestMethod["a" /* RequestMethod */].PUT,
                body: Object(GraphRequestUtil["c" /* serializeContent */])(content),
            };
            try {
                const response = yield this.send(url, options, callback);
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * @async
     * Makes http request with PATCH method
     * @param {any} content - The content that needs to be sent with the request
     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
     * @returns A promise that resolves to the patch response
     */
    patch(content, callback) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            const url = this.buildFullUrl();
            this.setHeaderContentType();
            const options = {
                method: RequestMethod["a" /* RequestMethod */].PATCH,
                body: Object(GraphRequestUtil["c" /* serializeContent */])(content),
            };
            try {
                const response = yield this.send(url, options, callback);
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * @async
     * Alias for PATCH request
     * @param {any} content - The content that needs to be sent with the request
     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
     * @returns A promise that resolves to the patch response
     */
    update(content, callback) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                return yield this.patch(content, callback);
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * @async
     * Makes http request with DELETE method
     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
     * @returns A promise that resolves to the delete response
     */
    delete(callback) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            const url = this.buildFullUrl();
            const options = {
                method: RequestMethod["a" /* RequestMethod */].DELETE,
            };
            try {
                const response = yield this.send(url, options, callback);
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * @async
     * Alias for delete request call
     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
     * @returns A promise that resolves to the delete response
     */
    del(callback) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            try {
                return yield this.delete(callback);
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * @async
     * Makes a http request with GET method to read response as a stream.
     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
     * @returns A promise that resolves to the getStream response
     */
    getStream(callback) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            const url = this.buildFullUrl();
            const options = {
                method: RequestMethod["a" /* RequestMethod */].GET,
            };
            this.responseType(ResponseType.STREAM);
            try {
                const stream = yield this.send(url, options, callback);
                return stream;
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * @public
     * @async
     * Makes a http request with GET method to read response as a stream.
     * @param {any} stream - The stream instance
     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call
     * @returns A promise that resolves to the putStream response
     */
    putStream(stream, callback) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            const url = this.buildFullUrl();
            const options = {
                method: RequestMethod["a" /* RequestMethod */].PUT,
                headers: {
                    "Content-Type": "application/octet-stream",
                },
                body: stream,
            };
            try {
                const response = yield this.send(url, options, callback);
                return response;
            }
            catch (error) {
                throw error;
            }
        });
    }
}
//# sourceMappingURL=GraphRequest.js.map
// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/HTTPClient.js
var HTTPClient = __webpack_require__(83);

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/HTTPClientFactory.js
var HTTPClientFactory = __webpack_require__(208);

// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/ValidatePolyFilling.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @constant
 * @function
 * Validates availability of Promise and fetch in global context
 * @returns The true in case the Promise and fetch available, otherwise throws error
 */
const validatePolyFilling = () => {
    if (typeof Promise === "undefined" && typeof fetch === "undefined") {
        const error = new Error("Library cannot function without Promise and fetch. So, please provide polyfill for them.");
        error.name = "PolyFillNotAvailable";
        throw error;
    }
    else if (typeof Promise === "undefined") {
        const error = new Error("Library cannot function without Promise. So, please provide polyfill for it.");
        error.name = "PolyFillNotAvailable";
        throw error;
    }
    else if (typeof fetch === "undefined") {
        const error = new Error("Library cannot function without fetch. So, please provide polyfill for it.");
        error.name = "PolyFillNotAvailable";
        throw error;
    }
    return true;
};
//# sourceMappingURL=ValidatePolyFilling.js.map
// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/Client.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @module Client
 */






class Client_Client {
    /**
     * @private
     * @constructor
     * Creates an instance of Client
     * @param {ClientOptions} clientOptions - The options to instantiate the client object
     */
    constructor(clientOptions) {
        /**
         * @private
         * A member which stores the Client instance options
         */
        this.config = {
            baseUrl: Constants["b" /* GRAPH_BASE_URL */],
            debugLogging: false,
            defaultVersion: Constants["a" /* GRAPH_API_VERSION */],
        };
        try {
            validatePolyFilling();
        }
        catch (error) {
            throw error;
        }
        for (const key in clientOptions) {
            if (clientOptions.hasOwnProperty(key)) {
                this.config[key] = clientOptions[key];
            }
        }
        let httpClient;
        if (clientOptions.authProvider !== undefined && clientOptions.middleware !== undefined) {
            const error = new Error();
            error.name = "AmbiguityInInitialization";
            error.message = "Unable to Create Client, Please provide either authentication provider for default middleware chain or custom middleware chain not both";
            throw error;
        }
        else if (clientOptions.authProvider !== undefined) {
            httpClient = HTTPClientFactory["a" /* HTTPClientFactory */].createWithAuthenticationProvider(clientOptions.authProvider);
        }
        else if (clientOptions.middleware !== undefined) {
            httpClient = new HTTPClient["a" /* HTTPClient */](...[].concat(clientOptions.middleware));
        }
        else {
            const error = new Error();
            error.name = "InvalidMiddlewareChain";
            error.message = "Unable to Create Client, Please provide either authentication provider for default middleware chain or custom middleware chain";
            throw error;
        }
        this.httpClient = httpClient;
    }
    /**
     * @public
     * @static
     * To create a client instance with options and initializes the default middleware chain
     * @param {Options} options - The options for client instance
     * @returns The Client instance
     */
    static init(options) {
        const clientOptions = {};
        for (const i in options) {
            if (options.hasOwnProperty(i)) {
                clientOptions[i] = i === "authProvider" ? new CustomAuthenticationProvider_CustomAuthenticationProvider(options[i]) : options[i];
            }
        }
        return Client_Client.initWithMiddleware(clientOptions);
    }
    /**
     * @public
     * @static
     * To create a client instance with the Client Options
     * @param {ClientOptions} clientOptions - The options object for initializing the client
     * @returns The Client instance
     */
    static initWithMiddleware(clientOptions) {
        try {
            return new Client_Client(clientOptions);
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * @public
     * Entry point to make requests
     * @param {string} path - The path string value
     * @returns The graph request instance
     */
    api(path) {
        return new GraphRequest_GraphRequest(this.httpClient, this.config, path);
    }
}
//# sourceMappingURL=Client.js.map
// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/msal/lib-es6/error/AuthError.js
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

var AuthErrorMessage = {
    unexpectedError: {
        code: "unexpected_error",
        desc: "Unexpected error in authentication."
    },
    noWindowObjectError: {
        code: "no_window_object",
        desc: "No window object available. Details:"
    }
};
/**
 * General error class thrown by the MSAL.js library.
 */
var AuthError_AuthError = /** @class */ (function (_super) {
    tslib_es6["b" /* __extends */](AuthError, _super);
    function AuthError(errorCode, errorMessage) {
        var _this = _super.call(this, errorMessage) || this;
        Object.setPrototypeOf(_this, AuthError.prototype);
        _this.errorCode = errorCode;
        _this.errorMessage = errorMessage;
        _this.name = "AuthError";
        return _this;
    }
    AuthError.createUnexpectedError = function (errDesc) {
        return new AuthError(AuthErrorMessage.unexpectedError.code, AuthErrorMessage.unexpectedError.desc + ": " + errDesc);
    };
    AuthError.createNoWindowObjectError = function (errDesc) {
        return new AuthError(AuthErrorMessage.noWindowObjectError.code, AuthErrorMessage.noWindowObjectError.desc + " " + errDesc);
    };
    return AuthError;
}(Error));

//# sourceMappingURL=AuthError.js.map
// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/msal/lib-es6/error/ServerError.js
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


var ServerErrorMessage = {
    serverUnavailable: {
        code: "server_unavailable",
        desc: "Server is temporarily unavailable."
    },
    unknownServerError: {
        code: "unknown_server_error"
    },
};
/**
 * Error thrown when there is an error with the server code, for example, unavailability.
 */
var ServerError_ServerError = /** @class */ (function (_super) {
    tslib_es6["b" /* __extends */](ServerError, _super);
    function ServerError(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "ServerError";
        Object.setPrototypeOf(_this, ServerError.prototype);
        return _this;
    }
    ServerError.createServerUnavailableError = function () {
        return new ServerError(ServerErrorMessage.serverUnavailable.code, ServerErrorMessage.serverUnavailable.desc);
    };
    ServerError.createUnknownServerError = function (errorDesc) {
        return new ServerError(ServerErrorMessage.unknownServerError.code, errorDesc);
    };
    return ServerError;
}(AuthError_AuthError));

//# sourceMappingURL=ServerError.js.map
// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/msal/lib-es6/error/InteractionRequiredAuthError.js
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */


var InteractionRequiredAuthErrorMessage = {
    interactionRequired: {
        code: "interaction_required"
    },
    consentRequired: {
        code: "consent_required"
    },
    loginRequired: {
        code: "login_required"
    },
};
/**
 * Error thrown when the user is required to perform an interactive token request.
 */
var InteractionRequiredAuthError_InteractionRequiredAuthError = /** @class */ (function (_super) {
    tslib_es6["b" /* __extends */](InteractionRequiredAuthError, _super);
    function InteractionRequiredAuthError(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "InteractionRequiredAuthError";
        Object.setPrototypeOf(_this, InteractionRequiredAuthError.prototype);
        return _this;
    }
    InteractionRequiredAuthError.isInteractionRequiredError = function (errorString) {
        var interactionRequiredCodes = [
            InteractionRequiredAuthErrorMessage.interactionRequired.code,
            InteractionRequiredAuthErrorMessage.consentRequired.code,
            InteractionRequiredAuthErrorMessage.loginRequired.code
        ];
        return errorString && interactionRequiredCodes.indexOf(errorString) > -1;
    };
    InteractionRequiredAuthError.createLoginRequiredAuthError = function (errorDesc) {
        return new InteractionRequiredAuthError(InteractionRequiredAuthErrorMessage.loginRequired.code, errorDesc);
    };
    InteractionRequiredAuthError.createInteractionRequiredAuthError = function (errorDesc) {
        return new InteractionRequiredAuthError(InteractionRequiredAuthErrorMessage.interactionRequired.code, errorDesc);
    };
    InteractionRequiredAuthError.createConsentRequiredAuthError = function (errorDesc) {
        return new InteractionRequiredAuthError(InteractionRequiredAuthErrorMessage.consentRequired.code, errorDesc);
    };
    return InteractionRequiredAuthError;
}(ServerError_ServerError));

//# sourceMappingURL=InteractionRequiredAuthError.js.map
// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/ImplicitMSALAuthenticationProvider.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */

/**
 * @module ImplicitMSALAuthenticationProvider
 */

/**
 * @class
 * Class representing ImplicitMSALAuthenticationProvider
 * @extends AuthenticationProvider
 */
class ImplicitMSALAuthenticationProvider_ImplicitMSALAuthenticationProvider {
    /**
     * @public
     * @constructor
     * Creates an instance of ImplicitMSALAuthenticationProvider
     * @param {UserAgentApplication} msalApplication - An instance of MSAL UserAgentApplication
     * @param {MSALAuthenticationProviderOptions} options - An instance of MSALAuthenticationProviderOptions
     * @returns An instance of ImplicitMSALAuthenticationProvider
     */
    constructor(msalApplication, options) {
        this.options = options;
        this.msalApplication = msalApplication;
    }
    /**
     * @public
     * @async
     * To get the access token
     * @param {AuthenticationProviderOptions} authenticationProviderOptions - The authentication provider options object
     * @returns The promise that resolves to an access token
     */
    getAccessToken(authenticationProviderOptions) {
        return tslib_es6["a" /* __awaiter */](this, void 0, void 0, function* () {
            const options = authenticationProviderOptions;
            let scopes;
            if (typeof options !== "undefined") {
                scopes = options.scopes;
            }
            if (typeof scopes === "undefined" || scopes.length === 0) {
                scopes = this.options.scopes;
            }
            if (scopes.length === 0) {
                const error = new Error();
                error.name = "EmptyScopes";
                error.message = "Scopes cannot be empty, Please provide a scopes";
                throw error;
            }
            if (this.msalApplication.getAccount()) {
                const tokenRequest = {
                    scopes,
                };
                try {
                    const authResponse = yield this.msalApplication.acquireTokenSilent(tokenRequest);
                    return authResponse.accessToken;
                }
                catch (error) {
                    if (error instanceof InteractionRequiredAuthError_InteractionRequiredAuthError) {
                        try {
                            const authResponse = yield this.msalApplication.acquireTokenPopup(tokenRequest);
                            return authResponse.accessToken;
                        }
                        catch (error) {
                            throw error;
                        }
                    }
                    else {
                        throw error;
                    }
                }
            }
            else {
                try {
                    const tokenRequest = {
                        scopes,
                    };
                    yield this.msalApplication.loginPopup(tokenRequest);
                    const authResponse = yield this.msalApplication.acquireTokenSilent(tokenRequest);
                    return authResponse.accessToken;
                }
                catch (error) {
                    throw error;
                }
            }
        });
    }
}
//# sourceMappingURL=ImplicitMSALAuthenticationProvider.js.map
// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/MSALAuthenticationProviderOptions.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @class
 * @implements AuthenticationProviderOptions
 * Class representing MSALAuthenticationProviderOptions
 */
class MSALAuthenticationProviderOptions {
    /**
     * @public
     * @constructor
     * To create an instance of MSALAuthenticationProviderOptions
     * @param {string[]} scopes - An array of scopes
     * @returns An instance of MSALAuthenticationProviderOptions
     */
    constructor(scopes) {
        this.scopes = scopes;
    }
}
//# sourceMappingURL=MSALAuthenticationProviderOptions.js.map
// CONCATENATED MODULE: /Volumes/DATA/projects/sync247/node_modules/@microsoft/microsoft-graph-client/lib/es/index.js
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */

























//# sourceMappingURL=index.js.map
// CONCATENATED MODULE: ../capability-msgraph/src/msgraph-auth.ts
/* eslint-disable @typescript-eslint/naming-convention */
// eslint-disable-next-line @typescript-eslint/no-explicit-any


async function getToken() {
  try {
    const response = await fetch(
      `https://login.microsoftonline.com/${"fbe59500-b0cc-491b-aa3e-ffaf2699aec9"}/oauth2/v2.0/token`,
      {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: `client_id=${"997d5a04-670d-434f-a215-8e55667d8477"}
&scope=https%3A%2F%2Fgraph.microsoft.com%2F.default
&client_secret=${"i:]nT8@Vw@Ju0FX0BHFs3YqjmH/KZnxH"}
&grant_type=client_credentials`
      }
    )

    const json = await response.json()

    if (json.error) {
      const errorResponse = json 
      const error = new Error(errorResponse.error_description)
      Object.assign(error, {
        name: errorResponse.error,
        code: JSON.stringify(errorResponse.error_codes, null, 0),
        timestamp: errorResponse.timestamp,
        traceId: errorResponse.trace_id,
        correlationId: errorResponse.correlation_id,
        errorUri: errorResponse.error_uri
      })

      throw error
    } else {
      const tokenResponse = json 
      return tokenResponse
    }
  } catch (ex) {
    console.error(ex)
    throw ex
  }
}


















// CONCATENATED MODULE: ../capability-msgraph/src/msgraph-store.ts




/**
 * CI Step to interact with a Microsoft OneDrive store such as a Sharepoint folder
 * or Microsoft Teams channel documents folder
 */
class msgraph_store_MSGraphStore {
  

  

  /**
   * Provide token to this interactor for authorization
   *
   * @param accessToken MSGraph token for user with sufficient permissions
   */
  constructor() {;msgraph_store_MSGraphStore.prototype.__init.call(this);
    try {
      this.client = Client_Client.init({
        defaultVersion: 'v1.0',
        debugLogging: false,
        authProvider: this.authProvider
      })
    } catch (ex) {
      console.error(ex)
    }
  }

   async getMemberProfile(uid) {
    return this.client.api(`/users/${uid}`).get()
  }

   async updateMemberProfile({
    uid,
    ...user
  }


) {
    return this.client.api(`/users/${uid}`).patch(user)
  }

   async checkGroupOwner(uid) {
    try {
      const result = await this.client
        .api(
          `groups/${"04953fa0-7abb-454e-a5d6-b3c3a30223e6"}/members/${uid}?$select=id`
        )
        .get()
      if (!result) {
        return false
      }
      return result.id === uid
    } catch (ex) {
      console.error(ex)
      return false
    }
  }

   async deleteTeam(groupId) {
    throw new Error('Unupported by Microsoft Teams API')

    /*   const response = await this.client
                .api(`teams/${groupId}`)
                .responseType(MicrosoftGraph.ResponseType.RAW)
                .delete()

            console.log(JSON.stringify(response, null, 2)) */
  }

   async getTeamsInstalledAppDefinition(
    groupId
  )













 {
    const result










 = await this.client
      .api(
        `teams/${groupId}/installedApps?$expand=teamsAppDefinition&$filter=teamsAppDefinition/teamsAppId eq '${"a9cb905d-d960-4793-bbd7-81978f958113"}'`
      )
      .get()

    if (result && result.value && result.value.length > 0) {
      return result.value[0]
    }
    return { id: null }
  }

   async deleteThisAppFromTeam(groupId) {
    const { id } = await this.getTeamsInstalledAppDefinition(groupId)

    if (!id) {
      console.error('could not delete app from team')
      return
    }

    await this.client
      .api(`teams/${groupId}/installedApps/${id}`)
      .responseType(ResponseType.RAW)
      .delete()
  }

   async addThisAppToTeam(groupId) {
    const teamsAppInstallation = {
      'teamsApp@odata.bind': `https://graph.microsoft.com/v1.0/appCatalogs/teamsApps('${"a9cb905d-d960-4793-bbd7-81978f958113"}')`
    }

    await this.client
      .api(`teams/${groupId}/installedApps`)
      .responseType(ResponseType.RAW)
      .post(teamsAppInstallation)
  }

   async createTeam(
    {
      name,
      description
    }


,
    progressCallback
  ) {
    const teamObject = {
      'template@odata.bind':
        "https://graph.microsoft.com/beta/teamsTemplates('standard')",
      'owners@odata.bind': [
        `https://graph.microsoft.com/beta/users('${"75193827-3e97-4b5a-8aa8-f506ffb07af0"}')`
      ],
      visibility: 'Private',
      displayName: name,
      description,
      memberSettings: {
        allowCreateUpdateChannels: true,
        allowDeleteChannels: true,
        allowAddRemoveApps: false,
        allowCreateUpdateRemoveTabs: true,
        allowCreateUpdateRemoveConnectors: true
      },
      guestSettings: {
        allowCreateUpdateChannels: true,
        allowDeleteChannels: true
      },
      funSettings: {
        allowGiphy: false,
        giphyContentRating: 'Moderate',
        allowStickersAndMemes: true,
        allowCustomMemes: true
      },
      messagingSettings: {
        allowUserEditMessages: true,
        allowUserDeleteMessages: true,
        allowOwnerDeleteMessages: true,
        allowTeamMentions: false,
        allowChannelMentions: false
      },
      discoverySettings: {
        showInTeamsSearchAndSuggestions: false
      },
      installedApps: [
        {
          'teamsApp@odata.bind': `https://graph.microsoft.com/v1.0/appCatalogs/teamsApps('${"a9cb905d-d960-4793-bbd7-81978f958113"}')`
        }
      ]
    }

    const response = await this.client
      .api(`teams`)
      .version('beta')
      .responseType(ResponseType.RAW)
      .post(teamObject)

    const location = response.headers.get('location')

    let counter = 0

    return new Promise((resolve, reject) => {
      const wait = () =>
        setTimeout(async () => {
          const result = await this.client.api(location).get()

          await progressCallback(
            `${new Date().toLocaleTimeString()} ${result.status}`
          )

          if (result.status !== 'succeeded' && counter++ < 3) {
            wait()
          } else {
            resolve(null)
          }
        }, 5000)

      wait()
    })
  }

   async updateTeam({
    groupId,
    name,
    description
  }



) {
    const teamObject = {
      displayName: name,
      description
    }

    // Note: updating team in msgraph does not work for name/description must update group
    await this.client
      .api(`groups/${groupId}`)
      .responseType(ResponseType.RAW)
      .patch(teamObject)
  }

   async addMemberToTeam({
    groupid,
    uid
  }


) {
    const userObject = {
      '@odata.id': `https://graph.microsoft.com/beta/directoryObjects/${uid}`
    }

    await this.client
      .api(`groups/${groupid}/members/$ref`)
      .version('beta')
      .post(userObject)
  }

   async addOwnerToTeam({
    groupid,
    uid
  }


) {
    const userObject = {
      '@odata.id': `https://graph.microsoft.com/beta/directoryObjects/${uid}`
    }

    await this.client
      .api(`groups/${groupid}/owners/$ref`)
      .version('beta')
      .post(userObject)
  }

   async getTeamByDisplayName({
    displayName
  }

)








 {
    const responses = await this.client
      .api(`groups`)
      .version('beta')
      .filter(
        `resourceProvisioningOptions/Any(x:x eq 'Team') and startswith(displayName, '${displayName}')`
      )
      .get()

    return responses.value 













  }

   async getChannelByDescription({
    groupid,
    description
  }


)









 {
    const responses = await this.client
      .api(`teams/${groupid}/channels`)
      .version('beta')
      .filter(`description eq '${description}'`)
      .get()

    return responses.value 















  }

   async getChannelGeneral({
    groupid
  }

)









 {
    const responses = await this.client
      .api(`teams/${groupid}/channels`)
      .version('beta')
      .filter(`displayName eq 'General'`)
      .get()

    return responses.value 















  }

   async getChannel({
    groupid,
    channelid
  }


)







 {
    const response = await this.client
      .api(`teams/${groupid}/channels/${channelid}`)
      .version('beta')
      .get()

    return response 















  }

   async createChannel({
    groupid,
    displayName,
    description
  }



) {
    return this.client.api(`teams/${groupid}/channels`).version('beta').post({
      displayName,
      description,
      isFavoriteByDefault: true,
      membershipType: 'standard'
    })
  }

  // NOT CURRENTLY SUPPORTED USING APPLICATION PRIVILEGES (KNOWN MSGRAPH ISSUE)
   async updateTeamPhoto({
    groupid,
    photo
  }


) {
    await this.client
      .api(`teams/${groupid}/photo`)
      .version('beta')
      .header('content-type', 'image/jpeg')
      .put(photo)
  }

  /**
   * Helper callback that simulates a msal AuthProvider and just returns the stored token
   * Called by the msgraph runtime
   */
   __init() {this.authProvider = async (
    callback
  ) => {
    if (!this.accessToken) {
      await this.refreshToken()
    }

    callback(null, this.accessToken.access_token)
  }}

   async refreshToken() {
    this.accessToken = await getToken()

    if (this.accessToken.expires_in > 60) {
      setTimeout(() => {
        this.accessToken = null
      }, (this.accessToken.expires_in - 60) * 1000)
    } else {
      console.log('ACCESS TOKEN EXPIRES IN LESS THAN 1 MINUTE')
    }
  }
}

/* harmony default export */ var msgraph_store = (msgraph_store_MSGraphStore);

// CONCATENATED MODULE: ../capability-msgraph/src/index.ts






// note: do not export testing-framework as msw distorts response in cloudlfare environment

class src_MicrosoftGraphCapability {
  constructor(app) {
    app.msgraph = new msgraph_store_MSGraphStore()
  }
}

// EXTERNAL MODULE: /Volumes/DATA/projects/sync247/node_modules/reactive-cards/src/index.ts + 3 modules
var reactive_cards_src = __webpack_require__(0);

// CONCATENATED MODULE: ../skill-provision/src/provisionNumber.ts








async function provisionNumber(
  app





,
  context,
  data




) {
  let {
    member: userLocalId,
    virtualnumber: virtualNumber,
    // eslint-disable-next-line prefer-const
    provider: carrierProvider
  } = data

  virtualNumber = app.carrier.cleanNumber(virtualNumber)

  await context.response.send(
    `Provisioning ${app.carrier.beautifyNumber(
      virtualNumber
    )} on ${carrierProvider}`
  )

  let userGlobalId

  if (userLocalId === 'self') {
    userLocalId = context['bot.From'].localid
    userGlobalId = context['bot.From'].id
  } else {
    const getProviderSpecialistResponse = await app.store.getProviderSpecialist(
      {
        'bot.Provider': context['bot.Provider'],
        userLocalId
      }
    )

    if (
      !getProviderSpecialistResponse ||
      !getProviderSpecialistResponse.userGlobalId
    ) {
      await context.response.send(
        `Sorry, could not find user details in the key-value store;  try removing and adding user from sync24-7 team again`
      )
      return
    }

    userGlobalId = getProviderSpecialistResponse.userGlobalId
  }

  const user = await app.msgraph.getMemberProfile(userGlobalId)

  if (!user.mobilePhone || user.mobilePhone.length < 10) {
    await context.response.send(
      `Provisioned specialist must have a physical mobile number set in Active Directory.  Please update using Microsoft|365 admin portal and try again.`
    )
    return
  }

  const physicalNumber = `+${app.carrier.cleanNumber(user.mobilePhone)}`

  const provisionedNumberDetails = await app.carrier.getIncomingPhoneNumber(
    carrierProvider,
    virtualNumber
  )

  if (!provisionedNumberDetails) {
    await context.response.send(
      `Could not find exactly one match to that number in your account;   please check the number`
    )
    return
  }

  provisionedNumberDetails.friendly_name =
    provisionedNumberDetails.friendly_name ||
    app.carrier.beautifyNumber(provisionedNumberDetails.phone_number)

  if (
    !provisionedNumberDetails.capabilities.sms ||
    !provisionedNumberDetails.capabilities.voice
  ) {
    await context.response.send(
      `That number is not both voice and SMS enabled;  please try a different one`
    )
    return
  }

  await context.response.send(
    `Found virtual number ${provisionedNumberDetails.friendly_name}`
  )

  // Double check physical number is not a virtual number

  const getPhysical = await app.store.getVirtualNumberTeam({
    virtualNumber: physicalNumber
  })

  if (getPhysical) {
    await context.response.send(
      `The mobile number ${app.carrier.beautifyNumber(
        physicalNumber
      )} on this account is already a provisioned number for ${
        getPhysical.userName
      }; I cannot provision to it or I might get in an infinite loop;  please update the Microsoft|365 user profile mobile number to a real world number`
    )
    return
  }

  // Double check virtual number is not already provisioned

  const getVirtual = await app.store.getVirtualNumberTeam({
    virtualNumber: `+${virtualNumber}`
  })

  if (getVirtual) {
    await context.response.send(
      `The virtual number ${app.carrier.beautifyNumber(
        virtualNumber
      )} on this account is already a provisioned to ${
        getVirtual.userName
      }; please unprovision it first before provisioning it again`
    )
    return
  }

  const finalProvisionedNumberDetails = await app.carrier.updateIncomingPhoneNumber(
    carrierProvider,
    provisionedNumberDetails.sid,
    {
      friendly_name: `${
        user.displayName
      } ${provisionedNumberDetails.friendly_name.replace(/^[^+(0-9]*/, '')}`
    }
  )

  virtualNumber = finalProvisionedNumberDetails.phone_number

  await context.response.send(
    `Updated virtual number to ${
      finalProvisionedNumberDetails.friendly_name
    } and pairing to physical number ${app.carrier.beautifyNumber(
      physicalNumber
    )}`
  )

  try {
    await app.msgraph.updateMemberProfile({
      uid: userGlobalId,
      businessPhones: [virtualNumber]
    })
  } catch (ex) {
    if (ex.statusCode === 403) {
      await context.response.send(
        `Cannot update business phones field for "${user.displayName}" in the Azure AD;  this is for cosmetic purposes only, but you may wish to do so in the Microsoft|365 admin portal.  You shouldn't see this message for non administrator accounts.`
      )
    } else {
      console.error(ex)
      return
    }
  }

  const partialTeamSiteName = `sync ${app.carrier
    .beautifyNumber(virtualNumber)
    .replace(/^\+/, '')}`

  let teamSiteName = `${partialTeamSiteName} ${user.surname}`

  if (false) {} else if (true) {
    teamSiteName += '-dev'
  }

  await app.db
    .collection('temp')
    .doc(teamSiteName)
    .set({
      carrierProvider,
      userGlobalId,
      'bot.conversation': JSON.stringify(context['bot.Conversation']),
      virtualNumber,
      physicalNumber,
      userName: user.displayName,
      userGivenName: user.givenName,
      userSurname: user.surname,
      role: 'provisioned'
    })

  const existingTeams = await app.msgraph.getTeamByDisplayName({
    displayName: partialTeamSiteName
  })

  if (!existingTeams || existingTeams.length === 0) {
    const card = iopa_botadapter_src["CardFactory"].heroCard(
      'Creating Team',
      `Creating a new team site "${teamSiteName}" for ${user.displayName}.   This may take up to twenty minutes to complete.`
    )

    await Promise.all([
      context.response.send(card),
      app.msgraph.createTeam(
        {
          name: teamSiteName,
          description: `Provisioned Sync24-7 environment for ${user.displayName}, ${user.jobTitle} ${"development"}`
        },
        async (text) => {
          console.log(text)
        }
      )
    ])
  } else {
    const [existingTeam] = existingTeams

    const card = iopa_botadapter_src["CardFactory"].heroCard(
      'Updated Team',
      `Updated team site "${existingTeam.displayName}" for ${user.displayName}`
    )

    await app.msgraph.deleteThisAppFromTeam(existingTeam.id)

    await app.msgraph.updateTeam({
      groupId: existingTeam.id,
      name: teamSiteName,
      description: `Provisioned Sync24-7 environment for ${user.displayName}, ${user.jobTitle} ${"development"}`
    })

    await app.msgraph.addThisAppToTeam(existingTeam.id)

    await context.response.send(card)
  }
}

// CONCATENATED MODULE: ../skill-provision/src/provisionAreaCode.ts










async function provisionAreaCode(
  app





,
  context,
  data





) {
  const { member, virtualnumber: areacode, provider, locality } = data

  const availablenumbers = await app.carrier.getAvailablePhoneNumbers(
    provider,
    areacode,
    locality
  )

  if (
    !availablenumbers ||
    availablenumbers.available_phone_numbers.length === 0
  ) {
    await context.response.send(`No numbers available in areacode ${areacode}`)
    return
  }

  let tries = 0
  let virtualnumber

  do {
    virtualnumber = availablenumbers.available_phone_numbers[tries].phone_number

    try {
      const result = await app.carrier.purchaseIncomingPhoneNumber(
        provider,
        virtualnumber
      )

      if (result) {
        await provisionNumber(app, context, {
          member,
          virtualnumber: result.phone_number,
          provider
        })
        return
      }
    } catch (ex) {
      console.error(ex)
    }

    virtualnumber = null
    tries++
  } while (
    tries < 3 &&
    tries < availablenumbers.available_phone_numbers.length - 1
  )

  if (!virtualnumber) {
    await context.response.send(
      `Could not purchase an available number, please try provisioning directly in the carrier console`
    )
  }
}

// CONCATENATED MODULE: ../common-cards/src/cards-voice.tsx
/** @jsx ReactiveCards.h */


const ReactiveCardsFix = reactive_cards_src // required for certain build packagers

function VoiceMailCard({
  text,
  recordingUrl,
  fromNumber,
  toNumber,
  callerId,
  callbackPayload
}






) {
  return (
    reactive_cards_src["h"]('card', null
      , reactive_cards_src["h"]('body', null
        , reactive_cards_src["h"]('text', { size: "small", color: "accent", weight: "lighter",}, "VOICEMAIL "
           , fromNumber, " " , callerId
        )
        , reactive_cards_src["h"]('text', { size: "large",}, "Inbound Voicemail" )
        , reactive_cards_src["h"]('text', null, text)
      )
      , reactive_cards_src["h"]('actionset', null
        , reactive_cards_src["h"]('action', { type: "openurl", url: recordingUrl,}, "Source"

        )
        , reactive_cards_src["h"]('action', { type: "submit", data: callbackPayload,}, "Call back"

        )
      )
    )
  )
}

function CallRecordCard({
  title,
  duration,
  participantNumber,
  callerId,
  status,
  callbackPayload
}






) {
  return (
    reactive_cards_src["h"]('card', null
      , reactive_cards_src["h"]('body', null
        , reactive_cards_src["h"]('text', { size: "small", color: "accent", weight: "lighter",}, "VOICE "
           , participantNumber, " " , callerId || status, " DURATION "  , duration, "s"
        )
        , reactive_cards_src["h"]('text', { size: "large",}, title)
      )
      , reactive_cards_src["h"]('actionset', null
        , reactive_cards_src["h"]('action', { type: "submit", data: callbackPayload,}, "Call back"

        )
      )
    )
  )
}

// CONCATENATED MODULE: ../common-cards/src/cards-teams.tsx
/** @jsx ReactiveCards.h */


const cards_teams_ReactiveCardsFix = reactive_cards_src // required for certain build packagers

function TeamChannelLinkCard({
  title,
  text,
  label,
  'bot.Team': botTeam,
  'bot.Channel': botChannel,
  tenant
}






) {
  return (
    reactive_cards_src["h"]('card', null
      , reactive_cards_src["h"]('body', null
        , title && reactive_cards_src["h"]('text', { size: "large",}, title)
        , text && reactive_cards_src["h"]('text', { wrap: true,}, text)
      )
      , reactive_cards_src["h"]('actionset', null
        , reactive_cards_src["h"]('action', {
          type: "openurl",
          url: `https://teams.microsoft.com/l/channel/${botChannel.id}/${botChannel.name}?groupId=${botTeam.globalid}&tenantId=${tenant}`,}
        
          , label
        )
      )
    )
  )
}

function TeamLinkCard({
  title,
  text,
  label,
  'bot.Team': botTeam,
  tenant
}





) {
  return (
    reactive_cards_src["h"]('card', null
      , reactive_cards_src["h"]('body', null
        , title && reactive_cards_src["h"]('text', { size: "large",}, title)
        , text && reactive_cards_src["h"]('text', { wrap: true,}, text)
      )
      , reactive_cards_src["h"]('actionset', null
        , reactive_cards_src["h"]('action', {
          type: "openurl",
          url: `https://teams.microsoft.com/l/team/${botTeam.id}/conversations?groupId=${botTeam.globalid}&tenantId=${tenant}`,}
        
          , label
        )
      )
    )
  )
}

function HeroCard({
  title,
  text
}


) {
  return (
    reactive_cards_src["h"]('card', null
      , reactive_cards_src["h"]('body', null
        , reactive_cards_src["h"]('text', { size: "large",}, title)
        , reactive_cards_src["h"]('text', { wrap: true,}, text)
      )
    )
  )
}

// CONCATENATED MODULE: ../common-cards/src/cards-sms.tsx
/** @jsx ReactiveCards.h */


const cards_sms_ReactiveCardsFix = reactive_cards_src // required for certain build packagers

function SmsCard({
  caption,
  text
}


) {
  return (
    reactive_cards_src["h"]('card', null
      , reactive_cards_src["h"]('body', null
        , reactive_cards_src["h"]('text', { size: "small", color: "accent", weight: "lighter",}
          , caption
        )
        , text && reactive_cards_src["h"]('text', { wrap: true,}, text)
      )
    )
  )
}

// CONCATENATED MODULE: ../common-cards/src/index.tsx




// CONCATENATED MODULE: ../skill-provision/src/voicemail.tsx
/** @jsx ReactiveCards.h */
// eslint-disable-next-line @typescript-eslint/no-unused-vars











async function showVoicemail(
  app





,
  context,
  data


) {
  let { virtualNumber } = data

  virtualNumber = app.carrier.cleanNumber(virtualNumber)

  const teamRecord = await app.store.getVirtualNumberTeam({
    virtualNumber: `+${virtualNumber}`
  })

  if (!teamRecord || !teamRecord.physicalNumber) {
    await context.response.send(
      `The virtual number ${app.carrier.beautifyNumber(
        virtualNumber
      )} was not found`
    )
    return
  }

  await context.response.send(
    `Voicemail for ${
      teamRecord.userName
    } associated with virtual number ${app.carrier.beautifyNumber(
      virtualNumber
    )} and physical number ${app.carrier.beautifyNumber(
      teamRecord.physicalNumber
    )} is 
${teamRecord.voicemailText || ' set to default for the organization'}`
  )
}

async function setVoicemail(
  app





,
  context,
  data



) {
  const { voicemailText } = data
  let { virtualNumber } = data

  virtualNumber = `+${app.carrier.cleanNumber(virtualNumber)}`

  const teamRecord = await app.store.getVirtualNumberTeam({
    virtualNumber
  })

  if (!teamRecord || !teamRecord.physicalNumber) {
    await context.response.send(
      `The virtual number ${app.carrier.beautifyNumber(
        virtualNumber
      )} was not found`
    )
    return
  }

  teamRecord.virtualNumber = virtualNumber

  teamRecord.voicemailText = voicemailText

  try {
    await app.store.registerOrUpdateVirtualNumberTeam({
      virtualNumber,
      voicemailText
    })
  } catch (ex) {
    await context.response.send(
      `Cannot update voicemail in the database;  ${ex.message}`
    )
    return
  }

  const card = (
    reactive_cards_src["h"]('card', null
      , reactive_cards_src["h"]('body', null
        , reactive_cards_src["h"]('text', { size: "extraLarge",}, "Voicemail Updated" )
        , reactive_cards_src["h"]('text', null, "Updated details in the sync24-7 contact center"      )
        , reactive_cards_src["h"]('factset', null
          , reactive_cards_src["h"]('fact', {
            title: "Virtual",
            value: app.carrier.beautifyNumber(teamRecord.virtualNumber),}
          )
          , reactive_cards_src["h"]('fact', { title: "Provider", value: teamRecord.carrierProvider,} )
          , reactive_cards_src["h"]('fact', {
            title: "Mobile",
            value: app.carrier.beautifyNumber(teamRecord.physicalNumber),}
          )
          , reactive_cards_src["h"]('fact', { title: "Specialist", value: teamRecord.userName,} )
          , reactive_cards_src["h"]('fact', {
            title: "Voicemail",
            value: teamRecord.voicemailText || 'default',}
          )
          , reactive_cards_src["h"]('fact', { title: "Env", value: "development",} )
        )
      )
    )
  )

  await app.teams.sendToExistingOrNewTeamsChannel(
    {
      provider: teamRecord['bot.Provider'],
      groupId: teamRecord.teamGlobalId,
      channelDescriptor: null /** General */,
      channelName: 'General',
      botId: teamRecord.userLocalId,
      serviceUrl: teamRecord['bot.ServiceUrl'],
      activity: iopa_botadapter_src["MessageFactory"].attachment(iopa_botadapter_src["CardFactory"].reactiveCard(card))
    },
    async (ctx) => {
      /** noop */
    }
  )

  await context.response.send(
    TeamLinkCard({
      title: 'Voicemail updated',
      text: `Updated voicemail for ${
        teamRecord.userName
      } on virtual number ${app.carrier.beautifyNumber(
        virtualNumber
      )} and physical number ${app.carrier.beautifyNumber(
        teamRecord.physicalNumber
      )}`,
      label: teamRecord.teamName,
      'bot.Team': {
        id: teamRecord.teamId,
        globalid: teamRecord.teamGlobalId
      },
      tenant: "fbe59500-b0cc-491b-aa3e-ffaf2699aec9"
    })
  )
}

// CONCATENATED MODULE: ../skill-provision/src/reassignNumber.tsx
/** @jsx ReactiveCards.h */
// eslint-disable-next-line @typescript-eslint/no-unused-vars











async function reassignNumber(
  app





,
  context,
  data



) {
  let { member: userLocalId, virtualnumber: virtualNumber } = data

  try {
    virtualNumber = `+${virtualNumber}`

    // FIND TEAM RECORD FOR EXISTING ASSIGNMENT

    const teamRecord = await app.store.getVirtualNumberTeam({
      virtualNumber
    })

    if (!teamRecord) {
      await context.response.send(
        `Could not find ${virtualNumber} as a provisioned number;   please check the number`
      )
      return
    }

    teamRecord.virtualNumber = virtualNumber

    // FIND NEW ASSIGNMENT SPECIALIST DETAILS FROM BOT PROVIDER (i.e., TEAMS) AND THEN MSGRAPH

    let userGlobalId

    if (userLocalId === 'self') {
      userLocalId = context['bot.From'].localid
      userGlobalId = context['bot.From'].id
    } else {
      const getProviderSpecialistResponse = await app.store.getProviderSpecialist(
        {
          'bot.Provider': context['bot.Provider'],
          userLocalId
        }
      )

      if (
        !getProviderSpecialistResponse ||
        !getProviderSpecialistResponse.userGlobalId
      ) {
        await context.response.send(
          `Sorry, could not find specialist details in the provider-specialist key-value store;  try removing and adding user from sync24-7 team again`
        )
        return
      }

      userGlobalId = getProviderSpecialistResponse.userGlobalId
    }

    const specialist = await app.store.getSpecialist({
      userGlobalId
    })

    if (!specialist) {
      await context.response.send(
        `Sorry, could not find specialist details in the specialist key-value store;  try removing and adding user from sync24-7 team again`
      )
      return
    }

    const user = await app.msgraph.getMemberProfile(userGlobalId)

    if (!user.mobilePhone || user.mobilePhone.length < 10) {
      await context.response.send(
        `Provisioned specialist must have a physical mobile number set in Active Directory.  Please update using Microsoft|365 admin portal and try again.`
      )
      return
    }

    const physicalNumber = `+${app.carrier.cleanNumber(user.mobilePhone)}`

    await context.response.send(
      `OK, reassigning ${app.carrier.beautifyNumber(
        virtualNumber
      )} currently assigned to ${teamRecord.userName} to ${
        user.displayName
      } and associating with new physical number ${physicalNumber}`
    )

    /// /  REASSIGN

    const provisionedNumberDetails = await app.carrier.getIncomingPhoneNumber(
      teamRecord.carrierProvider,
      virtualNumber
    )

    if (!provisionedNumberDetails) {
      await context.response.send(
        `Could not find exactly one match to that number in your account;   please check the number`
      )
      return
    }

    provisionedNumberDetails.friendly_name =
      provisionedNumberDetails.friendly_name ||
      app.carrier.beautifyNumber(provisionedNumberDetails.phone_number)

    // Double check physical number is not a virtual number

    const getPhysical = await app.store.getVirtualNumberTeam({
      virtualNumber: physicalNumber
    })

    if (getPhysical) {
      await context.response.send(
        `The mobile number ${app.carrier.beautifyNumber(
          physicalNumber
        )} on this account is already a provisioned number for ${
          getPhysical.userName
        }; I cannot provision to it or I might get in an infinite loop;  please update the Microsoft|365 user profile mobile number to a real world number`
      )
      return
    }

    const finalProvisionedNumberDetails = await app.carrier.updateIncomingPhoneNumber(
      teamRecord.carrierProvider,
      provisionedNumberDetails.sid,
      {
        friendly_name: `${
          user.displayName
        } ${provisionedNumberDetails.friendly_name.replace(/^[^+(0-9]*/, '')}`
      }
    )

    virtualNumber = finalProvisionedNumberDetails.phone_number

    try {
      await app.msgraph.updateMemberProfile({
        uid: userGlobalId,
        businessPhones: [virtualNumber]
      })
    } catch (ex) {
      if (ex.statusCode === 403) {
        /** silently ignore for administrator */
      } else {
        console.error(ex)
      }
    }

    const partialTeamSiteName = `sync ${app.carrier
      .beautifyNumber(virtualNumber)
      .replace(/^\+/, '')}`

    let teamSiteName = `${partialTeamSiteName} ${user.surname}`

    if (false) {} else if (
      true
    ) {
      teamSiteName += '-dev'
    }

    const existingTeams = await app.msgraph.getTeamByDisplayName({
      displayName: partialTeamSiteName
    })

    if (!existingTeams || existingTeams.length === 0) {
      await context.response.send(
        `Could not find an existing team with a name starting ${partialTeamSiteName}, unable to reassign`
      )
      return
    }
    const [existingTeam] = existingTeams

    const newTeamRecord = {
      ...teamRecord,
      teamId: teamRecord.teamId,
      teamName: teamSiteName,
      teamGlobalId: teamRecord.teamGlobalId,
      carrierProvider: teamRecord.carrierProvider,
      userGlobalId,
      virtualNumber,
      physicalNumber,
      userName: user.displayName,
      userGivenName: user.givenName,
      userSurname: user.surname,
      role: 'provisioned'
    }

    await app.msgraph.updateTeam({
      groupId: existingTeam.id,
      name: teamSiteName,
      description: `Provisioned Sync24-7 environment for ${user.displayName}, ${user.jobTitle} ${"development"}`
    })

    try {
      await app.msgraph.addMemberToTeam({
        groupid: newTeamRecord.teamGlobalId,
        uid: userGlobalId
      })
      console.log('Added member to team')
    } catch (ex) {
      // ignore as likely already exists
    }

    await app.store.registerOrUpdateTeam(newTeamRecord)
    await app.store.registerOrUpdateVirtualNumberTeam(newTeamRecord)

    await app.store.registerSpecialist({
      userGlobalId: newTeamRecord.userGlobalId,
      virtualNumber: newTeamRecord.virtualNumber,
      provisionedNumbers: ((specialist && specialist.provisionedNumbers) || [])
        .concat(newTeamRecord.virtualNumber)
        .filter(onlyUnique)
    })

    const card = (
      reactive_cards_src["h"]('card', null
        , reactive_cards_src["h"]('body', null
          , reactive_cards_src["h"]('text', { size: "extraLarge",}, "Reassignment")
          , reactive_cards_src["h"]('text', null, "Reassignment in the sync24-7 contact center"     )
          , reactive_cards_src["h"]('factset', null
            , reactive_cards_src["h"]('fact', {
              title: "Virtual",
              value: app.carrier.beautifyNumber(newTeamRecord.virtualNumber),}
            )
            , reactive_cards_src["h"]('fact', { title: "Provider", value: newTeamRecord.carrierProvider,} )
            , reactive_cards_src["h"]('fact', {
              title: "Mobile",
              value: app.carrier.beautifyNumber(newTeamRecord.physicalNumber),}
            )
            , reactive_cards_src["h"]('fact', { title: "Specialist", value: newTeamRecord.userName,} )
            , reactive_cards_src["h"]('fact', {
              title: "Voicemail",
              value: newTeamRecord.voicemailText || 'default',}
            )
            , reactive_cards_src["h"]('fact', { title: "Env", value: "development",} )
          )
        )
      )
    )

    await app.teams.sendToExistingOrNewTeamsChannel(
      {
        provider: newTeamRecord['bot.Provider'],
        groupId: newTeamRecord.teamGlobalId,
        channelDescriptor: null /** General */,
        channelName: 'General',
        botId: newTeamRecord.userLocalId,
        serviceUrl: newTeamRecord['bot.ServiceUrl'],
        activity: iopa_botadapter_src["MessageFactory"].attachment(iopa_botadapter_src["CardFactory"].reactiveCard(card))
      },
      async (ctx) => {
        /** noop */
      }
    )

    await context.response.send(
      TeamLinkCard({
        title: 'Team updated',
        text: `Team has been succesfully updated for ${newTeamRecord.userName} ; you may wish to remove ${teamRecord.userName} from the team membership roster`,
        label: newTeamRecord.teamName,
        'bot.Team': {
          id: newTeamRecord.teamId,
          globalid: newTeamRecord.teamGlobalId
        },
        tenant: "fbe59500-b0cc-491b-aa3e-ffaf2699aec9"
      })
    )
  } catch (ex) {
    context.error(ex)
    await context.response.send(
      `An error occurred during reassignment: ${ex.message}`
    )
  }
}

function onlyUnique(
  value,
  index,
  self
) {
  return self.indexOf(value) === index
}

// CONCATENATED MODULE: ../skill-provision/src/migrateNumber.ts









async function migrateNumber(
  app





,
  context,
  virtualNumber
) {
  try {
    virtualNumber = `+${virtualNumber}`

    const teamRecord = await app.store.getVirtualNumberTeam({
      virtualNumber
    })

    if (!teamRecord) {
      await context.response.send(
        `Could not find ${virtualNumber} as a provisioned number;   please check the number`
      )
      return
    }

    teamRecord.virtualNumber = virtualNumber

    if (teamRecord.carrierProvider !== 'twilio') {
      await context.response.send(
        `Migration of virtual numbers between environments is only supported for twilio;  use unprovision command instead and manually move the number in the ${teamRecord.carrierProvider} portal`
      )
      return
    }

    await context.response.send(
      `OK, migrating ${app.carrier.beautifyNumber(virtualNumber)} assigned to ${
        teamRecord.userName
      }`
    )

    await app.store.deleteTeam(teamRecord)

    const provisionedNumberDetails = await app.carrier.getIncomingPhoneNumber(
      teamRecord.carrierProvider,
      virtualNumber
    )

    await app.carrier.updateIncomingPhoneNumber(
      teamRecord.carrierProvider,
      provisionedNumberDetails.sid,
      {
        friendly_name: `${provisionedNumberDetails.friendly_name.replace(
          /^[^+0-9(]*/,
          ''
        )}`
      }
    )

    await app.carrier.migrateIncomingPhoneNumber(
      teamRecord.carrierProvider,
      provisionedNumberDetails.sid
    )

    const partialTeamSiteName = `sync ${app.carrier
      .beautifyNumber(virtualNumber)
      .replace(/^\+/, '')}`

    const teamSiteName = `${partialTeamSiteName} UNPROVISIONED`

    await app.msgraph.updateTeam({
      groupId: teamRecord.teamGlobalId,
      name: teamSiteName,
      description: `Deprovisioned Sync24-7 environment`
    })

    let found = false

    await app.teams.sendToExistingOrNewTeamsChannel(
      {
        provider: teamRecord['bot.Provider'],
        groupId: teamRecord.teamGlobalId,
        channelDescriptor: null /** General */,
        channelName: 'General',
        botId: teamRecord.userLocalId,
        serviceUrl: teamRecord['bot.ServiceUrl'],
        activity: iopa_botadapter_src["MessageFactory"].text(
          `The virtual number ${provisionedNumberDetails.friendly_name} has been unprovisioned, pending migration`
        )
      },
      async (ctx) => {
        try {
          await app.msgraph.deleteThisAppFromTeam(teamRecord.teamGlobalId)
        } catch (ex) {
          console.error(ex)
        }
        found = true
        await context.response.send(
          TeamChannelLinkCard({
            text: `Migration removal from ${"development"} complete;  please switch to target environment and reprovision`,
            label: teamRecord.teamName,
            'bot.Team': {
              id: teamRecord.teamId,
              globalid: teamRecord.teamGlobalId
            },
            'bot.Channel': ctx['bot.Channel'],
            tenant: "fbe59500-b0cc-491b-aa3e-ffaf2699aec9"
          })
        )
      }
    )

    if (!found) {
      await context.response.send(
        `Migration removal from ${"development"} complete;  please switch to target environment and reprovision`
      )
    }
  } catch (ex) {
    context.error(ex)
    await context.response.send(
      `An error occurred during migration: ${ex.message}`
    )
  }
}

// CONCATENATED MODULE: ../skill-provision/src/unprovision.ts










async function unprovision(
  app





,
  context,
  virtualNumber
) {
  try {
    virtualNumber = `+${virtualNumber}`

    const teamRecord = await app.store.getVirtualNumberTeam({
      virtualNumber
    })

    if (!teamRecord) {
      await context.response.send(
        `Could not find ${virtualNumber} as a provisioned number;   please check the number`
      )
      return
    }

    teamRecord.virtualNumber = virtualNumber

    await context.response.send(
      `OK, unprovisioning ${app.carrier.beautifyNumber(
        virtualNumber
      )} assigned to ${teamRecord.userName}`
    )

    await app.store.deleteTeam(teamRecord)

    const provisionedNumberDetails = await app.carrier.getIncomingPhoneNumber(
      teamRecord.carrierProvider,
      virtualNumber
    )

    await app.carrier.updateIncomingPhoneNumber(
      teamRecord.carrierProvider,
      provisionedNumberDetails.sid,
      {
        friendly_name: `${provisionedNumberDetails.friendly_name.replace(
          /^[^+0-9(]*/,
          ''
        )}`
      }
    )

    const partialTeamSiteName = `sync ${app.carrier
      .beautifyNumber(virtualNumber)
      .replace(/^\+/, '')}`

    const teamSiteName = `${partialTeamSiteName} UNPROVISIONED`

    await app.msgraph.updateTeam({
      groupId: teamRecord.teamGlobalId,
      name: teamSiteName,
      description: `Deprovisioned Sync24-7 environment`
    })

    let found = false

    await app.teams.sendToExistingOrNewTeamsChannel(
      {
        provider: teamRecord['bot.Provider'],
        groupId: teamRecord.teamGlobalId,
        channelDescriptor: null /** General */,
        channelName: 'General',
        botId: teamRecord.userLocalId,
        serviceUrl: teamRecord['bot.ServiceUrl'],
        activity: iopa_botadapter_src["MessageFactory"].text(
          `The virtual number ${provisionedNumberDetails.friendly_name} has been unprovisioned by the administrator`
        )
      },
      async (ctx) => {
        try {
          await app.msgraph.deleteThisAppFromTeam(teamRecord.teamGlobalId)
        } catch (ex) {
          console.error(ex)
        }
        found = true
        await context.response.send(
          TeamChannelLinkCard({
            text: `Unprovisioning complete;  it is now safe to delete team`,
            label: teamRecord.teamName,
            'bot.Team': {
              id: teamRecord.teamId,
              globalid: teamRecord.teamGlobalId
            },
            'bot.Channel': ctx['bot.Channel'],
            tenant: "fbe59500-b0cc-491b-aa3e-ffaf2699aec9"
          })
        )
      }
    )

    if (!found) {
      await context.response.send(`Unprovisioning complete`)
    }
  } catch (ex) {
    context.error(ex)
    await context.response.send(
      `An error occurred during unprovisioning: ${ex.message}`
    )
  }
}

// CONCATENATED MODULE: ../skill-provision/src/index.tsx
/** @jsx ReactiveCards.h */

















const src_ReactiveCardsFix = reactive_cards_src

/* harmony default export */ var skill_provision_src = (class {
  







  constructor(
    app






  ) {
    this.app = app

    app.bot
      .command('voicemail <virtualnumber> [text]')
      .action(async (context, data) => {
        if (
          data.text &&
          !(await app.msgraph.checkGroupOwner(context['bot.From'].id))
        ) {
          const card = iopa_botadapter_src["CardFactory"].heroCard(
            'Provision Error',
            `Sorry, you have to be an administrator to be able to change a voicemail greeting`
          )

          await context.response.send(card)
          return
        }
        const virtualNumber = this.app.carrier.cleanNumber(data.virtualnumber)

        const voicemailText = data.text
          ? (data.raw ).split(' ').splice(2).join(' ')
          : undefined

        if (
          !isNumeric(virtualNumber) ||
          virtualNumber.length < 8 ||
          virtualNumber.length > 15
        ) {
          await context.response.send(
            'The first argument for the voicemail command must be a valid telephone number'
          )
          return
        }

        if (voicemailText) {
          await setVoicemail(app, context, {
            virtualNumber,
            voicemailText
          })
        } else {
          await showVoicemail(app, context, {
            virtualNumber
          })
        }
      })

    app.bot
      .command('unprovision <virtualnumber>')
      .action(async (context, data) => {
        try {
          if (!(await app.msgraph.checkGroupOwner(context['bot.From'].id))) {
            const card = iopa_botadapter_src["CardFactory"].heroCard(
              'Provision Error',
              `Sorry, you have to be an administrator to be able to provision resources;  code: ${context['bot.From'].id}`
            )

            await context.response.send(card)
            return
          }
        } catch (ex) {
          console.log(ex)

          await context.response.send(ex.message)
          return
        }

        const virtualnumber = this.app.carrier.cleanNumber(data.virtualnumber)

        if (
          !isNumeric(virtualnumber) ||
          virtualnumber.length < 8 ||
          virtualnumber.length > 15
        ) {
          await context.response.send(
            'The sole argument for the unprovision command must be a valid telephone number'
          )
          return
        }

        await unprovision(this.app, context, virtualnumber)
      })

    app.bot
      .command('migrate <virtualnumber>')
      .action(async (context, data) => {
        try {
          if (!(await app.msgraph.checkGroupOwner(context['bot.From'].id))) {
            const card = iopa_botadapter_src["CardFactory"].heroCard(
              'Provision Error',
              `Sorry, you have to be an administrator to be able to change provisioning;  code: ${context['bot.From'].id}`
            )

            await context.response.send(card)
            return
          }
        } catch (ex) {
          console.log(ex)

          await context.response.send(ex.message)
          return
        }

        const virtualnumber = this.app.carrier.cleanNumber(data.virtualnumber)

        if (
          !isNumeric(virtualnumber) ||
          virtualnumber.length < 8 ||
          virtualnumber.length > 15
        ) {
          await context.response.send(
            'The sole argument for the unprovision command must be a valid telephone number'
          )
          return
        }

        await migrateNumber(this.app, context, virtualnumber)
      })

    app.bot
      .command('provision <member> <virtualnumber>')
      .option('-p --provider <name>', 'twilio or signalwire', 'twilio')
      .option(
        '-l --locality <city>',
        'restrict to city when virtual number is an area code'
      )
      .action(async (context, data) => {
        if (!(await app.msgraph.checkGroupOwner(context['bot.From'].id))) {
          const card = iopa_botadapter_src["CardFactory"].heroCard(
            'Provision Error',
            `Sorry, you have to be an administrator to be able to provision resources`
          )

          await context.response.send(card)
          return
        }

        const { virtualnumber, locality } = data

        if (virtualnumber.length === 3) {
          await provisionAreaCode(this.app, context, data)
          return
        }
        if (locality) {
          await context.response.send(
            'Locality option can only be specified with 3 digit area US codes'
          )
          return
        }
        await provisionNumber(app, context, data)
      })

    app.bot
      .command('assign <member> <virtualnumber>')
      .action(async (context, data) => {
        if (!(await app.msgraph.checkGroupOwner(context['bot.From'].id))) {
          const card = iopa_botadapter_src["CardFactory"].heroCard(
            'Provision Error',
            `Sorry, you have to be an administrator to be able to provision and reassign resources`
          )

          await context.response.send(card)
          return
        }

        const { member } = data

        const virtualnumber = this.app.carrier.cleanNumber(data.virtualnumber)

        if (
          !isNumeric(virtualnumber) ||
          virtualnumber.length < 8 ||
          virtualnumber.length > 15
        ) {
          await context.response.send(
            'The second argument for the assign command must be a valid telephone number'
          )
          return
        }

        await reassignNumber(this.app, context, {
          member,
          virtualnumber
        })
      })
  }
});

function isNumeric(value) {
  return /^\d+$/.test(value)
}

// CONCATENATED MODULE: ../skill-membership/src/index.tsx
/** @jsx ReactiveCards.h */














const skill_membership_src_ReactiveCardsFix = reactive_cards_src
// import { default as teamPhoto } from './assets/profile_photo'

/* harmony default export */ var skill_membership_src = (class {
  constructor(
    app






  ) {
    app.bot
      .command('urn:com.sync247:ChannelCreated')
      .api(
        async (
          context,
          {
            channelInfo,
            teamInfo
          }
        ) => {
          if (/^[\d()\s\-+)]+$/.test(channelInfo.name)) {
            const teamGlobalId =
              teamInfo.aadGroupId ||
              (await app.store.getTeam({ teamId: teamInfo.id })).teamGlobalId

            await context.response.send(
              TeamChannelLinkCard({
                title: `New communication channel opened`,
                label: channelInfo.name,
                'bot.Team': {
                  id: teamInfo.id,
                  globalid: teamGlobalId
                },
                'bot.Channel': channelInfo ,
                tenant: "fbe59500-b0cc-491b-aa3e-ffaf2699aec9"
              })
            )
          }
        }
      )

    app.bot
      .command('urn:com.sync247:TeamRenamed')
      .api(
        async (
          context,
          {
            channelInfo,
            teamInfo
          }
        ) => {
          await app.store.registerOrUpdateTeam({
            teamId: teamInfo.id,
            teamName: teamInfo.name
          })
        }
      )

    app.bot.command('urn:com.sync247:TeamMembersAdded').api(
      async (
        context,
        {
          members,
          teamInfo,
          'bot.Provider': botProvider
        }




      ) => {
        let addedMembers = ''

        await Promise.all(
          members.map(async (account) => {
            try {
              const user = await app.msgraph.getMemberProfile(
                account.aadObjectId
              )

              addedMembers += `${user.displayName} `

              await app.store.registerSpecialist({
                userGlobalId: account.aadObjectId,
                email: user.userPrincipalName,
                userName: user.displayName,
                physicalNumber: `+${app.carrier.cleanNumber(user.mobilePhone)}`
              })

              await app.store.registerOrUpdateTeam({
                teamId: teamInfo.id,
                teamName: teamInfo.name
              })

              await app.store.registerProviderSpecialist({
                'bot.Provider': botProvider,
                userLocalId: account.id,
                userGlobalId: account.aadObjectId
              })
            } catch (ex) {
              console.error(ex)
            }
          })
        )
        try {
          await context.response.send(
            HeroCard({
              title: 'Member added to team',
              text: `${addedMembers} added to ${teamInfo.name}.`
            })
          )
          console.log(`${addedMembers} added to ${teamInfo.name}.`)
        } catch (ex) {
          console.error(ex)
        }
      }
    )

    app.bot.command('urn:com.sync247:TeamAdded').api(
      async (
        context,
        {
          bot,
          teamInfo
        }



      ) => {
        let item











        try {
          item = (
            await app.db.collection('temp').doc(teamInfo.name).get()
          ).data() 
        } catch (ex) {
          console.error(ex)
        }

        await context.response.send(
          reactive_cards_src["h"]('card', null
            , reactive_cards_src["h"]('body', null
              , reactive_cards_src["h"]('text', { size: "extraLarge",}, "Welcome")
              , reactive_cards_src["h"]('text', null, "Welcome to the sync24-7 contact center"     )
              , reactive_cards_src["h"]('factset', null
                , item && (
                  reactive_cards_src["h"]('fact', {
                    title: "Virtual",
                    value: app.carrier.beautifyNumber(item.virtualNumber),}
                  )
                )
                , item && reactive_cards_src["h"]('fact', { title: "Provider", value: item.carrierProvider,} )
                , item && (
                  reactive_cards_src["h"]('fact', {
                    title: "Mobile",
                    value: app.carrier.beautifyNumber(item.physicalNumber),}
                  )
                )
                , item && reactive_cards_src["h"]('fact', { title: "Specialist", value: item.userName,} )
                , item && reactive_cards_src["h"]('fact', { title: "Voicemail", value: "default",} )
                , reactive_cards_src["h"]('fact', { title: "Env", value: "development",} )
              )
            )
          )
        )

        try {
          const teamWithVirtualNumber = {
            teamId: teamInfo.id,
            teamGlobalId: teamInfo.global_id,
            teamName: teamInfo.name,
            userLocalId: bot.id,
            userGlobalId: item.userGlobalId,
            carrierProvider: item.carrierProvider,
            virtualNumber: item ? item.virtualNumber : null,
            physicalNumber: item ? item.physicalNumber : null,
            'bot.Source': context['bot.Source'],
            'bot.Provider': context['bot.Provider'],
            'bot.ServiceUrl': context['bot.ServiceUrl'],
            role: item.role,
            userName: item.userName,
            userGivenName: item.userGivenName,
            userSurname: item.userSurname
          } 

          await app.store.registerOrUpdateTeam(teamWithVirtualNumber)

          if (item) {
            await app.store.registerOrUpdateVirtualNumberTeam(
              teamWithVirtualNumber
            )

            console.log('Registered virtual number in store')

            if ("75193827-3e97-4b5a-8aa8-f506ffb07af0" !== item.userGlobalId) {
              try {
                await app.msgraph.addMemberToTeam({
                  groupid: teamInfo.global_id,
                  uid: item.userGlobalId
                })
                console.log('Added member to team')
              } catch (ex) {
                console.error(ex)
                // silently log and continue
              }
            }

            try {
              if (
                false
              ) {}
            } catch (ex) {
              console.error(ex)
              // silently log and continue
            }

            console.log('Add virtual number to specialist store')
            const specialist = await app.store.getSpecialist({
              userGlobalId: item.userGlobalId
            })
            await app.store.registerSpecialist({
              userGlobalId: item.userGlobalId,
              virtualNumber: item.virtualNumber,
              provisionedNumbers: (
                (specialist && specialist.provisionedNumbers) ||
                []
              )
                .concat(item.virtualNumber)
                .filter(src_onlyUnique)
            })

            // NOT CURRENTLY SUPPORTED USING APPLICATION PRIVILEGES (KNOWN MSGRAPH ISSUE)

            /*  try {
                                  await app.msgraph.updateTeamPhoto({
                                      groupid: teamInfo.global_id,
                                      photo: teamPhoto
                                  })
                                   console.log("Updated team profile photo")
                              } catch (ex) {
                                  console.error(ex)
                              } */

            await app.db.collection('temp').doc(teamInfo.name).delete()

            context.log(`Removed temp table`)

            await context['bot.Capability'].adapter.continueConversation(
              JSON.parse(item['bot.conversation']),
              async (origcontext) => {
                await origcontext.response.status(200).send(
                  TeamLinkCard({
                    title: 'Team created',
                    text:
                      'Team has been succesfully setup successfully created',
                    label: teamInfo.name,
                    'bot.Team': {
                      id: teamInfo.id,
                      globalid: teamInfo.global_id
                    },
                    tenant: "fbe59500-b0cc-491b-aa3e-ffaf2699aec9"
                  })
                )
              }
            )

            context.log(`Team created successfully`)
          }
        } catch (ex) {
          console.error(ex)
          console.error(JSON.stringify(ex.json && ex.json()))
        }
      }
    )

    app.bot
      .command('urn:com.sync247:TeamMembersRemoved')
      .api(
        async (
          context,
          {
            members,
            teamInfo
          }
        ) => {
          const teamGlobalId =
            teamInfo.aadGroupId ||
            (await app.store.getTeam({ teamId: teamInfo.id })).teamGlobalId

          if (!teamGlobalId || teamGlobalId !== "fd4e5a27-d348-4d83-bacd-8291762eb965") {
            return
          }

          console.log('urn:com.sync247:TeamMembersRemoved')

          let count = 0

          await Promise.all(
            members.map(async (account) => {
              try {
                const specialist = await app.store.getSpecialist({
                  userGlobalId: account.aadObjectId
                })

                if (!specialist) {
                  return
                }

                await Promise.all(
                  specialist.provisionedNumbers.map(async (virtualNumber) => {
                    try {
                      const teamRecord = await app.store.getVirtualNumberTeam({
                        virtualNumber
                      })

                      teamRecord.virtualNumber = virtualNumber

                      await context.response.send(
                        `Unprovisioning ${app.carrier.beautifyNumber(
                          virtualNumber
                        )} assigned to ${teamRecord.userName}`
                      )

                      await app.store.deleteTeam(teamRecord)

                      await app.teams.sendToExistingOrNewTeamsChannel(
                        {
                          provider: teamRecord['bot.Provider'],
                          groupId: teamRecord.teamGlobalId,
                          channelDescriptor: null /** General */,
                          channelName: 'General',
                          botId: teamRecord.userLocalId,
                          serviceUrl: teamRecord['bot.ServiceUrl'],
                          activity: iopa_botadapter_src["MessageFactory"].text(
                            'The virtual number associated with this account has been unprovisioned'
                          )
                        },
                        async (ctx) => {
                          await context.response.send(
                            TeamChannelLinkCard({
                              text: `Unprovisioning complete;  it is now safe to delete team`,
                              label: teamRecord.teamName,
                              'bot.Team': {
                                id: teamRecord.teamId,
                                globalid: teamRecord.teamGlobalId
                              },
                              'bot.Channel': ctx['bot.Channel'],
                              tenant: "fbe59500-b0cc-491b-aa3e-ffaf2699aec9"
                            })
                          )
                        }
                      )

                      count++
                    } catch (ex) {
                      console.error(ex)
                    }
                  })
                )
              } catch (ex) {
                console.error(ex)
              }
            })
          )

          await context.response.send(
            `${count} virtual numbers returned to pool.`
          )
          console.log(`${count} virtual numbers returned to pool.`)
        }
      )
  }
});

function src_onlyUnique(
  value,
  index,
  self
) {
  return self.indexOf(value) === index
}

// CONCATENATED MODULE: ../skill-teams-to-sms/src/index.tsx










/* harmony default export */ var skill_teams_to_sms_src = (class {
  








  constructor(
    app







  ) {
    this.app = app

    app.bot
      .command('sms <number> [text...]')
      .description(
        'Start an SMS conversation with a new or existing participant'
      )
      .action(async (context, data) => {
        // clean arguments
        const _cleanDataNumber = this.app.carrier.cleanNumber(data.number)
        if (data.number && !src_isNumeric(_cleanDataNumber)) {
          data.text = `${data.number} ${data.text.join(' ')}`
          data.number = null
        } else {
          data.number = _cleanDataNumber
          data.text = data.text.join(' ')
        }

        // determine where this command is called from
        const teamId = context['bot.Team'].id

        if (!teamId) {
          /** 1 on 1 chat */
          await this.findTeamSendSms(context, data)
          return
        }

        const teamRecord = await this.app.store.getTeam({ teamId })

        if (!teamRecord || !teamRecord.virtualNumber) {
          await this.findTeamSendSms(context, data)
          return
        }

        // On a provisioned team
        const channel = await this.app.msgraph.getChannel({
          groupid: teamRecord.teamGlobalId,
          channelid: context['bot.Channel'].id
        })
        const isChannelNumeric = src_isNumeric(channel.description)

        if (!data.number) {
          // No Recipient Specified

          if (!isChannelNumeric) {
            await context.response.send(
              `[sync24-7] To send an sms to a parcipant you must either provide the recipient's number, or invoke the "sms" command on a participant channel not [${channel.description}]`
            )
            return
          }

          // On a provisioned team and participant numeric channel, no number provided
          if (!data.text) {
            await context.response.send(
              `[sync24-7] You are already on the channel required to send a text;  no need to use the "sms" command when on this channel, ignoring`
            )
            return
          }

          data.number = channel.description

          // On a provisioned team and participant numeric channel, no number provided and text provided as expected; sms this participant
          await this.smsFromExistingOrNewTeamsChannel(context, data, teamRecord)
          return
        }

        // With Recipient Specified

        if (!isChannelNumeric) {
          // On a general or alphanumeric non-participant channel of a provisioned team, valid numeric recipient provided
          await this.smsFromExistingOrNewTeamsChannel(context, data, teamRecord)
          return
        }

        // On a provisioned team and participant numeric channel, recipient number provided
        if (data.number !== channel.description) {
          await context.response.send(
            `When used in conjuction with a number [${data.number}], the "sms" command should be requested from the *General* channel or 1-on-bot chat.  To avoid confusion, I haven't initiated an sms message so please try this command again without the number to sms the participant identified by this channel or try again with the number from the general channel or 1 on 1 chat`
          )
          return
        }

        // On a provisioned team and participant numeric channel, recipient number provided and it matches channel
        await this.smsFromExistingOrNewTeamsChannel(context, data, teamRecord)
      })

    // catch all,  if entered in a provision team and participant channel, means a message to be sent via sms
    app.bot.action(async (context) => {
      const teamId = context['bot.Team'].id

      if (!teamId) {
        await context.response.send(
          `I don't understand what you mean;  try typing help`
        )
        return
      }

      const teamRecord = await this.app.store.getTeam({ teamId })

      if (!teamRecord) {
        await context.response.send(`Unknown command, try telling me 'help'`)
        return
      }

      if (teamRecord.role === 'provisioned') {
        await this.inParticipantChannelSendToSms(context, teamRecord)
        return
      }
      await context.response.send(`Unknown command, try telling me 'help'`)
    })
  }

  /**
   * Create a new sms channel on the senders individual sync team
   */
   async findTeamSendSms(
    context,
    data
  ) {
    const getProviderSpecialistResponse = await this.app.store.getProviderSpecialist(
      {
        'bot.Provider': context['bot.Provider'],
        userLocalId: context['bot.From'].localid
      }
    )

    if (
      !getProviderSpecialistResponse ||
      !getProviderSpecialistResponse.userGlobalId
    ) {
      await context.response.send(
        `Sorry, could not find your sync24-7 details;  please have the administrator remove and add you in the sync24-7 team again`
      )
      return
    }

    const { userGlobalId } = getProviderSpecialistResponse

    const specialist = await this.app.store.getSpecialist({ userGlobalId })

    if (!specialist || !specialist.virtualNumber) {
      await context.response.send(
        `Sorry, could not find a provisioned number for you;  please have the administrator reprovision your virtual number`
      )
      return
    }

    const teamRecord = await this.app.store.getVirtualNumberTeam({
      virtualNumber: specialist.virtualNumber
    })
    await this.smsFromExistingOrNewTeamsChannel(context, data, teamRecord)
  }

   async smsFromExistingOrNewTeamsChannel(
    context,
    data,
    teamRecord
  ) {
    const recipientNumber = `+${this.app.carrier.cleanNumber(data.number)}`

    void context.response.send(
      `Ok, creating an SMS conversation from ${this.app.carrier.beautifyNumber(
        teamRecord.virtualNumber
      )} to ${this.app.carrier.beautifyNumber(recipientNumber)} `
    )

    const activity = iopa_botadapter_src["MessageFactory"].attachment(
      iopa_botadapter_src["CardFactory"].reactiveCard(
        SmsCard({
          caption: `To ${this.app.carrier.beautifyNumber(
            recipientNumber
          )} From ${this.app.carrier.beautifyNumber(teamRecord.virtualNumber)}`,
          text: data.text
        })
      )
    )

    try {
      await this.app.teams.sendToExistingOrNewTeamsChannel(
        {
          provider: teamRecord['bot.Provider'],
          groupId: teamRecord.teamGlobalId,
          channelName: this.app.carrier
            .beautifyNumber(recipientNumber)
            .replace(/^\+/, ''),
          channelDescriptor: recipientNumber.replace(/^\+/, ''),
          botId: teamRecord.userLocalId,
          serviceUrl: teamRecord['bot.ServiceUrl'],
          activity
        },
        async (ctx) => {
          if (data.text) {
            await this.app.carrier.createSmsConversation(
              teamRecord.carrierProvider,
              teamRecord.virtualNumber,
              recipientNumber,
              async (smscontext) => {
                await smscontext['bot.Capability'].sendActivity(data.text)
              }
            )
          }

          if (context['bot.Channel'].id !== ctx['bot.Channel'].id) {
            await context.response.send(
              TeamChannelLinkCard({
                text: `Conversation with ${this.app.carrier.beautifyNumber(
                  recipientNumber
                )} initiated`,
                label: `View Channel`,
                'bot.Channel': ctx['bot.Channel'],
                tenant: "fbe59500-b0cc-491b-aa3e-ffaf2699aec9",
                'bot.Team': {
                  globalid: teamRecord.teamGlobalId
                }
              })
            )
          }
        }
      )
    } catch (ex) {
      console.error(ex)
    }
  }

  /**
   * Send a new message or reply from a sync-channel in microsoft teams directly to SMS recipient
   */
  async inParticipantChannelSendToSms(
    context,
    teamRecord
  ) {
    try {
      const channel = await this.app.msgraph.getChannel({
        groupid: teamRecord.teamGlobalId,
        channelid: context['bot.Channel'].id
      })

      if (!/^\d+$/.test(channel.description)) {
        await context.response.send(
          `[sync24-7] Not a recognized command and not on an inbound number channel ${channel.description};  try @sync help for available commands`
        )
        return
      }

      const fromNumber = teamRecord.virtualNumber
      const toNumber = `+${channel.description}`
      const text = context['bot.Text']

      await this.app.carrier.createSmsConversation(
        teamRecord.carrierProvider,
        fromNumber,
        toNumber,
        async (ctx) => {
          try {
            await ctx['bot.Capability'].sendActivity(text)
            console.log(
              `SENT SMS to ${teamRecord.carrierProvider} ${toNumber} from ${fromNumber}`
            )

            await context['bot.Capability'].sendActivity(
              iopa_botadapter_src["MessageFactory"].text(
                String.fromCharCode(0xd83d, 0xdc4d) // :thumbsup:
              )
            )
          } catch (ex) {
            context.error(ex)
            await context['bot.Capability'].sendActivity(
              iopa_botadapter_src["MessageFactory"].text(ex.message)
            )
          }
        }
      )

      await context.response.status(200).end()
    } catch (ex) {
      console.error(ex)
      await context['bot.Capability'].sendActivity(
        iopa_botadapter_src["MessageFactory"].text(ex.message)
      )
      await context.response.status(200).end()
    }
  }
});

function src_isNumeric(value) {
  return /^\d+$/.test(value)
}

// CONCATENATED MODULE: ../skill-sms-to-teams/src/index.tsx







/* harmony default export */ var skill_sms_to_teams_src = (class {
  






  constructor(
    app





  ) {
    this.app = app

    app.carrier.onMessage(
      async (
        context,
        next
      ) => {
        try {
          const virtualNumber = context['bot.Recipient'].localid
          const fromNumber = context['bot.From'].localid
          const text = context['bot.Text']

          const teamRecord = await this.app.store.getVirtualNumberTeam(
            { virtualNumber }
          )

          if (!teamRecord) {
            console.error(
              `Unknown team for incoming message to ${virtualNumber}`
            )
            return next()
          }

          console.log(
            `Incoming message from ${fromNumber} for team ${JSON.stringify(
              teamRecord.teamId
            )}`
          )

          const activity = iopa_botadapter_src["MessageFactory"].attachment(
            iopa_botadapter_src["CardFactory"].reactiveCard(
              SmsCard({
                caption: this.app.carrier.beautifyNumber(fromNumber),
                text
              })
            )
          )

          /*   if (teamRecord.conversationReference) {
                           const conversationReference: ConversationReference & { timestamp: number } = JSON.parse(teamRecord.conversationReference)
       
                           if (conversationReference.timestamp && (Date.now() - conversationReference.timestamp) < (1000 * 60 * 10)) {
       
                               await this.app.botadapter.continueConversation(JSON.parse(teamRecord.conversationReference), async (ctx) => {
                                   await ctx["bot.Capability"].sendActivity(activity)
                               })
       
                               return next()
                           }
       
                       } */

          await this.app.teams.sendToExistingOrNewTeamsChannel(
            {
              provider: teamRecord['bot.Provider'],
              groupId: teamRecord.teamGlobalId,
              channelName: this.app.carrier
                .beautifyNumber(fromNumber)
                .replace(/^\+/, ''),
              channelDescriptor: fromNumber.replace(/^\+/, ''),
              botId: teamRecord.userLocalId,
              serviceUrl: teamRecord['bot.ServiceUrl'],
              activity
            },
            () => Promise.resolve()
          )
        } catch (ex) {
          console.error(ex)
          return next()
        }

        return Promise.resolve() // skip remaining message handlers as now processed
      }
    )

    // Catch if unable to process
    app.carrier.onMessage(
      async (
        context,
        next
      ) => {
        console.log(
          `Unable to process inbound message to ${context['bot.Recipient'].localid}`
        )

        // TODO Save to slack or undeliverable table

        context.response['iopa.StatusCode'] = 500
        context.response['iopa.StatusText'] =
          'Unable to process inbound message'
        void context.response.end(null)
      }
    )
  }
});

// CONCATENATED MODULE: ../skill-voice-to-voice/src/index.tsx
/** @jsx ReactiveCards.h */
 // required for certain build packagers












const skill_voice_to_voice_src_ReactiveCardsFix = reactive_cards_src

const BEEP_MP3 = 'https://firebasestorage.googleapis.com/v0/b/karla-media.appspot.com/o/assets%2Fbeepbutton.mp3?alt=media&token=98fee557-d4ec-47c8-8e76-bd3aff1e4913'.replace(
  /&/g,
  '&amp;'
)

/* harmony default export */ var skill_voice_to_voice_src = (class {
  






  constructor(
    app





  ) {
    this.app = app

    if (!app.carrier) {
      console.error(app)
      throw new Error('App is missing carrier')
    }

    app.carrier.onCall(
      async (
        context,
        next
      ) => {
        if (
          context['bot.Capability'].activity.channelData.Direction ===
          'outbound-api'
        ) {
          return next()
        }

        const subtype = context['iopa.Url'].searchParams.get('subtype')

        switch (subtype) {
          case 'whisper':
            return this.onWhisperCall(context, next)
          case 'whispered':
            return this.onWhisperComplete(context, next)
          case 'callcomplete':
            return this.onCallComplete(context, next)
          case 'callbackoption':
            return this.onCallBackOption(context, next)
          case 'transcription':
            return this.onTranscription(context, next)
          case 'recordingcomplete':
            return this.onRecordingComplete(context, next)
          default:
            return this.onIncomingCall(context, next)
        }
      }
    )

    app.carrier.onCallStatus(
      async (
        context,
        next
      ) => {
        if (
          context['bot.Capability'].activity.channelData.Direction ===
          'outbound-api'
        ) {
          return onCallStatusOutbound(context, next)
        }

        if (
          context['bot.Capability'].activity.channelData.CallStatus ===
          'completed'
        ) {
          const virtualNumber = context['bot.Recipient'].localid
          const recipientNumber = context['bot.From'].localid

          const teamRecord = await this.app.store.getVirtualNumberTeam(
            { virtualNumber: context['bot.Recipient'].localid }
          )
          if (!teamRecord) {
            return next()
          }

          console.log(
            `Call Complete ${context['bot.From'].localid} to ${JSON.stringify(
              teamRecord.physicalNumber
            )}`
          )

          const { channelData } = context['bot.Capability'].activity
          const duration = channelData.CallDuration
          const title = duration < 61 ? 'Missed Inbound Call' : 'Inbound Call'
          const callerId = context['bot.From'].name

          const card = CallRecordCard({
            participantNumber: context['bot.Capability'].carrier.beautifyNumber(
              recipientNumber
            ),
            title,
            duration,
            callerId,
            callbackPayload: {
              'bot.Intent': 'urn:io.iopa.bot:intent:literal',
              'bot.Text': 'urn:com.sync247:carrier:clicktocall',
              'bot.Provider': context['bot.Provider'],
              physicalNumber: teamRecord.physicalNumber,
              virtualNumber,
              'bot.Recipient': recipientNumber
            }
          })

          await this.app.teams.sendToExistingOrNewTeamsChannel(
            {
              provider: teamRecord['bot.Provider'],
              groupId: teamRecord.teamGlobalId,
              channelName: this.app.carrier
                .beautifyNumber(recipientNumber)
                .replace(/^\+/, ''),
              channelDescriptor: recipientNumber.replace(/^\+/, ''),
              botId: teamRecord.userLocalId,
              serviceUrl: teamRecord['bot.ServiceUrl'],
              activity: iopa_botadapter_src["MessageFactory"].attachment(
                iopa_botadapter_src["CardFactory"].reactiveCard(card)
              )
            },
            () => Promise.resolve()
          )
        }

        return next()
      }
    )

    const onCallStatusOutbound = async (
      context,
      next
    ) => {
      const status = context['bot.Capability'].activity.channelData.CallStatus

      const physicalNumber = context['bot.Recipient'].localid
      const virtualNumber = context['bot.From'].localid
      const recipientNumber = `+${context['iopa.Url'].searchParams.get(
        'recipient'
      )}`

      const teamRecord = await this.app.store.getVirtualNumberTeam({
        virtualNumber
      })

      if (!teamRecord) {
        return next()
      }

      console.log(
        `Outbound Call Complete ${physicalNumber} to ${recipientNumber}`
      )

      const { channelData } = context['bot.Capability'].activity
      const duration = channelData.CallDuration
      const title = duration < 61 ? 'Outbound Call Attempt' : 'Outbound Call'

      const card = CallRecordCard({
        participantNumber: context['bot.Capability'].carrier.beautifyNumber(
          recipientNumber
        ),
        title,
        duration,
        status,
        callbackPayload: {
          'bot.Intent': 'urn:io.iopa.bot:intent:literal',
          'bot.Text': 'urn:com.sync247:carrier:clicktocall',
          'bot.Provider': context['bot.Provider'],
          physicalNumber,
          virtualNumber,
          'bot.Recipient': recipientNumber
        }
      })

      await this.app.teams.sendToExistingOrNewTeamsChannel(
        {
          provider: teamRecord['bot.Provider'],
          groupId: teamRecord.teamGlobalId,
          channelDescriptor: recipientNumber.replace(/^\+/, ''),
          channelName: this.app.carrier
            .beautifyNumber(recipientNumber)
            .replace(/^\+/, ''),
          botId: teamRecord.userLocalId,
          serviceUrl: teamRecord['bot.ServiceUrl'],
          activity: iopa_botadapter_src["MessageFactory"].attachment(iopa_botadapter_src["CardFactory"].reactiveCard(card))
        },
        () => Promise.resolve()
      )

      return next()
    }

    app.botadapter.onActionInvoke(
      async (
        context,
        value






,
        next
      ) => {
        if (
          value['bot.Intent'] === 'urn:io.iopa.bot:intent:literal' &&
          value['bot.Text'] === 'urn:com.sync247:carrier:clicktocall'
        ) {
          await context.response.send('Ok, connecting')

          await app.carrier.clickToCall({
            provider: value['bot.Provider'],
            baseUrl: app.carrier.getBaseUrl(context),
            physicalNumber: value.physicalNumber,
            virtualNumber: value.virtualNumber,
            recipientNumber: value['bot.Recipient']
          })
        }

        return next()
      }
    )
  }

  async onIncomingCall(
    context,
    next
  ) {
    const teamRecord = await this.app.store.getVirtualNumberTeam({
      virtualNumber: context['bot.Recipient'].localid
    })

    if (!teamRecord) {
      console.error(
        new Error(
          `[skill-voice-to-voice.onIncomingCall] could you find virtual number ${context['bot.Recipient'].localid}`
        )
      )
      return next()
    }

    console.log(
      `Transferring voice call from ${
        context['bot.From'].localid
      } to ${JSON.stringify(teamRecord.physicalNumber)}`
    )

    const whisperCallUrl = getSubTypeUrl(context, 'whisper')
    const callCompleteUrl = getSubTypeUrl(context, 'callcomplete')

    void context.response.end(
      `<?xml version="1.0" encoding="UTF-8"?>
    <Response>
        <Dial answerOnBridge="true" action="${callCompleteUrl}" timeout="12">
        <Number url="${whisperCallUrl}">${teamRecord.physicalNumber}</Number>
        </Dial>
    </Response>`,
      { status: 200 }
    )
    return next()
  }

  async onWhisperCall(
    context,
    next
  ) {
    console.log(`Whisper call from ${context['bot.From'].localid}`)
    const whisperCompleteUrl = getSubTypeUrl(context, 'whispered')

    void context.response.end(
      `<?xml version="1.0" encoding="UTF-8"?>
            <Response>
              <Gather action="${whisperCompleteUrl}" timeout="5" numDigits="1"><Say voice="alice" language="en-GB"> Press 1 to accept call from Sync Health, any other key to reject</Say></Gather>
              <Hangup />
            </Response>`,
      { status: 200 }
    )
    return next()
  }

  async onWhisperComplete(
    context,
    next
  ) {
    const digits = context['bot.Capability'].activity.channelData.Digits
    console.log(
      `Whisper disposition ${JSON.stringify(digits)} ${
        context['bot.From'].localid
      }`
    )

    if (digits === '1') {
      void context.response.end(
        `<?xml version="1.0" encoding="UTF-8"?><Response></Response>`,
        { status: 200 }
      )
      return next()
    }
    void context.response.end(
      `<?xml version="1.0" encoding="UTF-8"?>
      <Response>
        <Hangup/>
      </Response>
   `,
      { status: 200 }
    )
    return next()
  }

  async onCallComplete(
    context,
    next
  ) {
    const { activity } = context['bot.Capability']

    if (
      activity.channelData.DialCallStatus === 'completed' ||
      activity.channelData.DialCallStatus === 'answered'
    ) {
      void context.response.end(
        `<?xml version="1.0" encoding="UTF-8"?>
            <Response>
               <Play>${BEEP_MP3}</Play>
              <Hangup />
            </Response>`,
        { status: 200 }
      )
      return next()
    }

    console.log(
      `Gathering callback options for missed call from ${context['bot.From'].localid}`
    )
    const callBackOptionUrl = getSubTypeUrl(context, 'callbackoption')

    const teamRecord = await this.app.store.getVirtualNumberTeam({
      virtualNumber: context['bot.Recipient'].localid
    })

    let voiceMailText

    if (!teamRecord) {
      console.error(
        new Error(
          `[skill-voice-to-voice.onIncomingCall] could not find virtual number ${context['bot.Recipient'].localid}`
        )
      )
    } else {
      voiceMailText = teamRecord.voicemailText
    }

    voiceMailText =
      voiceMailText ||
      `Thank you for calling Sync Health.   If you need emergency assistance, please hang up and dial nine one one immediately.  If you arenât in an emergency, please press 1 and one of our associates will return a call to the number you called from. Or press any other key or remain on the line to leave a message. One of our associates will return your call or voicemail at our soonest opportunity, within one business day.  Thank you again for calling, we look forward to speaking with you soon.
 `

    void context.response.end(
      `<?xml version="1.0" encoding="UTF-8"?>
        <Response>
          <Gather action="${callBackOptionUrl}" actionOnEmptyResult="true" timeout="10" numDigits="1">
          <Say voice="alice" language="en-GB">${voiceMailText}</Say>
          </Gather>
        </Response>
     `,
      { status: 200 }
    )

    return next()
  }

  async onCallBackOption(
    context,
    next
  ) {
    const digits = context['bot.Capability'].activity.channelData.Digits

    console.log(
      `Callback disposition ${JSON.stringify(digits)} ${
        context['bot.From'].localid
      }`
    )

    const transcriptionUrl = getSubTypeUrl(context, 'transcription')
    const recordingCompleteUrl = getSubTypeUrl(context, 'recordingcomplete')

    if (digits === '1') {
      void context.response.end(
        `<?xml version="1.0" encoding="UTF-8"?>
          <Response>
            <Play>${BEEP_MP3}</Play>
            <Say voice="alice" language="en-GB"> Ok, we'll call you back on this number.</Say>
            <Hangup />
          </Response>`,
        { status: 200 }
      )

      const teamRecord = await this.app.store.getVirtualNumberTeam({
        virtualNumber: context['bot.Recipient'].localid
      })

      await this.app.teams.sendToExistingOrNewTeamsChannel(
        {
          provider: teamRecord['bot.Provider'],
          groupId: teamRecord.teamGlobalId,
          channelDescriptor: context['bot.From'].localid.replace(/^\+/, ''),
          channelName: this.app.carrier
            .beautifyNumber(context['bot.From'].localid)
            .replace(/^\+/, ''),
          botId: teamRecord.userLocalId,
          serviceUrl: teamRecord['bot.ServiceUrl'],
          activity: iopa_botadapter_src["MessageFactory"].text(
            `Call back requested from ${this.app.carrier
              .beautifyNumber(context['bot.From'].localid)
              .replace(/^\+/, '')}`
          )
        },
        () => Promise.resolve()
      )

      return next()
    }
    void context.response.end(
      `<?xml version="1.0" encoding="UTF-8"?>
      <Response>
        <Say voice="alice" language="en-GB">Please leave a message after the beep and press pound when you're done.</Say>
        <Record action="${recordingCompleteUrl}" finishOnKey="#" transcribe="true" transcribeCallback="${transcriptionUrl}" />
        <Hangup />
      </Response>
   `,
      { status: 200 }
    )
    return next()
  }

  async onRecordingComplete(
    context,
    next
  ) {
    const teamRecord = await this.app.store.getVirtualNumberTeam({
      virtualNumber: context['bot.Recipient'].localid
    })
    console.log(
      `Recording complete ${context['bot.From'].localid} to ${JSON.stringify(
        teamRecord.physicalNumber
      )}`
    )

    void context.response.end(
      `<?xml version="1.0" encoding="UTF-8"?>
      <Response>
        <Say voice="alice" language="en-GB">Thanks, your message has been sent.</Say>
        <Play>${BEEP_MP3}</Play>
        <Hangup />
      </Response>
   `,
      { status: 200 }
    )

    await this.app.teams.sendToExistingOrNewTeamsChannel(
      {
        provider: teamRecord['bot.Provider'],
        groupId: teamRecord.teamGlobalId,
        channelDescriptor: context['bot.From'].localid.replace(/^\+/, ''),
        channelName: this.app.carrier
          .beautifyNumber(context['bot.From'].localid)
          .replace(/^\+/, ''),
        botId: teamRecord.userLocalId,
        serviceUrl: teamRecord['bot.ServiceUrl'],
        activity: iopa_botadapter_src["MessageFactory"].text(
          `Processing voice mail from ${this.app.carrier
            .beautifyNumber(context['bot.From'].localid)
            .replace(/^\+/, '')}`
        )
      },
      () => Promise.resolve()
    )

    return next()
  }

  async onTranscription(
    context,
    next
  ) {
    const virtualNumber = context['bot.Recipient'].localid
    const fromNumber = context['bot.From'].localid
    const teamRecord = await this.app.store.getVirtualNumberTeam({
      virtualNumber
    })
    console.log(
      `Transcribe ${fromNumber} to ${JSON.stringify(teamRecord.physicalNumber)}`
    )

    const { channelData } = context['bot.Capability'].activity

    if (channelData.TranscriptionText || channelData.RecordingUrl) {
      let recordingUrl
      if (channelData.RecordingUrl.startsWith('/')) {
        recordingUrl = await this.app.carrier.getRecordingUrl(
          context['bot.Provider'],
          channelData.RecordingUrl
        )
      } else {
        recordingUrl = channelData.RecordingUrl
      }

      const activity = iopa_botadapter_src["MessageFactory"].attachment(
        iopa_botadapter_src["CardFactory"].reactiveCard(
          VoiceMailCard({
            text: channelData.TranscriptionText || 'no transcription available',
            fromNumber: this.app.carrier.beautifyNumber(fromNumber),
            toNumber: this.app.carrier.beautifyNumber(virtualNumber),
            callerId: context['bot.From'].name,
            recordingUrl,
            callbackPayload: {
              'bot.Intent': 'urn:io.iopa.bot:intent:literal',
              'bot.Text': 'urn:com.sync247:carrier:clicktocall',
              'bot.Provider': context['bot.Provider'],
              physicalNumber: teamRecord.physicalNumber,
              virtualNumber,
              'bot.Recipient': fromNumber
            }
          })
        )
      )

      await this.app.teams.sendToExistingOrNewTeamsChannel(
        {
          provider: teamRecord['bot.Provider'],
          groupId: teamRecord.teamGlobalId,
          channelDescriptor: fromNumber.replace(/^\+/, ''),
          channelName: this.app.carrier
            .beautifyNumber(fromNumber)
            .replace(/^\+/, ''),
          botId: teamRecord.userLocalId,
          serviceUrl: teamRecord['bot.ServiceUrl'],
          activity
        },
        () => Promise.resolve()
      )
    } else {
      console.log('no transcription available')
      /* noop -- handled in callstatus handler */
    }

    void context.response.end()
    return next()
  }
});

function getSubTypeUrl(context, subtype) {
  const provider = context['bot.Provider']
  const type = context['iopa.Url'].searchParams.get('type')
  const callback_token = encodeURIComponent(
    context['iopa.Url'].searchParams.get('callback_token')
  )

  return `${context['iopa.Url'].protocol}//${context['iopa.Url'].hostname}${context['iopa.Path']}?provider=${provider}&amp;type=${type}&amp;callback_token=${callback_token}&amp;subtype=${subtype}`
}

// CONCATENATED MODULE: ../skill-teams-to-voice/src/index.tsx










/* harmony default export */ var skill_teams_to_voice_src = (class {
  








  constructor(
    app







  ) {
    this.app = app

    app.bot
      .command('call [number]')
      .alias('voice')
      .description('Start a voice call with a new or existing participant')
      .action(async (context, data) => {
        const teamId = context['bot.Team'].id

        if (!teamId) {
          /** 1 on 1 chat */
          await this.findTeamCreateVoiceCall(context, data)
          return
        }

        const teamRecord = await this.app.store.getTeam({ teamId })

        if (!teamRecord || !teamRecord.virtualNumber) {
          await this.findTeamCreateVoiceCall(context, data)
          return
        }

        // On a provisioned team

        const channel = await this.app.msgraph.getChannel({
          groupid: teamRecord.teamGlobalId,
          channelid: context['bot.Channel'].id
        })

        if (!data.number) {
          if (!/^\d+$/.test(channel.description)) {
            await context.response.send(
              `[sync24-7] To voice call a parcipant you must either provide a number to dial, or invoke the "call"/"voice" command on a participant channel not [${channel.description}]`
            )
            return
          }

          // On a provisioned team and participant numeric channel, no number provided as expected; call this participant

          const recipientNumber = channel.description

          await context.response.send(
            `Ok, creating a voice call from ${this.app.carrier.beautifyNumber(
              teamRecord.physicalNumber
            )} to ${this.app.carrier.beautifyNumber(recipientNumber)} `
          )

          await this.app.carrier.clickToCall({
            provider: teamRecord.carrierProvider,
            baseUrl: this.app.carrier.getBaseUrl(context),
            physicalNumber: teamRecord.physicalNumber,
            virtualNumber: teamRecord.virtualNumber,
            recipientNumber
          })
        } else {
          if (!/^\d+$/.test(channel.description)) {
            // On a general or alphanumeric non-participant channel of a provisioned team
            await this.callFromExistingOrNewTeamsChannel(
              context,
              data,
              teamRecord
            )
            return
          }

          const recipientNumber = app.carrier.cleanNumber(data.number)

          if (app.carrier.cleanNumber(data.number) !== channel.description) {
            await context.response.send(
              `When used in conjuction with a number [${data.number}], the "voice"/"call" command should be requested from the *General* channel or 1-on-bot chat.  To avoid confusion, I haven't initiated a call so please try this command again without the number to call the participant identified by this channel or try again with the number from the general channel or 1 on 1 chat`
            )

            return
          }

          // OK, on a provisioned team and participant numeric channel, and number provided matches the channel

          await context.response.send(
            `Ok, creating a voice call from ${this.app.carrier.beautifyNumber(
              teamRecord.physicalNumber
            )} to ${this.app.carrier.beautifyNumber(
              recipientNumber
            )};  next time you don't need to retype the participant's phone number if the "call"/"voice" command is used on a participant channel like this `
          )

          await this.app.carrier.clickToCall({
            provider: teamRecord.carrierProvider,
            baseUrl: this.app.carrier.getBaseUrl(context),
            physicalNumber: teamRecord.physicalNumber,
            virtualNumber: teamRecord.virtualNumber,
            recipientNumber
          })
        }
      })
  }

  /**
   * Create a new participant channel on the senders individual sync team
   */
   async findTeamCreateVoiceCall(
    context,
    data
  ) {
    const getProviderSpecialistResponse = await this.app.store.getProviderSpecialist(
      {
        'bot.Provider': context['bot.Provider'],
        userLocalId: context['bot.From'].localid
      }
    )

    if (
      !getProviderSpecialistResponse ||
      !getProviderSpecialistResponse.userGlobalId
    ) {
      console.error(
        `[skill-teams-to-voice] Could not find specialist in KV: ${JSON.stringify(
          {
            'bot.Provider': context['bot.Provider'],
            userLocalId: context['bot.From'].localid
          }
        )} ${JSON.stringify(getProviderSpecialistResponse)}`
      )

      await context.response.send(
        `Sorry, could not find your sync24-7 details;  please have the administrator remove and add you in the sync24-7 team again`
      )
      return
    }

    const { userGlobalId } = getProviderSpecialistResponse

    const specialist = await this.app.store.getSpecialist({ userGlobalId })

    if (!specialist || !specialist.virtualNumber) {
      await context.response.send(
        `Sorry, could not find a provisioned number for you;  please have the administrator reprovision your virtual number`
      )
      return
    }

    const teamRecord = await this.app.store.getVirtualNumberTeam({
      virtualNumber: specialist.virtualNumber
    })
    await this.callFromExistingOrNewTeamsChannel(context, data, teamRecord)
  }

  /**
   * Create a new participant channel on the senders individual sync team
   */
   async callFromExistingOrNewTeamsChannel(
    context,
    data,
    teamRecord
  ) {
    const recipientNumber = `+${this.app.carrier.cleanNumber(data.number)}`
    await context.response.send(
      `Ok, creating a voice call from ${this.app.carrier.beautifyNumber(
        teamRecord.physicalNumber
      )} to ${this.app.carrier.beautifyNumber(recipientNumber)} `
    )
    const activity = iopa_botadapter_src["MessageFactory"].text(
      `Initiating voice call from ${this.app.carrier.beautifyNumber(
        teamRecord.physicalNumber
      )} to ${this.app.carrier.beautifyNumber(recipientNumber)} `
    )

    try {
      await this.app.teams.sendToExistingOrNewTeamsChannel(
        {
          provider: teamRecord['bot.Provider'],
          groupId: teamRecord.teamGlobalId,
          channelDescriptor: recipientNumber.replace(/^\+/, ''),
          channelName: this.app.carrier
            .beautifyNumber(recipientNumber)
            .replace(/^\+/, ''),
          botId: teamRecord.userLocalId,
          serviceUrl: teamRecord['bot.ServiceUrl'],
          activity
        },
        async (ctx) => {
          await this.app.carrier.clickToCall({
            provider: teamRecord.carrierProvider,
            baseUrl: this.app.carrier.getBaseUrl(context),
            physicalNumber: teamRecord.physicalNumber,
            virtualNumber: teamRecord.virtualNumber,
            recipientNumber
          })

          if (context['bot.Channel'].id !== ctx['bot.Channel'].id) {
            await context.response.send(
              TeamChannelLinkCard({
                text: `Voice call with ${this.app.carrier.beautifyNumber(
                  recipientNumber
                )} initiated`,
                label: `View Channel`,
                'bot.Channel': ctx['bot.Channel'],
                tenant: "fbe59500-b0cc-491b-aa3e-ffaf2699aec9",
                'bot.Team': {
                  globalid: teamRecord.teamGlobalId
                }
              })
            )
          }
        }
      )
    } catch (ex) {
      console.error(ex)
    }
  }
});

// CONCATENATED MODULE: ./src/index.ts





















const { name: src_name, version } = __webpack_require__(359)

/* harmony default export */ var src_0 = (function (
  app







) {
  // Default Iopa App (catch-all)
  app[iopa_src["f" /* constants */].APPBUILDER.DefaultApp] = async (context, next) => {
    if (context['bot.Source'] === iopa_botadapter_src["URN_BOTADAPTER"]) {
      const botCapabilityContext = context 
      console.log(
        `Bot activity ${botCapabilityContext['bot.Provider']} ${botCapabilityContext['bot.ActivityType']}`
      )
      void context.response.end({ status: 200 })
    } else if (context['bot.Source'] === iopa_carrier_src["URN_CARRIER"]) {
      void context.response.end(
        `<?xml version="1.0" encoding="UTF-8"?><Response></Response>`,
        { status: 200 }
      )
    } else {
      context.response['iopa.StatusCode'] = 404
      void context.response.end('SYNC247-404 Resource was not found')
    }
  }

  // Core capabilities
  app.use(src_Router, 'Router')
  app.use(Sync247StoreCapability, 'CapabilitySync247Store')
  app.use(src_MicrosoftGraphCapability, 'CapabilityMicrosoftGraph')

  // Bot pipeline, after core, before application
  app.use(src_CapabilityMicrosoftTeams, 'CapabilityTeams')
  app.use(src_CarrierCapability, 'CapabilityCarrier')

  // Teams sub-App
  const teamsApp = app.fork(
    (context) =>
      context['bot.Provider'] === 'msteams' ||
      context['bot.Provider'] === 'emulator'
  ) 








  teamsApp.carrier = app.carrier
  teamsApp.db = app.db
  teamsApp.botadapter = app.botadapter

  teamsApp
    .use(iopa_botcommander_src["a" /* BotCommanderMiddleware */], 'BotCommanderMiddleware')
    .use(skill_provision_src, 'SkillProvision')
    .use(skill_membership_src, 'SkillMembership')
    .use(skill_teams_to_sms_src, 'SkillTeamsToSms')
    .use(skill_teams_to_voice_src, 'SkillTeamsToVoice')
  ;['botadapter', 'msgraph', 'store', 'carrier', 'teams'].forEach((prop) => {
    teamsApp[prop] = app[prop]
  })

  app.bot = teamsApp.bot

  // SMS sub-App
  const smsApp = app.fork(
    (context) =>
      context['bot.Provider'] === 'signalwire' ||
      context['bot.Provider'] === 'twilio'
  ) 








  ;['bot', 'botadapter', 'msgraph', 'store', 'carrier', 'teams'].forEach(
    (prop) => {
      smsApp[prop] = app[prop]
    }
  )

  smsApp.carrier = app.carrier
  smsApp.botadapter = app.botadapter
  smsApp.db = app.db
  smsApp.bot = app.bot

  smsApp
    .use(skill_voice_to_voice_src, 'SkillVoiceToVoice')
    .use(skill_sms_to_teams_src, 'SkillSmsToTeams')

  // Main App
  app.use(VersionPlugin, 'VersionPlugin')
});

class VersionPlugin {
   constructor(app) {
    app.get('/client/v1.0.0/version', (context) => {
      console.log('dev')
      return context.response.send(
        `CloudFlare ${"development"} ${context['iopa.Url'].hostname} package ${src_name} version ${version}`
      )
    })
  }
}

// CONCATENATED MODULE: ./src/entry-cloudflare.ts



const entry_cloudflare_app = Object(src["a" /* default */])()
entry_cloudflare_app.use(src_0, 'entry-cloudflare')
entry_cloudflare_app.build()


/***/ })
/******/ ]);